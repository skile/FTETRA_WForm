//   NOTE: this is a machine generated file--editing not recommended
//
// acapi.cpp - class member functions for ASN.1 module ACAPI
//
//   This file was generated by snacc on Tue Apr 25 09:49:14 2006
//   UBC snacc written by Mike Sample


#include "acapi.h"

namespace SNACC{
//------------------------------------------------------------------------------
// value defs


//------------------------------------------------------------------------------
// class member definitions:

Integer16 & 
Integer16::operator =(const Integer16 &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
Integer16::ValueRanges(int &sizeVRList) const
{
		static const ValueRange Integer16_ValueRangeList[] = 
			{{ 0, 65535, 1 }};

		sizeVRList = 1;
		return &Integer16_ValueRangeList[0];
}

SSIType & 
SSIType::operator =(const SSIType &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
SSIType::ValueRanges(int &sizeVRList) const
{
		static const ValueRange SSIType_ValueRangeList[] = 
			{{ 0, 16777215, 1 }};

		sizeVRList = 1;
		return &SSIType_ValueRangeList[0];
}

MCCType & 
MCCType::operator =(const MCCType &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
MCCType::ValueRanges(int &sizeVRList) const
{
		static const ValueRange MCCType_ValueRangeList[] = 
			{{ 0, 1023, 1 }};

		sizeVRList = 1;
		return &MCCType_ValueRangeList[0];
}

MNCType & 
MNCType::operator =(const MNCType &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
MNCType::ValueRanges(int &sizeVRList) const
{
		static const ValueRange MNCType_ValueRangeList[] = 
			{{ 0, 16383, 1 }};

		sizeVRList = 1;
		return &MNCType_ValueRangeList[0];
}

const SizeConstraint*  
DialingString::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint DialingString_SizeConstraintList[] = 
			{{ 1, 24, 1 }};

	sizeList = 1;
	return &DialingString_SizeConstraintList[0];
}


const char*  
DialingString::PermittedAlphabet(int &sizePermittedAlpha)const
{

	static const char alpha[] = {0x23,0x2a,0x2c,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39};
	sizePermittedAlpha = 13;
	return alpha;
}


const SizeConstraint*  
DTMFString::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint DTMFString_SizeConstraintList[] = 
			{{ 1, 255, 1 }};

	sizeList = 1;
	return &DTMFString_SizeConstraintList[0];
}


const char*  
DTMFString::PermittedAlphabet(int &sizePermittedAlpha)const
{

	static const char alpha[] = {0x23,0x2a,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44};
	sizePermittedAlpha = 16;
	return alpha;
}


const SizeConstraint*  
SDSDataTypeSeq::SdsData::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint sdsData_SizeConstraintList[] = 
			{{ 0, 256, 1 }};

	sizeList = 1;
	return &sdsData_SizeConstraintList[0];
}


SDSDataTypeSeq::BitLength & 
SDSDataTypeSeq::BitLength::operator =(const BitLength &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
SDSDataTypeSeq::BitLength::ValueRanges(int &sizeVRList) const
{
		static const ValueRange bitLength_ValueRangeList[] = 
			{{ 0, 2047, 1 }};

		sizeVRList = 1;
		return &bitLength_ValueRangeList[0];
}

void SDSDataTypeSeq::Init(void)
{
  bitLength = NULL;
}


int SDSDataTypeSeq::checkConstraints(ConstraintFailList* pConstraintFails) const{
	sdsData.checkConstraints(pConstraintFails);

	if (bitLength != NULL)
		bitLength->checkConstraints(pConstraintFails);

	return 0;
}


void SDSDataTypeSeq::Clear()
{
  if(bitLength)
    delete bitLength;
  bitLength = NULL;
}

SDSDataTypeSeq::SDSDataTypeSeq(const SDSDataTypeSeq &that)
{
   Init();
   *this = that;
}
AsnType *SDSDataTypeSeq::Clone() const
{
  return new SDSDataTypeSeq(*this);
}

SDSDataTypeSeq &SDSDataTypeSeq::operator = (const SDSDataTypeSeq &that)
{
  if (this != &that)
  {
    Clear();
    sdsData = that.sdsData;
    if (that.bitLength)
    {
      if (!bitLength)
        bitLength = new BitLength;
      *bitLength = *that.bitLength;
    }
    else
    {
      delete bitLength;
      bitLength = NULL;
    }
  }

  return *this;
}

AsnLen
SDSDataTypeSeq::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (bitLength))
  {
    l = bitLength->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

    l = sdsData.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // SDSDataTypeSeq::BEncContent


void SDSDataTypeSeq::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SDSDataTypeSeq::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    sdsData.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  bitLength = new BitLength;
    bitLength->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SDSDataTypeSeq::BDecContent

AsnLen SDSDataTypeSeq::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SDSDataTypeSeq::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SDSDataTypeSeq::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SDSDataTypeSeq::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "sdsData ";
	sdsData.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (bitLength))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "bitLength ";
		bitLength->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SDSDataTypeSeq::Print()

void SDSDataTypeSeq::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    sdsData.PrintXML(os, "sdsData");

  if (NOT_NULL (bitLength))
  {
    bitLength->PrintXML(os, "bitLength");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SDSDataTypeSeq::PrintXML


void ACAPI_Transport_Ack::Init(void)
{
}


int ACAPI_Transport_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	timeStamp.checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_Transport_Ack::Clear()
{
}

ACAPI_Transport_Ack::ACAPI_Transport_Ack(const ACAPI_Transport_Ack &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_Transport_Ack::Clone() const
{
  return new ACAPI_Transport_Ack(*this);
}

ACAPI_Transport_Ack &ACAPI_Transport_Ack::operator = (const ACAPI_Transport_Ack &that)
{
  if (this != &that)
  {
    Clear();
    timeStamp = that.timeStamp;
  }

  return *this;
}

AsnLen
ACAPI_Transport_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_Transport_Ack::BEncContent


void ACAPI_Transport_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Transport_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_Transport_Ack::BDecContent

AsnLen ACAPI_Transport_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 2);
  return l;
}

void ACAPI_Transport_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Transport_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 2))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_Transport_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_Transport_Ack::Print()

void ACAPI_Transport_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    timeStamp.PrintXML(os, "timeStamp");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_Transport_Ack::PrintXML


void ACAPI_Message_Ack::Init(void)
{
}


int ACAPI_Message_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	timeStamp.checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_Message_Ack::Clear()
{
}

ACAPI_Message_Ack::ACAPI_Message_Ack(const ACAPI_Message_Ack &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_Message_Ack::Clone() const
{
  return new ACAPI_Message_Ack(*this);
}

ACAPI_Message_Ack &ACAPI_Message_Ack::operator = (const ACAPI_Message_Ack &that)
{
  if (this != &that)
  {
    Clear();
    timeStamp = that.timeStamp;
  }

  return *this;
}

AsnLen
ACAPI_Message_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_Message_Ack::BEncContent


void ACAPI_Message_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Message_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_Message_Ack::BDecContent

AsnLen ACAPI_Message_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 16);
  return l;
}

void ACAPI_Message_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Message_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 16))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_Message_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_Message_Ack::Print()

void ACAPI_Message_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    timeStamp.PrintXML(os, "timeStamp");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_Message_Ack::PrintXML


void SS_CallForwardCancelAll::Init(void)
{
}


int SS_CallForwardCancelAll::checkConstraints(ConstraintFailList* pConstraintFails) const{
	return 0;
}


void SS_CallForwardCancelAll::Clear()
{
}

SS_CallForwardCancelAll::SS_CallForwardCancelAll(const SS_CallForwardCancelAll &that)
{
   Init();
   *this = that;
}
AsnType *SS_CallForwardCancelAll::Clone() const
{
  return new SS_CallForwardCancelAll(*this);
}

SS_CallForwardCancelAll &SS_CallForwardCancelAll::operator = (const SS_CallForwardCancelAll &that)
{
  if (this != &that)
  {
    Clear();
  }

  return *this;
}

AsnLen
SS_CallForwardCancelAll::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  return totalLen;
} // SS_CallForwardCancelAll::BEncContent


void SS_CallForwardCancelAll::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardCancelAll::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  if (elmtLen0 == INDEFINITE_LEN)
    BDecEoc (_b, bytesDecoded);
  else if (elmtLen0 != 0)
  {
          throw EXCEPT("Expected an empty sequence", DECODE_ERROR);
  }
} // SS_CallForwardCancelAll::BDecContent

AsnLen SS_CallForwardCancelAll::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 68);
  return l;
}

void SS_CallForwardCancelAll::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardCancelAll::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 68))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_CallForwardCancelAll::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
	int nonePrinted = true;
++indent;

	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_CallForwardCancelAll::Print()

void SS_CallForwardCancelAll::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_CallForwardCancelAll::PrintXML


void SS_CallForwardInterrogate::Init(void)
{
  startSSI = NULL;
  endSSI = NULL;
  maxTransferredEntries = NULL;
}


int SS_CallForwardInterrogate::checkConstraints(ConstraintFailList* pConstraintFails) const{
	if (startSSI != NULL)
		startSSI->checkConstraints(pConstraintFails);

	if (endSSI != NULL)
		endSSI->checkConstraints(pConstraintFails);

	if (maxTransferredEntries != NULL)
		maxTransferredEntries->checkConstraints(pConstraintFails);

	return 0;
}


void SS_CallForwardInterrogate::Clear()
{
  if(startSSI)
    delete startSSI;
  startSSI = NULL;
  if(endSSI)
    delete endSSI;
  endSSI = NULL;
  if(maxTransferredEntries)
    delete maxTransferredEntries;
  maxTransferredEntries = NULL;
}

SS_CallForwardInterrogate::SS_CallForwardInterrogate(const SS_CallForwardInterrogate &that)
{
   Init();
   *this = that;
}
AsnType *SS_CallForwardInterrogate::Clone() const
{
  return new SS_CallForwardInterrogate(*this);
}

SS_CallForwardInterrogate &SS_CallForwardInterrogate::operator = (const SS_CallForwardInterrogate &that)
{
  if (this != &that)
  {
    Clear();
    if (that.startSSI)
    {
      if (!startSSI)
        startSSI = new AsnInt;
      *startSSI = *that.startSSI;
    }
    else
    {
      delete startSSI;
      startSSI = NULL;
    }
    if (that.endSSI)
    {
      if (!endSSI)
        endSSI = new AsnInt;
      *endSSI = *that.endSSI;
    }
    else
    {
      delete endSSI;
      endSSI = NULL;
    }
    if (that.maxTransferredEntries)
    {
      if (!maxTransferredEntries)
        maxTransferredEntries = new AsnInt;
      *maxTransferredEntries = *that.maxTransferredEntries;
    }
    else
    {
      delete maxTransferredEntries;
      maxTransferredEntries = NULL;
    }
  }

  return *this;
}

AsnLen
SS_CallForwardInterrogate::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (maxTransferredEntries))
  {
    l = maxTransferredEntries->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (endSSI))
  {
    l = endSSI->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

  if (NOT_NULL (startSSI))
  {
    l = startSSI->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;
  }

  return totalLen;
} // SS_CallForwardInterrogate::BEncContent


void SS_CallForwardInterrogate::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardInterrogate::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (_b, seqBytesDecoded);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  startSSI = new AsnInt;
    startSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  endSSI = new AsnInt;
    endSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  maxTransferredEntries = new AsnInt;
    maxTransferredEntries->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_CallForwardInterrogate::BDecContent

AsnLen SS_CallForwardInterrogate::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag3 (_b, APPL, CONS, 130);
  return l;
}

void SS_CallForwardInterrogate::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardInterrogate::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 130))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_CallForwardInterrogate::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
	int nonePrinted = true;
++indent;

	if (NOT_NULL (startSSI))
	{
		nonePrinted = false;
		Indent(os, indent);
		os << "startSSI ";
		startSSI->Print(os, indent);
	}

	if (NOT_NULL (endSSI))
	{
		if (!nonePrinted)
			os << "," << std::endl;
		nonePrinted = false;
		Indent(os, indent);
		os << "endSSI ";
		endSSI->Print(os, indent);
	}

	if (NOT_NULL (maxTransferredEntries))
	{
		if (!nonePrinted)
			os << "," << std::endl;
		nonePrinted = false;
		Indent(os, indent);
		os << "maxTransferredEntries ";
		maxTransferredEntries->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_CallForwardInterrogate::Print()

void SS_CallForwardInterrogate::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
  if (NOT_NULL (startSSI))
  {
    startSSI->PrintXML(os, "startSSI");
  }

  if (NOT_NULL (endSSI))
  {
    endSSI->PrintXML(os, "endSSI");
  }

  if (NOT_NULL (maxTransferredEntries))
  {
    maxTransferredEntries->PrintXML(os, "maxTransferredEntries");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_CallForwardInterrogate::PrintXML


void MON_Data_Ack::Init(void)
{
}


int MON_Data_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageAck.checkConstraints(pConstraintFails);

	return 0;
}


void MON_Data_Ack::Clear()
{
}

MON_Data_Ack::MON_Data_Ack(const MON_Data_Ack &that)
{
   Init();
   *this = that;
}
AsnType *MON_Data_Ack::Clone() const
{
  return new MON_Data_Ack(*this);
}

MON_Data_Ack &MON_Data_Ack::operator = (const MON_Data_Ack &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageAck = that.monMessageAck;
  }

  return *this;
}

AsnLen
MON_Data_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = monMessageAck.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Data_Ack::BEncContent


void MON_Data_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Data_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageAck.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Data_Ack::BDecContent

AsnLen MON_Data_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 74);
  return l;
}

void MON_Data_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Data_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 74))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Data_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageAck ";
	monMessageAck.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Data_Ack::Print()

void MON_Data_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageAck.PrintXML(os, "monMessageAck");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Data_Ack::PrintXML


LeasedLineType::ChannelID & 
LeasedLineType::ChannelID::operator =(const ChannelID &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
LeasedLineType::ChannelID::ValueRanges(int &sizeVRList) const
{
		static const ValueRange channelID_ValueRangeList[] = 
			{{ 1, 31, 1 }};

		sizeVRList = 1;
		return &channelID_ValueRangeList[0];
}

LeasedLineType::SubChannelID & 
LeasedLineType::SubChannelID::operator =(const SubChannelID &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
LeasedLineType::SubChannelID::ValueRanges(int &sizeVRList) const
{
		static const ValueRange subChannelID_ValueRangeList[] = 
			{{ 1, 8, 1 }};

		sizeVRList = 1;
		return &subChannelID_ValueRangeList[0];
}

void LeasedLineType::Init(void)
{
  subChannelID = NULL;
}


int LeasedLineType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	trunkID.checkConstraints(pConstraintFails);

	channelID.checkConstraints(pConstraintFails);

	if (subChannelID != NULL)
		subChannelID->checkConstraints(pConstraintFails);

	return 0;
}


void LeasedLineType::Clear()
{
  if(subChannelID)
    delete subChannelID;
  subChannelID = NULL;
}

LeasedLineType::LeasedLineType(const LeasedLineType &that)
{
   Init();
   *this = that;
}
AsnType *LeasedLineType::Clone() const
{
  return new LeasedLineType(*this);
}

LeasedLineType &LeasedLineType::operator = (const LeasedLineType &that)
{
  if (this != &that)
  {
    Clear();
    trunkID = that.trunkID;
    channelID = that.channelID;
    if (that.subChannelID)
    {
      if (!subChannelID)
        subChannelID = new SubChannelID;
      *subChannelID = *that.subChannelID;
    }
    else
    {
      delete subChannelID;
      subChannelID = NULL;
    }
  }

  return *this;
}

AsnLen
LeasedLineType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (subChannelID))
  {
    l = subChannelID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = channelID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = trunkID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // LeasedLineType::BEncContent


void LeasedLineType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" LeasedLineType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    trunkID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    channelID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  subChannelID = new SubChannelID;
    subChannelID->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // LeasedLineType::BDecContent

AsnLen LeasedLineType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void LeasedLineType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" LeasedLineType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void LeasedLineType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "trunkID ";
	trunkID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "channelID ";
	channelID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (subChannelID))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "subChannelID ";
		subChannelID->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of LeasedLineType::Print()

void LeasedLineType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    trunkID.PrintXML(os, "trunkID");

    channelID.PrintXML(os, "channelID");

  if (NOT_NULL (subChannelID))
  {
    subChannelID->PrintXML(os, "subChannelID");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // LeasedLineType::PrintXML


const SizeConstraint*  
ChannelMask_64k::ChannelMask64k::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint channelMask64k_SizeConstraintList[] = 
			{{ 2, 31, 1 }};

	sizeList = 1;
	return &channelMask64k_SizeConstraintList[0];
}


void ChannelMask_64k::Init(void)
{
}


int ChannelMask_64k::checkConstraints(ConstraintFailList* pConstraintFails) const{
	trunkID.checkConstraints(pConstraintFails);

	channelMask64k.checkConstraints(pConstraintFails);

	return 0;
}


void ChannelMask_64k::Clear()
{
}

ChannelMask_64k::ChannelMask_64k(const ChannelMask_64k &that)
{
   Init();
   *this = that;
}
AsnType *ChannelMask_64k::Clone() const
{
  return new ChannelMask_64k(*this);
}

ChannelMask_64k &ChannelMask_64k::operator = (const ChannelMask_64k &that)
{
  if (this != &that)
  {
    Clear();
    trunkID = that.trunkID;
    channelMask64k = that.channelMask64k;
  }

  return *this;
}

AsnLen
ChannelMask_64k::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = channelMask64k.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = trunkID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ChannelMask_64k::BEncContent


void ChannelMask_64k::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ChannelMask_64k::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    trunkID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    channelMask64k.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ChannelMask_64k::BDecContent

AsnLen ChannelMask_64k::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ChannelMask_64k::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ChannelMask_64k::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ChannelMask_64k::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "trunkID ";
	trunkID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "channelMask64k ";
	channelMask64k.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ChannelMask_64k::Print()

void ChannelMask_64k::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    trunkID.PrintXML(os, "trunkID");

    channelMask64k.PrintXML(os, "channelMask64k");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ChannelMask_64k::PrintXML


const SizeConstraint*  
ChannelMask_8k::ChannelMask8k::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint channelMask8k_SizeConstraintList[] = 
			{{ 16, 248, 1 }};

	sizeList = 1;
	return &channelMask8k_SizeConstraintList[0];
}


void ChannelMask_8k::Init(void)
{
}


int ChannelMask_8k::checkConstraints(ConstraintFailList* pConstraintFails) const{
	trunkID.checkConstraints(pConstraintFails);

	channelMask8k.checkConstraints(pConstraintFails);

	return 0;
}


void ChannelMask_8k::Clear()
{
}

ChannelMask_8k::ChannelMask_8k(const ChannelMask_8k &that)
{
   Init();
   *this = that;
}
AsnType *ChannelMask_8k::Clone() const
{
  return new ChannelMask_8k(*this);
}

ChannelMask_8k &ChannelMask_8k::operator = (const ChannelMask_8k &that)
{
  if (this != &that)
  {
    Clear();
    trunkID = that.trunkID;
    channelMask8k = that.channelMask8k;
  }

  return *this;
}

AsnLen
ChannelMask_8k::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = channelMask8k.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = trunkID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ChannelMask_8k::BEncContent


void ChannelMask_8k::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ChannelMask_8k::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    trunkID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    channelMask8k.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ChannelMask_8k::BDecContent

AsnLen ChannelMask_8k::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ChannelMask_8k::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ChannelMask_8k::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ChannelMask_8k::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "trunkID ";
	trunkID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "channelMask8k ";
	channelMask8k.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ChannelMask_8k::Print()

void ChannelMask_8k::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    trunkID.PrintXML(os, "trunkID");

    channelMask8k.PrintXML(os, "channelMask8k");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ChannelMask_8k::PrintXML


void FragmentationInfoType::Init(void)
{
}


int FragmentationInfoType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	packetNumber.checkConstraints(pConstraintFails);

	totalNumber.checkConstraints(pConstraintFails);

	return 0;
}


void FragmentationInfoType::Clear()
{
}

FragmentationInfoType::FragmentationInfoType(const FragmentationInfoType &that)
{
   Init();
   *this = that;
}
AsnType *FragmentationInfoType::Clone() const
{
  return new FragmentationInfoType(*this);
}

FragmentationInfoType &FragmentationInfoType::operator = (const FragmentationInfoType &that)
{
  if (this != &that)
  {
    Clear();
    packetNumber = that.packetNumber;
    totalNumber = that.totalNumber;
  }

  return *this;
}

AsnLen
FragmentationInfoType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = totalNumber.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = packetNumber.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // FragmentationInfoType::BEncContent


void FragmentationInfoType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" FragmentationInfoType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    packetNumber.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    totalNumber.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // FragmentationInfoType::BDecContent

AsnLen FragmentationInfoType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void FragmentationInfoType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" FragmentationInfoType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void FragmentationInfoType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "packetNumber ";
	packetNumber.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "totalNumber ";
	totalNumber.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of FragmentationInfoType::Print()

void FragmentationInfoType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    packetNumber.PrintXML(os, "packetNumber");

    totalNumber.PrintXML(os, "totalNumber");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // FragmentationInfoType::PrintXML


void ACAPI_CloseService_Ack::Init(void)
{
}


int ACAPI_CloseService_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	result.checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_CloseService_Ack::Clear()
{
}

ACAPI_CloseService_Ack::ACAPI_CloseService_Ack(const ACAPI_CloseService_Ack &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_CloseService_Ack::Clone() const
{
  return new ACAPI_CloseService_Ack(*this);
}

ACAPI_CloseService_Ack &ACAPI_CloseService_Ack::operator = (const ACAPI_CloseService_Ack &that)
{
  if (this != &that)
  {
    Clear();
    result = that.result;
  }

  return *this;
}

AsnLen
ACAPI_CloseService_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_CloseService_Ack::BEncContent


void ACAPI_CloseService_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_CloseService_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_CloseService_Ack::BDecContent

AsnLen ACAPI_CloseService_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 13);
  return l;
}

void ACAPI_CloseService_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_CloseService_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 13))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_CloseService_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_CloseService_Ack::Print()

void ACAPI_CloseService_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_CloseService_Ack::PrintXML


void CC_ForcedCallEnd::Init(void)
{
}


int CC_ForcedCallEnd::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callID.checkConstraints(pConstraintFails);

	disconnectCause.checkConstraints(pConstraintFails);

	return 0;
}


void CC_ForcedCallEnd::Clear()
{
}

CC_ForcedCallEnd::CC_ForcedCallEnd(const CC_ForcedCallEnd &that)
{
   Init();
   *this = that;
}
AsnType *CC_ForcedCallEnd::Clone() const
{
  return new CC_ForcedCallEnd(*this);
}

CC_ForcedCallEnd &CC_ForcedCallEnd::operator = (const CC_ForcedCallEnd &that)
{
  if (this != &that)
  {
    Clear();
    callID = that.callID;
    disconnectCause = that.disconnectCause;
  }

  return *this;
}

AsnLen
CC_ForcedCallEnd::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = disconnectCause.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

  return totalLen;
} // CC_ForcedCallEnd::BEncContent


void CC_ForcedCallEnd::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_ForcedCallEnd::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    disconnectCause.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_ForcedCallEnd::BDecContent

AsnLen CC_ForcedCallEnd::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 44);
  return l;
}

void CC_ForcedCallEnd::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_ForcedCallEnd::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 44))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_ForcedCallEnd::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectCause ";
	disconnectCause.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_ForcedCallEnd::Print()

void CC_ForcedCallEnd::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callID.PrintXML(os, "callID");

    disconnectCause.PrintXML(os, "disconnectCause");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_ForcedCallEnd::PrintXML


void CC_ForcedCallEnd_Ack::Init(void)
{
}


int CC_ForcedCallEnd_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callID.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void CC_ForcedCallEnd_Ack::Clear()
{
}

CC_ForcedCallEnd_Ack::CC_ForcedCallEnd_Ack(const CC_ForcedCallEnd_Ack &that)
{
   Init();
   *this = that;
}
AsnType *CC_ForcedCallEnd_Ack::Clone() const
{
  return new CC_ForcedCallEnd_Ack(*this);
}

CC_ForcedCallEnd_Ack &CC_ForcedCallEnd_Ack::operator = (const CC_ForcedCallEnd_Ack &that)
{
  if (this != &that)
  {
    Clear();
    callID = that.callID;
    result = that.result;
  }

  return *this;
}

AsnLen
CC_ForcedCallEnd_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // CC_ForcedCallEnd_Ack::BEncContent


void CC_ForcedCallEnd_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_ForcedCallEnd_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_ForcedCallEnd_Ack::BDecContent

AsnLen CC_ForcedCallEnd_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 123);
  return l;
}

void CC_ForcedCallEnd_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_ForcedCallEnd_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 123))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_ForcedCallEnd_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_ForcedCallEnd_Ack::Print()

void CC_ForcedCallEnd_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callID.PrintXML(os, "callID");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_ForcedCallEnd_Ack::PrintXML


void SS_CallForwardCancel_Ack::Init(void)
{
}


int SS_CallForwardCancel_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	cancelResult.checkConstraints(pConstraintFails);

	return 0;
}


void SS_CallForwardCancel_Ack::Clear()
{
}

SS_CallForwardCancel_Ack::SS_CallForwardCancel_Ack(const SS_CallForwardCancel_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_CallForwardCancel_Ack::Clone() const
{
  return new SS_CallForwardCancel_Ack(*this);
}

SS_CallForwardCancel_Ack &SS_CallForwardCancel_Ack::operator = (const SS_CallForwardCancel_Ack &that)
{
  if (this != &that)
  {
    Clear();
    cancelResult = that.cancelResult;
  }

  return *this;
}

AsnLen
SS_CallForwardCancel_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = cancelResult.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

  return totalLen;
} // SS_CallForwardCancel_Ack::BEncContent


void SS_CallForwardCancel_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardCancel_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    cancelResult.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_CallForwardCancel_Ack::BDecContent

AsnLen SS_CallForwardCancel_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 69);
  return l;
}

void SS_CallForwardCancel_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardCancel_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 69))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_CallForwardCancel_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "cancelResult ";
	cancelResult.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_CallForwardCancel_Ack::Print()

void SS_CallForwardCancel_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    cancelResult.PrintXML(os, "cancelResult");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_CallForwardCancel_Ack::PrintXML


void SS_ObjectIdentityCancelGateway::Init(void)
{
}


int SS_ObjectIdentityCancelGateway::checkConstraints(ConstraintFailList* pConstraintFails) const{
	gatewayID.checkConstraints(pConstraintFails);

	return 0;
}


void SS_ObjectIdentityCancelGateway::Clear()
{
}

SS_ObjectIdentityCancelGateway::SS_ObjectIdentityCancelGateway(const SS_ObjectIdentityCancelGateway &that)
{
   Init();
   *this = that;
}
AsnType *SS_ObjectIdentityCancelGateway::Clone() const
{
  return new SS_ObjectIdentityCancelGateway(*this);
}

SS_ObjectIdentityCancelGateway &SS_ObjectIdentityCancelGateway::operator = (const SS_ObjectIdentityCancelGateway &that)
{
  if (this != &that)
  {
    Clear();
    gatewayID = that.gatewayID;
  }

  return *this;
}

AsnLen
SS_ObjectIdentityCancelGateway::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = gatewayID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // SS_ObjectIdentityCancelGateway::BEncContent


void SS_ObjectIdentityCancelGateway::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityCancelGateway::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    gatewayID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_ObjectIdentityCancelGateway::BDecContent

AsnLen SS_ObjectIdentityCancelGateway::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 114);
  return l;
}

void SS_ObjectIdentityCancelGateway::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityCancelGateway::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 114))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_ObjectIdentityCancelGateway::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "gatewayID ";
	gatewayID.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_ObjectIdentityCancelGateway::Print()

void SS_ObjectIdentityCancelGateway::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    gatewayID.PrintXML(os, "gatewayID");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_ObjectIdentityCancelGateway::PrintXML


void SS_ObjectIdentityCancelGateway_Ack::Init(void)
{
}


int SS_ObjectIdentityCancelGateway_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	gatewayID.checkConstraints(pConstraintFails);

	cancelGatewayResult.checkConstraints(pConstraintFails);

	return 0;
}


void SS_ObjectIdentityCancelGateway_Ack::Clear()
{
}

SS_ObjectIdentityCancelGateway_Ack::SS_ObjectIdentityCancelGateway_Ack(const SS_ObjectIdentityCancelGateway_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_ObjectIdentityCancelGateway_Ack::Clone() const
{
  return new SS_ObjectIdentityCancelGateway_Ack(*this);
}

SS_ObjectIdentityCancelGateway_Ack &SS_ObjectIdentityCancelGateway_Ack::operator = (const SS_ObjectIdentityCancelGateway_Ack &that)
{
  if (this != &that)
  {
    Clear();
    gatewayID = that.gatewayID;
    cancelGatewayResult = that.cancelGatewayResult;
  }

  return *this;
}

AsnLen
SS_ObjectIdentityCancelGateway_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = cancelGatewayResult.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = gatewayID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // SS_ObjectIdentityCancelGateway_Ack::BEncContent


void SS_ObjectIdentityCancelGateway_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityCancelGateway_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    gatewayID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    cancelGatewayResult.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_ObjectIdentityCancelGateway_Ack::BDecContent

AsnLen SS_ObjectIdentityCancelGateway_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 115);
  return l;
}

void SS_ObjectIdentityCancelGateway_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityCancelGateway_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 115))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_ObjectIdentityCancelGateway_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "gatewayID ";
	gatewayID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "cancelGatewayResult ";
	cancelGatewayResult.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_ObjectIdentityCancelGateway_Ack::Print()

void SS_ObjectIdentityCancelGateway_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    gatewayID.PrintXML(os, "gatewayID");

    cancelGatewayResult.PrintXML(os, "cancelGatewayResult");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_ObjectIdentityCancelGateway_Ack::PrintXML


void SS_ObjectIdentityInterrogate::Init(void)
{
  startSSI = NULL;
  endSSI = NULL;
  maxTransferredEntries = NULL;
}


int SS_ObjectIdentityInterrogate::checkConstraints(ConstraintFailList* pConstraintFails) const{
	gatewaySSI.checkConstraints(pConstraintFails);

	if (startSSI != NULL)
		startSSI->checkConstraints(pConstraintFails);

	if (endSSI != NULL)
		endSSI->checkConstraints(pConstraintFails);

	if (maxTransferredEntries != NULL)
		maxTransferredEntries->checkConstraints(pConstraintFails);

	return 0;
}


void SS_ObjectIdentityInterrogate::Clear()
{
  if(startSSI)
    delete startSSI;
  startSSI = NULL;
  if(endSSI)
    delete endSSI;
  endSSI = NULL;
  if(maxTransferredEntries)
    delete maxTransferredEntries;
  maxTransferredEntries = NULL;
}

SS_ObjectIdentityInterrogate::SS_ObjectIdentityInterrogate(const SS_ObjectIdentityInterrogate &that)
{
   Init();
   *this = that;
}
AsnType *SS_ObjectIdentityInterrogate::Clone() const
{
  return new SS_ObjectIdentityInterrogate(*this);
}

SS_ObjectIdentityInterrogate &SS_ObjectIdentityInterrogate::operator = (const SS_ObjectIdentityInterrogate &that)
{
  if (this != &that)
  {
    Clear();
    gatewaySSI = that.gatewaySSI;
    if (that.startSSI)
    {
      if (!startSSI)
        startSSI = new AsnInt;
      *startSSI = *that.startSSI;
    }
    else
    {
      delete startSSI;
      startSSI = NULL;
    }
    if (that.endSSI)
    {
      if (!endSSI)
        endSSI = new AsnInt;
      *endSSI = *that.endSSI;
    }
    else
    {
      delete endSSI;
      endSSI = NULL;
    }
    if (that.maxTransferredEntries)
    {
      if (!maxTransferredEntries)
        maxTransferredEntries = new AsnInt;
      *maxTransferredEntries = *that.maxTransferredEntries;
    }
    else
    {
      delete maxTransferredEntries;
      maxTransferredEntries = NULL;
    }
  }

  return *this;
}

AsnLen
SS_ObjectIdentityInterrogate::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (maxTransferredEntries))
  {
    l = maxTransferredEntries->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (endSSI))
  {
    l = endSSI->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (startSSI))
  {
    l = startSSI->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

    l = gatewaySSI.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // SS_ObjectIdentityInterrogate::BEncContent


void SS_ObjectIdentityInterrogate::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityInterrogate::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    gatewaySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  startSSI = new AsnInt;
    startSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  endSSI = new AsnInt;
    endSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  maxTransferredEntries = new AsnInt;
    maxTransferredEntries->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_ObjectIdentityInterrogate::BDecContent

AsnLen SS_ObjectIdentityInterrogate::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 116);
  return l;
}

void SS_ObjectIdentityInterrogate::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityInterrogate::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 116))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_ObjectIdentityInterrogate::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "gatewaySSI ";
	gatewaySSI.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (startSSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "startSSI ";
		startSSI->Print(os, indent);
	}

	if (NOT_NULL (endSSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "endSSI ";
		endSSI->Print(os, indent);
	}

	if (NOT_NULL (maxTransferredEntries))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "maxTransferredEntries ";
		maxTransferredEntries->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_ObjectIdentityInterrogate::Print()

void SS_ObjectIdentityInterrogate::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    gatewaySSI.PrintXML(os, "gatewaySSI");

  if (NOT_NULL (startSSI))
  {
    startSSI->PrintXML(os, "startSSI");
  }

  if (NOT_NULL (endSSI))
  {
    endSSI->PrintXML(os, "endSSI");
  }

  if (NOT_NULL (maxTransferredEntries))
  {
    maxTransferredEntries->PrintXML(os, "maxTransferredEntries");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_ObjectIdentityInterrogate::PrintXML


void MON_FleetMonitoring_Req::Init(void)
{
  monHandle = NULL;
  monStartTime = NULL;
  monEndTime = NULL;
  monPersistentData = NULL;
}


int MON_FleetMonitoring_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monServices.checkConstraints(pConstraintFails);

	monFleet.checkConstraints(pConstraintFails);

	if (monHandle != NULL)
		monHandle->checkConstraints(pConstraintFails);

	if (monStartTime != NULL)
		monStartTime->checkConstraints(pConstraintFails);

	if (monEndTime != NULL)
		monEndTime->checkConstraints(pConstraintFails);

	if (monPersistentData != NULL)
		monPersistentData->checkConstraints(pConstraintFails);

	return 0;
}


void MON_FleetMonitoring_Req::Clear()
{
  if(monHandle)
    delete monHandle;
  monHandle = NULL;
  if(monStartTime)
    delete monStartTime;
  monStartTime = NULL;
  if(monEndTime)
    delete monEndTime;
  monEndTime = NULL;
  if(monPersistentData)
    delete monPersistentData;
  monPersistentData = NULL;
}

MON_FleetMonitoring_Req::MON_FleetMonitoring_Req(const MON_FleetMonitoring_Req &that)
{
   Init();
   *this = that;
}
AsnType *MON_FleetMonitoring_Req::Clone() const
{
  return new MON_FleetMonitoring_Req(*this);
}

MON_FleetMonitoring_Req &MON_FleetMonitoring_Req::operator = (const MON_FleetMonitoring_Req &that)
{
  if (this != &that)
  {
    Clear();
    monServices = that.monServices;
    monFleet = that.monFleet;
    if (that.monHandle)
    {
      if (!monHandle)
        monHandle = new AsnInt;
      *monHandle = *that.monHandle;
    }
    else
    {
      delete monHandle;
      monHandle = NULL;
    }
    if (that.monStartTime)
    {
      if (!monStartTime)
        monStartTime = new GeneralizedTime;
      *monStartTime = *that.monStartTime;
    }
    else
    {
      delete monStartTime;
      monStartTime = NULL;
    }
    if (that.monEndTime)
    {
      if (!monEndTime)
        monEndTime = new GeneralizedTime;
      *monEndTime = *that.monEndTime;
    }
    else
    {
      delete monEndTime;
      monEndTime = NULL;
    }
    if (that.monPersistentData)
    {
      if (!monPersistentData)
        monPersistentData = new AsnBool;
      *monPersistentData = *that.monPersistentData;
    }
    else
    {
      delete monPersistentData;
      monPersistentData = NULL;
    }
  }

  return *this;
}

AsnLen
MON_FleetMonitoring_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (monPersistentData))
  {
    l = monPersistentData->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (monEndTime))
  {
    l = monEndTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (monStartTime))
  {
    l = monStartTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (monHandle))
  {
    l = monHandle->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = monFleet.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monServices.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_FleetMonitoring_Req::BEncContent


void MON_FleetMonitoring_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_FleetMonitoring_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monServices.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monFleet.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monHandle = new AsnInt;
    monHandle->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monStartTime = new GeneralizedTime;
    monStartTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monEndTime = new GeneralizedTime;
    monEndTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monPersistentData = new AsnBool;
    monPersistentData->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_FleetMonitoring_Req::BDecContent

AsnLen MON_FleetMonitoring_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 72);
  return l;
}

void MON_FleetMonitoring_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_FleetMonitoring_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 72))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_FleetMonitoring_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monServices ";
	monServices.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monFleet ";
	monFleet.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (monHandle))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monHandle ";
		monHandle->Print(os, indent);
	}

	if (NOT_NULL (monStartTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monStartTime ";
		monStartTime->Print(os, indent);
	}

	if (NOT_NULL (monEndTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monEndTime ";
		monEndTime->Print(os, indent);
	}

	if (NOT_NULL (monPersistentData))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monPersistentData ";
		monPersistentData->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_FleetMonitoring_Req::Print()

void MON_FleetMonitoring_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monServices.PrintXML(os, "monServices");

    monFleet.PrintXML(os, "monFleet");

  if (NOT_NULL (monHandle))
  {
    monHandle->PrintXML(os, "monHandle");
  }

  if (NOT_NULL (monStartTime))
  {
    monStartTime->PrintXML(os, "monStartTime");
  }

  if (NOT_NULL (monEndTime))
  {
    monEndTime->PrintXML(os, "monEndTime");
  }

  if (NOT_NULL (monPersistentData))
  {
    monPersistentData->PrintXML(os, "monPersistentData");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_FleetMonitoring_Req::PrintXML


void MON_FleetMonitoring_Ack::Init(void)
{
  monStartTime = NULL;
  monEndTime = NULL;
  persistentData = NULL;
}


int MON_FleetMonitoring_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monServices.checkConstraints(pConstraintFails);

	monFleet.checkConstraints(pConstraintFails);

	if (monStartTime != NULL)
		monStartTime->checkConstraints(pConstraintFails);

	if (monEndTime != NULL)
		monEndTime->checkConstraints(pConstraintFails);

	if (persistentData != NULL)
		persistentData->checkConstraints(pConstraintFails);

	return 0;
}


void MON_FleetMonitoring_Ack::Clear()
{
  if(monStartTime)
    delete monStartTime;
  monStartTime = NULL;
  if(monEndTime)
    delete monEndTime;
  monEndTime = NULL;
  if(persistentData)
    delete persistentData;
  persistentData = NULL;
}

MON_FleetMonitoring_Ack::MON_FleetMonitoring_Ack(const MON_FleetMonitoring_Ack &that)
{
   Init();
   *this = that;
}
AsnType *MON_FleetMonitoring_Ack::Clone() const
{
  return new MON_FleetMonitoring_Ack(*this);
}

MON_FleetMonitoring_Ack &MON_FleetMonitoring_Ack::operator = (const MON_FleetMonitoring_Ack &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monServices = that.monServices;
    monFleet = that.monFleet;
    if (that.monStartTime)
    {
      if (!monStartTime)
        monStartTime = new GeneralizedTime;
      *monStartTime = *that.monStartTime;
    }
    else
    {
      delete monStartTime;
      monStartTime = NULL;
    }
    if (that.monEndTime)
    {
      if (!monEndTime)
        monEndTime = new GeneralizedTime;
      *monEndTime = *that.monEndTime;
    }
    else
    {
      delete monEndTime;
      monEndTime = NULL;
    }
    if (that.persistentData)
    {
      if (!persistentData)
        persistentData = new AsnBool;
      *persistentData = *that.persistentData;
    }
    else
    {
      delete persistentData;
      persistentData = NULL;
    }
  }

  return *this;
}

AsnLen
MON_FleetMonitoring_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (persistentData))
  {
    l = persistentData->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (monEndTime))
  {
    l = monEndTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (monStartTime))
  {
    l = monStartTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = monFleet.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = monServices.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_FleetMonitoring_Ack::BEncContent


void MON_FleetMonitoring_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_FleetMonitoring_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monServices.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monFleet.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monStartTime = new GeneralizedTime;
    monStartTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monEndTime = new GeneralizedTime;
    monEndTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  persistentData = new AsnBool;
    persistentData->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_FleetMonitoring_Ack::BDecContent

AsnLen MON_FleetMonitoring_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 73);
  return l;
}

void MON_FleetMonitoring_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_FleetMonitoring_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 73))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_FleetMonitoring_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monServices ";
	monServices.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monFleet ";
	monFleet.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (monStartTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monStartTime ";
		monStartTime->Print(os, indent);
	}

	if (NOT_NULL (monEndTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monEndTime ";
		monEndTime->Print(os, indent);
	}

	if (NOT_NULL (persistentData))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "persistentData ";
		persistentData->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_FleetMonitoring_Ack::Print()

void MON_FleetMonitoring_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monServices.PrintXML(os, "monServices");

    monFleet.PrintXML(os, "monFleet");

  if (NOT_NULL (monStartTime))
  {
    monStartTime->PrintXML(os, "monStartTime");
  }

  if (NOT_NULL (monEndTime))
  {
    monEndTime->PrintXML(os, "monEndTime");
  }

  if (NOT_NULL (persistentData))
  {
    persistentData->PrintXML(os, "persistentData");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_FleetMonitoring_Ack::PrintXML


void MON_Close_Ack::Init(void)
{
}


int MON_Close_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void MON_Close_Ack::Clear()
{
}

MON_Close_Ack::MON_Close_Ack(const MON_Close_Ack &that)
{
   Init();
   *this = that;
}
AsnType *MON_Close_Ack::Clone() const
{
  return new MON_Close_Ack(*this);
}

MON_Close_Ack &MON_Close_Ack::operator = (const MON_Close_Ack &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    result = that.result;
  }

  return *this;
}

AsnLen
MON_Close_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Close_Ack::BEncContent


void MON_Close_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Close_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Close_Ack::BDecContent

AsnLen MON_Close_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 76);
  return l;
}

void MON_Close_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Close_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 76))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Close_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Close_Ack::Print()

void MON_Close_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Close_Ack::PrintXML


void MON_ForcedCallEnd::Init(void)
{
}


int MON_ForcedCallEnd::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	disconnectCause.checkConstraints(pConstraintFails);

	return 0;
}


void MON_ForcedCallEnd::Clear()
{
}

MON_ForcedCallEnd::MON_ForcedCallEnd(const MON_ForcedCallEnd &that)
{
   Init();
   *this = that;
}
AsnType *MON_ForcedCallEnd::Clone() const
{
  return new MON_ForcedCallEnd(*this);
}

MON_ForcedCallEnd &MON_ForcedCallEnd::operator = (const MON_ForcedCallEnd &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    callID = that.callID;
    disconnectCause = that.disconnectCause;
  }

  return *this;
}

AsnLen
MON_ForcedCallEnd::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = disconnectCause.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_ForcedCallEnd::BEncContent


void MON_ForcedCallEnd::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_ForcedCallEnd::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    disconnectCause.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_ForcedCallEnd::BDecContent

AsnLen MON_ForcedCallEnd::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 91);
  return l;
}

void MON_ForcedCallEnd::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_ForcedCallEnd::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 91))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_ForcedCallEnd::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectCause ";
	disconnectCause.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_ForcedCallEnd::Print()

void MON_ForcedCallEnd::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    callID.PrintXML(os, "callID");

    disconnectCause.PrintXML(os, "disconnectCause");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_ForcedCallEnd::PrintXML


void MON_ForcedCallEnd_Ack::Init(void)
{
}


int MON_ForcedCallEnd_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void MON_ForcedCallEnd_Ack::Clear()
{
}

MON_ForcedCallEnd_Ack::MON_ForcedCallEnd_Ack(const MON_ForcedCallEnd_Ack &that)
{
   Init();
   *this = that;
}
AsnType *MON_ForcedCallEnd_Ack::Clone() const
{
  return new MON_ForcedCallEnd_Ack(*this);
}

MON_ForcedCallEnd_Ack &MON_ForcedCallEnd_Ack::operator = (const MON_ForcedCallEnd_Ack &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    callID = that.callID;
    result = that.result;
  }

  return *this;
}

AsnLen
MON_ForcedCallEnd_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_ForcedCallEnd_Ack::BEncContent


void MON_ForcedCallEnd_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_ForcedCallEnd_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_ForcedCallEnd_Ack::BDecContent

AsnLen MON_ForcedCallEnd_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 92);
  return l;
}

void MON_ForcedCallEnd_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_ForcedCallEnd_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 92))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_ForcedCallEnd_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_ForcedCallEnd_Ack::Print()

void MON_ForcedCallEnd_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    callID.PrintXML(os, "callID");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_ForcedCallEnd_Ack::PrintXML


void RSM_ResourceMonitoring_Close::Init(void)
{
}


int RSM_ResourceMonitoring_Close::checkConstraints(ConstraintFailList* pConstraintFails) const{
	rsmHandle.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void RSM_ResourceMonitoring_Close::Clear()
{
}

RSM_ResourceMonitoring_Close::RSM_ResourceMonitoring_Close(const RSM_ResourceMonitoring_Close &that)
{
   Init();
   *this = that;
}
AsnType *RSM_ResourceMonitoring_Close::Clone() const
{
  return new RSM_ResourceMonitoring_Close(*this);
}

RSM_ResourceMonitoring_Close &RSM_ResourceMonitoring_Close::operator = (const RSM_ResourceMonitoring_Close &that)
{
  if (this != &that)
  {
    Clear();
    rsmHandle = that.rsmHandle;
    result = that.result;
  }

  return *this;
}

AsnLen
RSM_ResourceMonitoring_Close::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = rsmHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // RSM_ResourceMonitoring_Close::BEncContent


void RSM_ResourceMonitoring_Close::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" RSM_ResourceMonitoring_Close::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    rsmHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // RSM_ResourceMonitoring_Close::BDecContent

AsnLen RSM_ResourceMonitoring_Close::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 102);
  return l;
}

void RSM_ResourceMonitoring_Close::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" RSM_ResourceMonitoring_Close::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 102))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void RSM_ResourceMonitoring_Close::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "rsmHandle ";
	rsmHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of RSM_ResourceMonitoring_Close::Print()

void RSM_ResourceMonitoring_Close::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    rsmHandle.PrintXML(os, "rsmHandle");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // RSM_ResourceMonitoring_Close::PrintXML


void TETRA_Address::Init(void)
{
  mcc = NULL;
  mnc = NULL;
}


int TETRA_Address::checkConstraints(ConstraintFailList* pConstraintFails) const{
	ssi.checkConstraints(pConstraintFails);

	if (mcc != NULL)
		mcc->checkConstraints(pConstraintFails);

	if (mnc != NULL)
		mnc->checkConstraints(pConstraintFails);

	return 0;
}


void TETRA_Address::Clear()
{
  if(mcc)
    delete mcc;
  mcc = NULL;
  if(mnc)
    delete mnc;
  mnc = NULL;
}

TETRA_Address::TETRA_Address(const TETRA_Address &that)
{
   Init();
   *this = that;
}
AsnType *TETRA_Address::Clone() const
{
  return new TETRA_Address(*this);
}

TETRA_Address &TETRA_Address::operator = (const TETRA_Address &that)
{
  if (this != &that)
  {
    Clear();
    ssi = that.ssi;
    if (that.mcc)
    {
      if (!mcc)
        mcc = new MCCType;
      *mcc = *that.mcc;
    }
    else
    {
      delete mcc;
      mcc = NULL;
    }
    if (that.mnc)
    {
      if (!mnc)
        mnc = new MNCType;
      *mnc = *that.mnc;
    }
    else
    {
      delete mnc;
      mnc = NULL;
    }
  }

  return *this;
}

AsnLen
TETRA_Address::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (mnc))
  {
    l = mnc->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (mcc))
  {
    l = mcc->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

    l = ssi.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // TETRA_Address::BEncContent


void TETRA_Address::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" TETRA_Address::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    ssi.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  mcc = new MCCType;
    mcc->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  mnc = new MNCType;
    mnc->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // TETRA_Address::BDecContent

AsnLen TETRA_Address::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TETRA_Address::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" TETRA_Address::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void TETRA_Address::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "ssi ";
	ssi.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (mcc))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "mcc ";
		mcc->Print(os, indent);
	}

	if (NOT_NULL (mnc))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "mnc ";
		mnc->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of TETRA_Address::Print()

void TETRA_Address::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    ssi.PrintXML(os, "ssi");

  if (NOT_NULL (mcc))
  {
    mcc->PrintXML(os, "mcc");
  }

  if (NOT_NULL (mnc))
  {
    mnc->PrintXML(os, "mnc");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // TETRA_Address::PrintXML


void ISDN_Address::Init(void)
{
}


int ISDN_Address::checkConstraints(ConstraintFailList* pConstraintFails) const{
	externalSubscriber.checkConstraints(pConstraintFails);

	gateWaySSI.checkConstraints(pConstraintFails);

	return 0;
}


void ISDN_Address::Clear()
{
}

ISDN_Address::ISDN_Address(const ISDN_Address &that)
{
   Init();
   *this = that;
}
AsnType *ISDN_Address::Clone() const
{
  return new ISDN_Address(*this);
}

ISDN_Address &ISDN_Address::operator = (const ISDN_Address &that)
{
  if (this != &that)
  {
    Clear();
    externalSubscriber = that.externalSubscriber;
    gateWaySSI = that.gateWaySSI;
  }

  return *this;
}

AsnLen
ISDN_Address::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = gateWaySSI.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = externalSubscriber.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ISDN_Address::BEncContent


void ISDN_Address::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ISDN_Address::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    externalSubscriber.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    gateWaySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ISDN_Address::BDecContent

AsnLen ISDN_Address::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ISDN_Address::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ISDN_Address::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ISDN_Address::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "externalSubscriber ";
	externalSubscriber.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "gateWaySSI ";
	gateWaySSI.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ISDN_Address::Print()

void ISDN_Address::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    externalSubscriber.PrintXML(os, "externalSubscriber");

    gateWaySSI.PrintXML(os, "gateWaySSI");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ISDN_Address::PrintXML


AddressType::AddressType(const AddressType &that)
{
   Init();
   *this = that;
}
void AddressType::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = tetraAddressCid;
  tetraAddress = NULL;
}


int AddressType::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (tetraAddress != NULL)
		tetraAddress->checkConstraints(pConstraintFails);

	if (iSDNAddress != NULL)
		iSDNAddress->checkConstraints(pConstraintFails);

	return 0;
}


void AddressType::Clear()
{
  switch (choiceId)
  {
    case tetraAddressCid:
      delete tetraAddress;
      tetraAddress = NULL;
      break;
    case iSDNAddressCid:
      delete iSDNAddress;
      iSDNAddress = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *AddressType::Clone() const
{
  return new AddressType(*this);
}

AddressType &AddressType::operator = (const AddressType &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.tetraAddress != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case tetraAddressCid:
           tetraAddress = new TETRA_Address(*that.tetraAddress);
           break;
         case iSDNAddressCid:
           iSDNAddress = new ISDN_Address(*that.iSDNAddress);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
AddressType::BEncContent (AsnBuf &_b) const
{
    FUNC("AddressType::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case tetraAddressCid:
      l = tetraAddress->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
      break;

    case iSDNAddressCid:
      l = iSDNAddress->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // AddressType::BEncContent


void AddressType::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("AddressType::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 0):
      choiceId = tetraAddressCid;
        tetraAddress = new TETRA_Address;
        tetraAddress->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = iSDNAddressCid;
        iSDNAddress = new ISDN_Address;
        iSDNAddress->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // AddressType::BDecContent


AsnLen AddressType::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void AddressType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void AddressType::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case tetraAddressCid:
		os << "tetraAddress ";
		if (tetraAddress)
			tetraAddress->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case iSDNAddressCid:
		os << "iSDNAddress ";
		if (iSDNAddress)
			iSDNAddress->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of AddressType::Print()

void AddressType::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"AddressType\" type=\"CHOICE\">";
  }
  else
        os << "<AddressType type=\"CHOICE\">";
  switch (choiceId)
  {
    case tetraAddressCid:
      if (tetraAddress)
        tetraAddress->PrintXML(os,"tetraAddress");
      else
      {
        os << "<tetraAddress -- void3 -- /tetraAddress>" << std::endl;
      }
      break;

    case iSDNAddressCid:
      if (iSDNAddress)
        iSDNAddress->PrintXML(os,"iSDNAddress");
      else
      {
        os << "<iSDNAddress -- void3 -- /iSDNAddress>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</AddressType>";
} // AddressType::PrintXML

SDSDataType::StatusType & 
SDSDataType::StatusType::operator =(const StatusType &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
SDSDataType::StatusType::ValueRanges(int &sizeVRList) const
{
		static const ValueRange statusType_ValueRangeList[] = 
			{{ 0, 65535, 1 }};

		sizeVRList = 1;
		return &statusType_ValueRangeList[0];
}

const SizeConstraint*  
SDSDataType::SdsType1::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint sdsType1_SizeConstraintList[] = 
			{{ 2, 0, 0 }};

	sizeList = 1;
	return &sdsType1_SizeConstraintList[0];
}


const SizeConstraint*  
SDSDataType::SdsType2::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint sdsType2_SizeConstraintList[] = 
			{{ 4, 0, 0 }};

	sizeList = 1;
	return &sdsType2_SizeConstraintList[0];
}


const SizeConstraint*  
SDSDataType::SdsType3::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint sdsType3_SizeConstraintList[] = 
			{{ 8, 0, 0 }};

	sizeList = 1;
	return &sdsType3_SizeConstraintList[0];
}


SDSDataType::SDSDataType(const SDSDataType &that)
{
   Init();
   *this = that;
}
void SDSDataType::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = statusTypeCid;
  statusType = NULL;
}


int SDSDataType::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (statusType != NULL)
		statusType->checkConstraints(pConstraintFails);

	if (sdsType1 != NULL)
		sdsType1->checkConstraints(pConstraintFails);

	if (sdsType2 != NULL)
		sdsType2->checkConstraints(pConstraintFails);

	if (sdsType3 != NULL)
		sdsType3->checkConstraints(pConstraintFails);

	if (sdsType4 != NULL)
		sdsType4->checkConstraints(pConstraintFails);

	return 0;
}


void SDSDataType::Clear()
{
  switch (choiceId)
  {
    case statusTypeCid:
      delete statusType;
      statusType = NULL;
      break;
    case sdsType1Cid:
      delete sdsType1;
      sdsType1 = NULL;
      break;
    case sdsType2Cid:
      delete sdsType2;
      sdsType2 = NULL;
      break;
    case sdsType3Cid:
      delete sdsType3;
      sdsType3 = NULL;
      break;
    case sdsType4Cid:
      delete sdsType4;
      sdsType4 = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *SDSDataType::Clone() const
{
  return new SDSDataType(*this);
}

SDSDataType &SDSDataType::operator = (const SDSDataType &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.statusType != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case statusTypeCid:
           statusType = new StatusType(*that.statusType);
           break;
         case sdsType1Cid:
           sdsType1 = new SdsType1(*that.sdsType1);
           break;
         case sdsType2Cid:
           sdsType2 = new SdsType2(*that.sdsType2);
           break;
         case sdsType3Cid:
           sdsType3 = new SdsType3(*that.sdsType3);
           break;
         case sdsType4Cid:
           sdsType4 = new SDSDataTypeSeq(*that.sdsType4);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
SDSDataType::BEncContent (AsnBuf &_b) const
{
    FUNC("SDSDataType::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case statusTypeCid:
      l = statusType->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
      break;

    case sdsType1Cid:
      l = sdsType1->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
      break;

    case sdsType2Cid:
      l = sdsType2->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
      break;

    case sdsType3Cid:
      l = sdsType3->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
      break;

    case sdsType4Cid:
      l = sdsType4->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // SDSDataType::BEncContent


void SDSDataType::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("SDSDataType::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 0):
      choiceId = statusTypeCid;
        statusType = new StatusType;
        statusType->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 1):
    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = sdsType1Cid;
        sdsType1 = new SdsType1;
        sdsType1->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = sdsType2Cid;
        sdsType2 = new SdsType2;
        sdsType2->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 3):
    case MAKE_TAG_ID (CNTX, CONS, 3):
      choiceId = sdsType3Cid;
        sdsType3 = new SdsType3;
        sdsType3->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 4):
      choiceId = sdsType4Cid;
        sdsType4 = new SDSDataTypeSeq;
        sdsType4->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // SDSDataType::BDecContent


AsnLen SDSDataType::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void SDSDataType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void SDSDataType::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case statusTypeCid:
		os << "statusType ";
		if (statusType)
			statusType->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case sdsType1Cid:
		os << "sdsType1 ";
		if (sdsType1)
			sdsType1->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case sdsType2Cid:
		os << "sdsType2 ";
		if (sdsType2)
			sdsType2->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case sdsType3Cid:
		os << "sdsType3 ";
		if (sdsType3)
			sdsType3->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case sdsType4Cid:
		os << "sdsType4 ";
		if (sdsType4)
			sdsType4->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of SDSDataType::Print()

void SDSDataType::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"SDSDataType\" type=\"CHOICE\">";
  }
  else
        os << "<SDSDataType type=\"CHOICE\">";
  switch (choiceId)
  {
    case statusTypeCid:
      if (statusType)
        statusType->PrintXML(os,"statusType");
      else
      {
        os << "<statusType -- void3 -- /statusType>" << std::endl;
      }
      break;

    case sdsType1Cid:
      if (sdsType1)
        sdsType1->PrintXML(os,"sdsType1");
      else
      {
        os << "<sdsType1 -- void3 -- /sdsType1>" << std::endl;
      }
      break;

    case sdsType2Cid:
      if (sdsType2)
        sdsType2->PrintXML(os,"sdsType2");
      else
      {
        os << "<sdsType2 -- void3 -- /sdsType2>" << std::endl;
      }
      break;

    case sdsType3Cid:
      if (sdsType3)
        sdsType3->PrintXML(os,"sdsType3");
      else
      {
        os << "<sdsType3 -- void3 -- /sdsType3>" << std::endl;
      }
      break;

    case sdsType4Cid:
      if (sdsType4)
        sdsType4->PrintXML(os,"sdsType4");
      else
      {
        os << "<sdsType4 -- void3 -- /sdsType4>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</SDSDataType>";
} // SDSDataType::PrintXML

void BasicServiceType::Init(void)
{
  encryption = NULL;
  circuitModeType = NULL;
}


int BasicServiceType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	communicationType.checkConstraints(pConstraintFails);

	if (encryption != NULL)
		encryption->checkConstraints(pConstraintFails);

	if (circuitModeType != NULL)
		circuitModeType->checkConstraints(pConstraintFails);

	return 0;
}


void BasicServiceType::Clear()
{
  if(encryption)
    delete encryption;
  encryption = NULL;
  if(circuitModeType)
    delete circuitModeType;
  circuitModeType = NULL;
}

BasicServiceType::BasicServiceType(const BasicServiceType &that)
{
   Init();
   *this = that;
}
AsnType *BasicServiceType::Clone() const
{
  return new BasicServiceType(*this);
}

BasicServiceType &BasicServiceType::operator = (const BasicServiceType &that)
{
  if (this != &that)
  {
    Clear();
    communicationType = that.communicationType;
    if (that.encryption)
    {
      if (!encryption)
        encryption = new AsnBool;
      *encryption = *that.encryption;
    }
    else
    {
      delete encryption;
      encryption = NULL;
    }
    if (that.circuitModeType)
    {
      if (!circuitModeType)
        circuitModeType = new CircuitModeType;
      *circuitModeType = *that.circuitModeType;
    }
    else
    {
      delete circuitModeType;
      circuitModeType = NULL;
    }
  }

  return *this;
}

AsnLen
BasicServiceType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (circuitModeType))
  {
    l = circuitModeType->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (encryption))
  {
    l = encryption->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

    l = communicationType.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // BasicServiceType::BEncContent


void BasicServiceType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" BasicServiceType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    communicationType.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  encryption = new AsnBool;
    encryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  circuitModeType = new CircuitModeType;
    circuitModeType->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // BasicServiceType::BDecContent

AsnLen BasicServiceType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void BasicServiceType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" BasicServiceType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void BasicServiceType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "communicationType ";
	communicationType.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (encryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "encryption ";
		encryption->Print(os, indent);
	}

	if (NOT_NULL (circuitModeType))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "circuitModeType ";
		circuitModeType->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of BasicServiceType::Print()

void BasicServiceType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    communicationType.PrintXML(os, "communicationType");

  if (NOT_NULL (encryption))
  {
    encryption->PrintXML(os, "encryption");
  }

  if (NOT_NULL (circuitModeType))
  {
    circuitModeType->PrintXML(os, "circuitModeType");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // BasicServiceType::PrintXML


const SizeConstraint*  
LocationAreaType::LocationName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint locationName_SizeConstraintList[] = 
			{{ 0, 32, 1 }};

	sizeList = 1;
	return &locationName_SizeConstraintList[0];
}


LocationAreaType::Cell & 
LocationAreaType::Cell::operator =(const Cell &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
LocationAreaType::Cell::ValueRanges(int &sizeVRList) const
{
		static const ValueRange cell_ValueRangeList[] = 
			{{ 0, 1024, 1 }};

		sizeVRList = 1;
		return &cell_ValueRangeList[0];
}

const SizeConstraint*  
LocationAreaType::CellName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint cellName_SizeConstraintList[] = 
			{{ 0, 32, 1 }};

	sizeList = 1;
	return &cellName_SizeConstraintList[0];
}


void LocationAreaType::Init(void)
{
  locationName = NULL;
  cell = NULL;
  cellName = NULL;
}


int LocationAreaType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	locationArea.checkConstraints(pConstraintFails);

	if (locationName != NULL)
		locationName->checkConstraints(pConstraintFails);

	if (cell != NULL)
		cell->checkConstraints(pConstraintFails);

	if (cellName != NULL)
		cellName->checkConstraints(pConstraintFails);

	return 0;
}


void LocationAreaType::Clear()
{
  if(locationName)
    delete locationName;
  locationName = NULL;
  if(cell)
    delete cell;
  cell = NULL;
  if(cellName)
    delete cellName;
  cellName = NULL;
}

LocationAreaType::LocationAreaType(const LocationAreaType &that)
{
   Init();
   *this = that;
}
AsnType *LocationAreaType::Clone() const
{
  return new LocationAreaType(*this);
}

LocationAreaType &LocationAreaType::operator = (const LocationAreaType &that)
{
  if (this != &that)
  {
    Clear();
    locationArea = that.locationArea;
    if (that.locationName)
    {
      if (!locationName)
        locationName = new LocationName;
      *locationName = *that.locationName;
    }
    else
    {
      delete locationName;
      locationName = NULL;
    }
    if (that.cell)
    {
      if (!cell)
        cell = new Cell;
      *cell = *that.cell;
    }
    else
    {
      delete cell;
      cell = NULL;
    }
    if (that.cellName)
    {
      if (!cellName)
        cellName = new CellName;
      *cellName = *that.cellName;
    }
    else
    {
      delete cellName;
      cellName = NULL;
    }
  }

  return *this;
}

AsnLen
LocationAreaType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (cellName))
  {
    l = cellName->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (cell))
  {
    l = cell->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (locationName))
  {
    l = locationName->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

    l = locationArea.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // LocationAreaType::BEncContent


void LocationAreaType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" LocationAreaType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    locationArea.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  locationName = new LocationName;
    locationName->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  cell = new Cell;
    cell->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  cellName = new CellName;
    cellName->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // LocationAreaType::BDecContent

AsnLen LocationAreaType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void LocationAreaType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" LocationAreaType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void LocationAreaType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "locationArea ";
	locationArea.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (locationName))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "locationName ";
		locationName->Print(os, indent);
	}

	if (NOT_NULL (cell))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "cell ";
		cell->Print(os, indent);
	}

	if (NOT_NULL (cellName))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "cellName ";
		cellName->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of LocationAreaType::Print()

void LocationAreaType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    locationArea.PrintXML(os, "locationArea");

  if (NOT_NULL (locationName))
  {
    locationName->PrintXML(os, "locationName");
  }

  if (NOT_NULL (cell))
  {
    cell->PrintXML(os, "cell");
  }

  if (NOT_NULL (cellName))
  {
    cellName->PrintXML(os, "cellName");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // LocationAreaType::PrintXML


DialupLineType::SubChannelID & 
DialupLineType::SubChannelID::operator =(const SubChannelID &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
DialupLineType::SubChannelID::ValueRanges(int &sizeVRList) const
{
		static const ValueRange subChannelID_ValueRangeList[] = 
			{{ 1, 8, 1 }};

		sizeVRList = 1;
		return &subChannelID_ValueRangeList[0];
}

void DialupLineType::Init(void)
{
  sourceID = NULL;
  subChannelID = NULL;
}


int DialupLineType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	destinationID.checkConstraints(pConstraintFails);

	if (sourceID != NULL)
		sourceID->checkConstraints(pConstraintFails);

	if (subChannelID != NULL)
		subChannelID->checkConstraints(pConstraintFails);

	return 0;
}


void DialupLineType::Clear()
{
  if(sourceID)
    delete sourceID;
  sourceID = NULL;
  if(subChannelID)
    delete subChannelID;
  subChannelID = NULL;
}

DialupLineType::DialupLineType(const DialupLineType &that)
{
   Init();
   *this = that;
}
AsnType *DialupLineType::Clone() const
{
  return new DialupLineType(*this);
}

DialupLineType &DialupLineType::operator = (const DialupLineType &that)
{
  if (this != &that)
  {
    Clear();
    destinationID = that.destinationID;
    if (that.sourceID)
    {
      if (!sourceID)
        sourceID = new DialingString;
      *sourceID = *that.sourceID;
    }
    else
    {
      delete sourceID;
      sourceID = NULL;
    }
    if (that.subChannelID)
    {
      if (!subChannelID)
        subChannelID = new SubChannelID;
      *subChannelID = *that.subChannelID;
    }
    else
    {
      delete subChannelID;
      subChannelID = NULL;
    }
  }

  return *this;
}

AsnLen
DialupLineType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (subChannelID))
  {
    l = subChannelID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

  if (NOT_NULL (sourceID))
  {
    l = sourceID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

    l = destinationID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // DialupLineType::BEncContent


void DialupLineType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" DialupLineType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    destinationID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  sourceID = new DialingString;
    sourceID->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  subChannelID = new SubChannelID;
    subChannelID->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // DialupLineType::BDecContent

AsnLen DialupLineType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void DialupLineType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" DialupLineType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void DialupLineType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "destinationID ";
	destinationID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (sourceID))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "sourceID ";
		sourceID->Print(os, indent);
	}

	if (NOT_NULL (subChannelID))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "subChannelID ";
		subChannelID->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of DialupLineType::Print()

void DialupLineType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    destinationID.PrintXML(os, "destinationID");

  if (NOT_NULL (sourceID))
  {
    sourceID->PrintXML(os, "sourceID");
  }

  if (NOT_NULL (subChannelID))
  {
    subChannelID->PrintXML(os, "subChannelID");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // DialupLineType::PrintXML


LineInformationType::LineInformationType(const LineInformationType &that)
{
   Init();
   *this = that;
}
void LineInformationType::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = leasedLineInfoCid;
  leasedLineInfo = NULL;
}


int LineInformationType::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (leasedLineInfo != NULL)
		leasedLineInfo->checkConstraints(pConstraintFails);

	if (dialupLineHandle != NULL)
		dialupLineHandle->checkConstraints(pConstraintFails);

	return 0;
}


void LineInformationType::Clear()
{
  switch (choiceId)
  {
    case leasedLineInfoCid:
      delete leasedLineInfo;
      leasedLineInfo = NULL;
      break;
    case dialupLineHandleCid:
      delete dialupLineHandle;
      dialupLineHandle = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *LineInformationType::Clone() const
{
  return new LineInformationType(*this);
}

LineInformationType &LineInformationType::operator = (const LineInformationType &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.leasedLineInfo != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case leasedLineInfoCid:
           leasedLineInfo = new LeasedLineType(*that.leasedLineInfo);
           break;
         case dialupLineHandleCid:
           dialupLineHandle = new AsnInt(*that.dialupLineHandle);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
LineInformationType::BEncContent (AsnBuf &_b) const
{
    FUNC("LineInformationType::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case leasedLineInfoCid:
      l = leasedLineInfo->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
      break;

    case dialupLineHandleCid:
      l = dialupLineHandle->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // LineInformationType::BEncContent


void LineInformationType::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("LineInformationType::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 0):
      choiceId = leasedLineInfoCid;
        leasedLineInfo = new LeasedLineType;
        leasedLineInfo->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 1):
      choiceId = dialupLineHandleCid;
        dialupLineHandle = new AsnInt;
        dialupLineHandle->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // LineInformationType::BDecContent


AsnLen LineInformationType::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void LineInformationType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void LineInformationType::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case leasedLineInfoCid:
		os << "leasedLineInfo ";
		if (leasedLineInfo)
			leasedLineInfo->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case dialupLineHandleCid:
		os << "dialupLineHandle ";
		if (dialupLineHandle)
			dialupLineHandle->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of LineInformationType::Print()

void LineInformationType::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"LineInformationType\" type=\"CHOICE\">";
  }
  else
        os << "<LineInformationType type=\"CHOICE\">";
  switch (choiceId)
  {
    case leasedLineInfoCid:
      if (leasedLineInfo)
        leasedLineInfo->PrintXML(os,"leasedLineInfo");
      else
      {
        os << "<leasedLineInfo -- void3 -- /leasedLineInfo>" << std::endl;
      }
      break;

    case dialupLineHandleCid:
      if (dialupLineHandle)
        dialupLineHandle->PrintXML(os,"dialupLineHandle");
      else
      {
        os << "<dialupLineHandle -- void3 -- /dialupLineHandle>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</LineInformationType>";
} // LineInformationType::PrintXML

LineResourceInfo::LineResourceInfo(const LineResourceInfo &that)
{
   Init();
   *this = that;
}
void LineResourceInfo::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = leasedLineIDCid;
  leasedLineID = NULL;
}


int LineResourceInfo::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (leasedLineID != NULL)
		leasedLineID->checkConstraints(pConstraintFails);

	if (dialupLineInfo != NULL)
		dialupLineInfo->checkConstraints(pConstraintFails);

	return 0;
}


void LineResourceInfo::Clear()
{
  switch (choiceId)
  {
    case leasedLineIDCid:
      delete leasedLineID;
      leasedLineID = NULL;
      break;
    case dialupLineInfoCid:
      delete dialupLineInfo;
      dialupLineInfo = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *LineResourceInfo::Clone() const
{
  return new LineResourceInfo(*this);
}

LineResourceInfo &LineResourceInfo::operator = (const LineResourceInfo &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.leasedLineID != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case leasedLineIDCid:
           leasedLineID = new AsnInt(*that.leasedLineID);
           break;
         case dialupLineInfoCid:
           dialupLineInfo = new DialupLineType(*that.dialupLineInfo);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
LineResourceInfo::BEncContent (AsnBuf &_b) const
{
    FUNC("LineResourceInfo::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case leasedLineIDCid:
      l = leasedLineID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
      break;

    case dialupLineInfoCid:
      l = dialupLineInfo->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // LineResourceInfo::BEncContent


void LineResourceInfo::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("LineResourceInfo::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 0):
      choiceId = leasedLineIDCid;
        leasedLineID = new AsnInt;
        leasedLineID->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = dialupLineInfoCid;
        dialupLineInfo = new DialupLineType;
        dialupLineInfo->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // LineResourceInfo::BDecContent


AsnLen LineResourceInfo::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void LineResourceInfo::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void LineResourceInfo::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case leasedLineIDCid:
		os << "leasedLineID ";
		if (leasedLineID)
			leasedLineID->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case dialupLineInfoCid:
		os << "dialupLineInfo ";
		if (dialupLineInfo)
			dialupLineInfo->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of LineResourceInfo::Print()

void LineResourceInfo::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"LineResourceInfo\" type=\"CHOICE\">";
  }
  else
        os << "<LineResourceInfo type=\"CHOICE\">";
  switch (choiceId)
  {
    case leasedLineIDCid:
      if (leasedLineID)
        leasedLineID->PrintXML(os,"leasedLineID");
      else
      {
        os << "<leasedLineID -- void3 -- /leasedLineID>" << std::endl;
      }
      break;

    case dialupLineInfoCid:
      if (dialupLineInfo)
        dialupLineInfo->PrintXML(os,"dialupLineInfo");
      else
      {
        os << "<dialupLineInfo -- void3 -- /dialupLineInfo>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</LineResourceInfo>";
} // LineResourceInfo::PrintXML

void LineInfoAckType::Init(void)
{
}


int LineInfoAckType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	lineInfo.checkConstraints(pConstraintFails);

	lineState.checkConstraints(pConstraintFails);

	return 0;
}


void LineInfoAckType::Clear()
{
  lineInfo.Clear();
}

LineInfoAckType::LineInfoAckType(const LineInfoAckType &that)
{
   Init();
   *this = that;
}
AsnType *LineInfoAckType::Clone() const
{
  return new LineInfoAckType(*this);
}

LineInfoAckType &LineInfoAckType::operator = (const LineInfoAckType &that)
{
  if (this != &that)
  {
    Clear();
    lineInfo = that.lineInfo;
    lineState = that.lineState;
  }

  return *this;
}

AsnLen
LineInfoAckType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = lineState.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = lineInfo.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // LineInfoAckType::BEncContent


void LineInfoAckType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" LineInfoAckType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    lineInfo.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    lineState.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // LineInfoAckType::BDecContent

AsnLen LineInfoAckType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void LineInfoAckType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" LineInfoAckType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void LineInfoAckType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "lineInfo ";
	lineInfo.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineState ";
	lineState.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of LineInfoAckType::Print()

void LineInfoAckType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    lineInfo.PrintXML(os, "lineInfo");

    lineState.PrintXML(os, "lineState");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // LineInfoAckType::PrintXML


DialupLineMask::SubChannelID & 
DialupLineMask::SubChannelID::operator =(const SubChannelID &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
DialupLineMask::SubChannelID::ValueRanges(int &sizeVRList) const
{
		static const ValueRange subChannelID_ValueRangeList[] = 
			{{ 1, 8, 1 }};

		sizeVRList = 1;
		return &subChannelID_ValueRangeList[0];
}

void DialupLineMask::Init(void)
{
  sourceID = NULL;
  subChannelID = NULL;
}


int DialupLineMask::checkConstraints(ConstraintFailList* pConstraintFails) const{
	destinationID.checkConstraints(pConstraintFails);

	lineHandle.checkConstraints(pConstraintFails);

	lineState.checkConstraints(pConstraintFails);

	if (sourceID != NULL)
		sourceID->checkConstraints(pConstraintFails);

	if (subChannelID != NULL)
		subChannelID->checkConstraints(pConstraintFails);

	return 0;
}


void DialupLineMask::Clear()
{
  lineState.Clear();
  if(sourceID)
    delete sourceID;
  sourceID = NULL;
  if(subChannelID)
    delete subChannelID;
  subChannelID = NULL;
}

DialupLineMask::DialupLineMask(const DialupLineMask &that)
{
   Init();
   *this = that;
}
AsnType *DialupLineMask::Clone() const
{
  return new DialupLineMask(*this);
}

DialupLineMask &DialupLineMask::operator = (const DialupLineMask &that)
{
  if (this != &that)
  {
    Clear();
    destinationID = that.destinationID;
    lineHandle = that.lineHandle;
    lineState = that.lineState;
    if (that.sourceID)
    {
      if (!sourceID)
        sourceID = new DialingString;
      *sourceID = *that.sourceID;
    }
    else
    {
      delete sourceID;
      sourceID = NULL;
    }
    if (that.subChannelID)
    {
      if (!subChannelID)
        subChannelID = new SubChannelID;
      *subChannelID = *that.subChannelID;
    }
    else
    {
      delete subChannelID;
      subChannelID = NULL;
    }
  }

  return *this;
}

AsnLen
DialupLineMask::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (subChannelID))
  {
    l = subChannelID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (sourceID))
  {
    l = sourceID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = lineState.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = lineHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = destinationID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // DialupLineMask::BEncContent


void DialupLineMask::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" DialupLineMask::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    destinationID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    lineHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    lineState.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  sourceID = new DialingString;
    sourceID->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  subChannelID = new SubChannelID;
    subChannelID->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // DialupLineMask::BDecContent

AsnLen DialupLineMask::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void DialupLineMask::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" DialupLineMask::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void DialupLineMask::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "destinationID ";
	destinationID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineHandle ";
	lineHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineState ";
	lineState.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (sourceID))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "sourceID ";
		sourceID->Print(os, indent);
	}

	if (NOT_NULL (subChannelID))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "subChannelID ";
		subChannelID->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of DialupLineMask::Print()

void DialupLineMask::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    destinationID.PrintXML(os, "destinationID");

    lineHandle.PrintXML(os, "lineHandle");

    lineState.PrintXML(os, "lineState");

  if (NOT_NULL (sourceID))
  {
    sourceID->PrintXML(os, "sourceID");
  }

  if (NOT_NULL (subChannelID))
  {
    subChannelID->PrintXML(os, "subChannelID");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // DialupLineMask::PrintXML


LineInformationMask::LineInformationMask(const LineInformationMask &that)
{
   Init();
   *this = that;
}
void LineInformationMask::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = channelMask64kCid;
  channelMask64k = NULL;
}


int LineInformationMask::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (channelMask64k != NULL)
		channelMask64k->checkConstraints(pConstraintFails);

	if (channelMask8k != NULL)
		channelMask8k->checkConstraints(pConstraintFails);

	if (dialupMask != NULL)
		dialupMask->checkConstraints(pConstraintFails);

	return 0;
}


void LineInformationMask::Clear()
{
  switch (choiceId)
  {
    case channelMask64kCid:
      delete channelMask64k;
      channelMask64k = NULL;
      break;
    case channelMask8kCid:
      delete channelMask8k;
      channelMask8k = NULL;
      break;
    case dialupMaskCid:
      delete dialupMask;
      dialupMask = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *LineInformationMask::Clone() const
{
  return new LineInformationMask(*this);
}

LineInformationMask &LineInformationMask::operator = (const LineInformationMask &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.channelMask64k != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case channelMask64kCid:
           channelMask64k = new ChannelMask_64k(*that.channelMask64k);
           break;
         case channelMask8kCid:
           channelMask8k = new ChannelMask_8k(*that.channelMask8k);
           break;
         case dialupMaskCid:
           dialupMask = new DialupLineMask(*that.dialupMask);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
LineInformationMask::BEncContent (AsnBuf &_b) const
{
    FUNC("LineInformationMask::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case channelMask64kCid:
      l = channelMask64k->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
      break;

    case channelMask8kCid:
      l = channelMask8k->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
      break;

    case dialupMaskCid:
      l = dialupMask->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // LineInformationMask::BEncContent


void LineInformationMask::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("LineInformationMask::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 0):
      choiceId = channelMask64kCid;
        channelMask64k = new ChannelMask_64k;
        channelMask64k->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = channelMask8kCid;
        channelMask8k = new ChannelMask_8k;
        channelMask8k->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = dialupMaskCid;
        dialupMask = new DialupLineMask;
        dialupMask->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // LineInformationMask::BDecContent


AsnLen LineInformationMask::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void LineInformationMask::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void LineInformationMask::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case channelMask64kCid:
		os << "channelMask64k ";
		if (channelMask64k)
			channelMask64k->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case channelMask8kCid:
		os << "channelMask8k ";
		if (channelMask8k)
			channelMask8k->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case dialupMaskCid:
		os << "dialupMask ";
		if (dialupMask)
			dialupMask->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of LineInformationMask::Print()

void LineInformationMask::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"LineInformationMask\" type=\"CHOICE\">";
  }
  else
        os << "<LineInformationMask type=\"CHOICE\">";
  switch (choiceId)
  {
    case channelMask64kCid:
      if (channelMask64k)
        channelMask64k->PrintXML(os,"channelMask64k");
      else
      {
        os << "<channelMask64k -- void3 -- /channelMask64k>" << std::endl;
      }
      break;

    case channelMask8kCid:
      if (channelMask8k)
        channelMask8k->PrintXML(os,"channelMask8k");
      else
      {
        os << "<channelMask8k -- void3 -- /channelMask8k>" << std::endl;
      }
      break;

    case dialupMaskCid:
      if (dialupMask)
        dialupMask->PrintXML(os,"dialupMask");
      else
      {
        os << "<dialupMask -- void3 -- /dialupMask>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</LineInformationMask>";
} // LineInformationMask::PrintXML

const SizeConstraint*  
SystemConnectionState::ConnectionName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint connectionName_SizeConstraintList[] = 
			{{ 0, 32, 1 }};

	sizeList = 1;
	return &connectionName_SizeConstraintList[0];
}


void SystemConnectionState::Init(void)
{
}


int SystemConnectionState::checkConstraints(ConstraintFailList* pConstraintFails) const{
	connectionID.checkConstraints(pConstraintFails);

	connectionName.checkConstraints(pConstraintFails);

	connectionState.checkConstraints(pConstraintFails);

	return 0;
}


void SystemConnectionState::Clear()
{
}

SystemConnectionState::SystemConnectionState(const SystemConnectionState &that)
{
   Init();
   *this = that;
}
AsnType *SystemConnectionState::Clone() const
{
  return new SystemConnectionState(*this);
}

SystemConnectionState &SystemConnectionState::operator = (const SystemConnectionState &that)
{
  if (this != &that)
  {
    Clear();
    connectionID = that.connectionID;
    connectionName = that.connectionName;
    connectionState = that.connectionState;
  }

  return *this;
}

AsnLen
SystemConnectionState::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = connectionState.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = connectionName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = connectionID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // SystemConnectionState::BEncContent


void SystemConnectionState::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SystemConnectionState::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    connectionID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    connectionName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    connectionState.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SystemConnectionState::BDecContent

AsnLen SystemConnectionState::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SystemConnectionState::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SystemConnectionState::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SystemConnectionState::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "connectionID ";
	connectionID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "connectionName ";
	connectionName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "connectionState ";
	connectionState.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SystemConnectionState::Print()

void SystemConnectionState::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    connectionID.PrintXML(os, "connectionID");

    connectionName.PrintXML(os, "connectionName");

    connectionState.PrintXML(os, "connectionState");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SystemConnectionState::PrintXML


const SizeConstraint*  
ResourceLoadInfo::ResourceName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint resourceName_SizeConstraintList[] = 
			{{ 0, 32, 1 }};

	sizeList = 1;
	return &resourceName_SizeConstraintList[0];
}


void ResourceLoadInfo::Init(void)
{
}


int ResourceLoadInfo::checkConstraints(ConstraintFailList* pConstraintFails) const{
	resourceID.checkConstraints(pConstraintFails);

	resourceName.checkConstraints(pConstraintFails);

	resourceLoad.checkConstraints(pConstraintFails);

	actBufferLoad.checkConstraints(pConstraintFails);

	maxBufferLoad.checkConstraints(pConstraintFails);

	return 0;
}


void ResourceLoadInfo::Clear()
{
}

ResourceLoadInfo::ResourceLoadInfo(const ResourceLoadInfo &that)
{
   Init();
   *this = that;
}
AsnType *ResourceLoadInfo::Clone() const
{
  return new ResourceLoadInfo(*this);
}

ResourceLoadInfo &ResourceLoadInfo::operator = (const ResourceLoadInfo &that)
{
  if (this != &that)
  {
    Clear();
    resourceID = that.resourceID;
    resourceName = that.resourceName;
    resourceLoad = that.resourceLoad;
    actBufferLoad = that.actBufferLoad;
    maxBufferLoad = that.maxBufferLoad;
  }

  return *this;
}

AsnLen
ResourceLoadInfo::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = maxBufferLoad.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = actBufferLoad.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = resourceLoad.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = resourceName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = resourceID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ResourceLoadInfo::BEncContent


void ResourceLoadInfo::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ResourceLoadInfo::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resourceID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resourceName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resourceLoad.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    actBufferLoad.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    maxBufferLoad.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ResourceLoadInfo::BDecContent

AsnLen ResourceLoadInfo::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ResourceLoadInfo::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ResourceLoadInfo::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ResourceLoadInfo::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "resourceID ";
	resourceID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "resourceName ";
	resourceName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "resourceLoad ";
	resourceLoad.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "actBufferLoad ";
	actBufferLoad.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "maxBufferLoad ";
	maxBufferLoad.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ResourceLoadInfo::Print()

void ResourceLoadInfo::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    resourceID.PrintXML(os, "resourceID");

    resourceName.PrintXML(os, "resourceName");

    resourceLoad.PrintXML(os, "resourceLoad");

    actBufferLoad.PrintXML(os, "actBufferLoad");

    maxBufferLoad.PrintXML(os, "maxBufferLoad");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ResourceLoadInfo::PrintXML


void MacFacilityType::Init(void)
{
}


int MacFacilityType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	uplinkRSSI.checkConstraints(pConstraintFails);

	pathDelay.checkConstraints(pConstraintFails);

	return 0;
}


void MacFacilityType::Clear()
{
}

MacFacilityType::MacFacilityType(const MacFacilityType &that)
{
   Init();
   *this = that;
}
AsnType *MacFacilityType::Clone() const
{
  return new MacFacilityType(*this);
}

MacFacilityType &MacFacilityType::operator = (const MacFacilityType &that)
{
  if (this != &that)
  {
    Clear();
    uplinkRSSI = that.uplinkRSSI;
    pathDelay = that.pathDelay;
  }

  return *this;
}

AsnLen
MacFacilityType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = pathDelay.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = uplinkRSSI.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MacFacilityType::BEncContent


void MacFacilityType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MacFacilityType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    uplinkRSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    pathDelay.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MacFacilityType::BDecContent

AsnLen MacFacilityType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void MacFacilityType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MacFacilityType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MacFacilityType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "uplinkRSSI ";
	uplinkRSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "pathDelay ";
	pathDelay.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MacFacilityType::Print()

void MacFacilityType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    uplinkRSSI.PrintXML(os, "uplinkRSSI");

    pathDelay.PrintXML(os, "pathDelay");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MacFacilityType::PrintXML


void DynGroupMemberState::Init(void)
{
}


int DynGroupMemberState::checkConstraints(ConstraintFailList* pConstraintFails) const{
	affectedSsi.checkConstraints(pConstraintFails);

	attachmentState.checkConstraints(pConstraintFails);

	return 0;
}


void DynGroupMemberState::Clear()
{
  affectedSsi.Clear();
}

DynGroupMemberState::DynGroupMemberState(const DynGroupMemberState &that)
{
   Init();
   *this = that;
}
AsnType *DynGroupMemberState::Clone() const
{
  return new DynGroupMemberState(*this);
}

DynGroupMemberState &DynGroupMemberState::operator = (const DynGroupMemberState &that)
{
  if (this != &that)
  {
    Clear();
    affectedSsi = that.affectedSsi;
    attachmentState = that.attachmentState;
  }

  return *this;
}

AsnLen
DynGroupMemberState::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = attachmentState.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = affectedSsi.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // DynGroupMemberState::BEncContent


void DynGroupMemberState::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" DynGroupMemberState::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    affectedSsi.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    attachmentState.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // DynGroupMemberState::BDecContent

AsnLen DynGroupMemberState::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void DynGroupMemberState::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" DynGroupMemberState::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void DynGroupMemberState::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "affectedSsi ";
	affectedSsi.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "attachmentState ";
	attachmentState.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of DynGroupMemberState::Print()

void DynGroupMemberState::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    affectedSsi.PrintXML(os, "affectedSsi");

    attachmentState.PrintXML(os, "attachmentState");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // DynGroupMemberState::PrintXML


void CallTransferType::Init(void)
{
}


int CallTransferType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	requestingSsi.checkConstraints(pConstraintFails);

	return 0;
}


void CallTransferType::Clear()
{
  requestingSsi.Clear();
}

CallTransferType::CallTransferType(const CallTransferType &that)
{
   Init();
   *this = that;
}
AsnType *CallTransferType::Clone() const
{
  return new CallTransferType(*this);
}

CallTransferType &CallTransferType::operator = (const CallTransferType &that)
{
  if (this != &that)
  {
    Clear();
    requestingSsi = that.requestingSsi;
  }

  return *this;
}

AsnLen
CallTransferType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = requestingSsi.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CallTransferType::BEncContent


void CallTransferType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CallTransferType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    requestingSsi.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CallTransferType::BDecContent

AsnLen CallTransferType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void CallTransferType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CallTransferType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CallTransferType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "requestingSsi ";
	requestingSsi.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CallTransferType::Print()

void CallTransferType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    requestingSsi.PrintXML(os, "requestingSsi");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CallTransferType::PrintXML


void CallForwardingEntryType::Init(void)
{
}


int CallForwardingEntryType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	forwardedPartySSI.checkConstraints(pConstraintFails);

	forwardToParty.checkConstraints(pConstraintFails);

	forwardingType.checkConstraints(pConstraintFails);

	forwardingService.checkConstraints(pConstraintFails);

	return 0;
}


void CallForwardingEntryType::Clear()
{
  forwardedPartySSI.Clear();
  forwardToParty.Clear();
}

CallForwardingEntryType::CallForwardingEntryType(const CallForwardingEntryType &that)
{
   Init();
   *this = that;
}
AsnType *CallForwardingEntryType::Clone() const
{
  return new CallForwardingEntryType(*this);
}

CallForwardingEntryType &CallForwardingEntryType::operator = (const CallForwardingEntryType &that)
{
  if (this != &that)
  {
    Clear();
    forwardedPartySSI = that.forwardedPartySSI;
    forwardToParty = that.forwardToParty;
    forwardingType = that.forwardingType;
    forwardingService = that.forwardingService;
  }

  return *this;
}

AsnLen
CallForwardingEntryType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = forwardingService.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = forwardingType.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = forwardToParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = forwardedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CallForwardingEntryType::BEncContent


void CallForwardingEntryType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CallForwardingEntryType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardedPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    forwardToParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingType.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingService.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CallForwardingEntryType::BDecContent

AsnLen CallForwardingEntryType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void CallForwardingEntryType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CallForwardingEntryType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CallForwardingEntryType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "forwardedPartySSI ";
	forwardedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardToParty ";
	forwardToParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingType ";
	forwardingType.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingService ";
	forwardingService.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CallForwardingEntryType::Print()

void CallForwardingEntryType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    forwardedPartySSI.PrintXML(os, "forwardedPartySSI");

    forwardToParty.PrintXML(os, "forwardToParty");

    forwardingType.PrintXML(os, "forwardingType");

    forwardingService.PrintXML(os, "forwardingService");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CallForwardingEntryType::PrintXML


void OociEntryType::Init(void)
{
  useOociAsCLI = NULL;
}


int OociEntryType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	assignedOOCI.checkConstraints(pConstraintFails);

	affectedPartySSI.checkConstraints(pConstraintFails);

	if (useOociAsCLI != NULL)
		useOociAsCLI->checkConstraints(pConstraintFails);

	return 0;
}


void OociEntryType::Clear()
{
  assignedOOCI.Clear();
  affectedPartySSI.Clear();
  if(useOociAsCLI)
    delete useOociAsCLI;
  useOociAsCLI = NULL;
}

OociEntryType::OociEntryType(const OociEntryType &that)
{
   Init();
   *this = that;
}
AsnType *OociEntryType::Clone() const
{
  return new OociEntryType(*this);
}

OociEntryType &OociEntryType::operator = (const OociEntryType &that)
{
  if (this != &that)
  {
    Clear();
    assignedOOCI = that.assignedOOCI;
    affectedPartySSI = that.affectedPartySSI;
    if (that.useOociAsCLI)
    {
      if (!useOociAsCLI)
        useOociAsCLI = new UseOociAsCliType;
      *useOociAsCLI = *that.useOociAsCLI;
    }
    else
    {
      delete useOociAsCLI;
      useOociAsCLI = NULL;
    }
  }

  return *this;
}

AsnLen
OociEntryType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (useOociAsCLI))
  {
    l = useOociAsCLI->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = affectedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = assignedOOCI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // OociEntryType::BEncContent


void OociEntryType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" OociEntryType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    assignedOOCI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    affectedPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  useOociAsCLI = new UseOociAsCliType;
    useOociAsCLI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // OociEntryType::BDecContent

AsnLen OociEntryType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void OociEntryType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" OociEntryType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void OociEntryType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "assignedOOCI ";
	assignedOOCI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "affectedPartySSI ";
	affectedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (useOociAsCLI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "useOociAsCLI ";
		useOociAsCLI->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of OociEntryType::Print()

void OociEntryType::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    assignedOOCI.PrintXML(os, "assignedOOCI");

    affectedPartySSI.PrintXML(os, "affectedPartySSI");

  if (NOT_NULL (useOociAsCLI))
  {
    useOociAsCLI->PrintXML(os, "useOociAsCLI");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // OociEntryType::PrintXML


SS_AbortCauseType::SS_AbortCauseType(const SS_AbortCauseType &that)
{
   Init();
   *this = that;
}
void SS_AbortCauseType::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = callIdentificationCid;
  callIdentification = NULL;
}


int SS_AbortCauseType::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (callIdentification != NULL)
		callIdentification->checkConstraints(pConstraintFails);

	if (callReport != NULL)
		callReport->checkConstraints(pConstraintFails);

	if (talkingPartyIdentification != NULL)
		talkingPartyIdentification->checkConstraints(pConstraintFails);

	if (callForwarding != NULL)
		callForwarding->checkConstraints(pConstraintFails);

	if (listSearchCall != NULL)
		listSearchCall->checkConstraints(pConstraintFails);

	if (callAuthorizedByDispatcher != NULL)
		callAuthorizedByDispatcher->checkConstraints(pConstraintFails);

	if (shortNumberAddressing != NULL)
		shortNumberAddressing->checkConstraints(pConstraintFails);

	if (areaSelection != NULL)
		areaSelection->checkConstraints(pConstraintFails);

	if (accessPriority != NULL)
		accessPriority->checkConstraints(pConstraintFails);

	if (priorityCall != NULL)
		priorityCall->checkConstraints(pConstraintFails);

	if (callWaiting != NULL)
		callWaiting->checkConstraints(pConstraintFails);

	if (callHold != NULL)
		callHold->checkConstraints(pConstraintFails);

	if (callCompletionToBusySubscriber != NULL)
		callCompletionToBusySubscriber->checkConstraints(pConstraintFails);

	if (lateEntry != NULL)
		lateEntry->checkConstraints(pConstraintFails);

	if (preEmptivePriorityCall != NULL)
		preEmptivePriorityCall->checkConstraints(pConstraintFails);

	if (includeCall != NULL)
		includeCall->checkConstraints(pConstraintFails);

	if (barringOfOutgoingCalls != NULL)
		barringOfOutgoingCalls->checkConstraints(pConstraintFails);

	if (barringOfIncomingCalls != NULL)
		barringOfIncomingCalls->checkConstraints(pConstraintFails);

	if (discreetListening != NULL)
		discreetListening->checkConstraints(pConstraintFails);

	if (ambienceListening != NULL)
		ambienceListening->checkConstraints(pConstraintFails);

	if (dynamicGroupNumberAssignment != NULL)
		dynamicGroupNumberAssignment->checkConstraints(pConstraintFails);

	if (callCompletionOnNoReply != NULL)
		callCompletionOnNoReply->checkConstraints(pConstraintFails);

	if (callRetention != NULL)
		callRetention->checkConstraints(pConstraintFails);

	return 0;
}


void SS_AbortCauseType::Clear()
{
  switch (choiceId)
  {
    case callIdentificationCid:
      delete callIdentification;
      callIdentification = NULL;
      break;
    case callReportCid:
      delete callReport;
      callReport = NULL;
      break;
    case talkingPartyIdentificationCid:
      delete talkingPartyIdentification;
      talkingPartyIdentification = NULL;
      break;
    case callForwardingCid:
      delete callForwarding;
      callForwarding = NULL;
      break;
    case listSearchCallCid:
      delete listSearchCall;
      listSearchCall = NULL;
      break;
    case callAuthorizedByDispatcherCid:
      delete callAuthorizedByDispatcher;
      callAuthorizedByDispatcher = NULL;
      break;
    case shortNumberAddressingCid:
      delete shortNumberAddressing;
      shortNumberAddressing = NULL;
      break;
    case areaSelectionCid:
      delete areaSelection;
      areaSelection = NULL;
      break;
    case accessPriorityCid:
      delete accessPriority;
      accessPriority = NULL;
      break;
    case priorityCallCid:
      delete priorityCall;
      priorityCall = NULL;
      break;
    case callWaitingCid:
      delete callWaiting;
      callWaiting = NULL;
      break;
    case callHoldCid:
      delete callHold;
      callHold = NULL;
      break;
    case callCompletionToBusySubscriberCid:
      delete callCompletionToBusySubscriber;
      callCompletionToBusySubscriber = NULL;
      break;
    case lateEntryCid:
      delete lateEntry;
      lateEntry = NULL;
      break;
    case preEmptivePriorityCallCid:
      delete preEmptivePriorityCall;
      preEmptivePriorityCall = NULL;
      break;
    case includeCallCid:
      delete includeCall;
      includeCall = NULL;
      break;
    case barringOfOutgoingCallsCid:
      delete barringOfOutgoingCalls;
      barringOfOutgoingCalls = NULL;
      break;
    case barringOfIncomingCallsCid:
      delete barringOfIncomingCalls;
      barringOfIncomingCalls = NULL;
      break;
    case discreetListeningCid:
      delete discreetListening;
      discreetListening = NULL;
      break;
    case ambienceListeningCid:
      delete ambienceListening;
      ambienceListening = NULL;
      break;
    case dynamicGroupNumberAssignmentCid:
      delete dynamicGroupNumberAssignment;
      dynamicGroupNumberAssignment = NULL;
      break;
    case callCompletionOnNoReplyCid:
      delete callCompletionOnNoReply;
      callCompletionOnNoReply = NULL;
      break;
    case callRetentionCid:
      delete callRetention;
      callRetention = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *SS_AbortCauseType::Clone() const
{
  return new SS_AbortCauseType(*this);
}

SS_AbortCauseType &SS_AbortCauseType::operator = (const SS_AbortCauseType &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.callIdentification != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case callIdentificationCid:
           callIdentification = new AsnInt(*that.callIdentification);
           break;
         case callReportCid:
           callReport = new AsnInt(*that.callReport);
           break;
         case talkingPartyIdentificationCid:
           talkingPartyIdentification = new AsnInt(*that.talkingPartyIdentification);
           break;
         case callForwardingCid:
           callForwarding = new AsnInt(*that.callForwarding);
           break;
         case listSearchCallCid:
           listSearchCall = new AsnInt(*that.listSearchCall);
           break;
         case callAuthorizedByDispatcherCid:
           callAuthorizedByDispatcher = new SS_AbortCauseTypeInt(*that.callAuthorizedByDispatcher);
           break;
         case shortNumberAddressingCid:
           shortNumberAddressing = new AsnInt(*that.shortNumberAddressing);
           break;
         case areaSelectionCid:
           areaSelection = new AsnInt(*that.areaSelection);
           break;
         case accessPriorityCid:
           accessPriority = new AsnInt(*that.accessPriority);
           break;
         case priorityCallCid:
           priorityCall = new AsnInt(*that.priorityCall);
           break;
         case callWaitingCid:
           callWaiting = new AsnInt(*that.callWaiting);
           break;
         case callHoldCid:
           callHold = new AsnInt(*that.callHold);
           break;
         case callCompletionToBusySubscriberCid:
           callCompletionToBusySubscriber = new AsnInt(*that.callCompletionToBusySubscriber);
           break;
         case lateEntryCid:
           lateEntry = new AsnInt(*that.lateEntry);
           break;
         case preEmptivePriorityCallCid:
           preEmptivePriorityCall = new AsnInt(*that.preEmptivePriorityCall);
           break;
         case includeCallCid:
           includeCall = new AsnInt(*that.includeCall);
           break;
         case barringOfOutgoingCallsCid:
           barringOfOutgoingCalls = new AsnInt(*that.barringOfOutgoingCalls);
           break;
         case barringOfIncomingCallsCid:
           barringOfIncomingCalls = new AsnInt(*that.barringOfIncomingCalls);
           break;
         case discreetListeningCid:
           discreetListening = new AsnInt(*that.discreetListening);
           break;
         case ambienceListeningCid:
           ambienceListening = new SS_AbortCauseTypeInt1(*that.ambienceListening);
           break;
         case dynamicGroupNumberAssignmentCid:
           dynamicGroupNumberAssignment = new AsnInt(*that.dynamicGroupNumberAssignment);
           break;
         case callCompletionOnNoReplyCid:
           callCompletionOnNoReply = new AsnInt(*that.callCompletionOnNoReply);
           break;
         case callRetentionCid:
           callRetention = new AsnInt(*that.callRetention);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
SS_AbortCauseType::BEncContent (AsnBuf &_b) const
{
    FUNC("SS_AbortCauseType::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case callIdentificationCid:
      l = callIdentification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
      break;

    case callReportCid:
      l = callReport->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
      break;

    case talkingPartyIdentificationCid:
      l = talkingPartyIdentification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
      break;

    case callForwardingCid:
      l = callForwarding->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
      break;

    case listSearchCallCid:
      l = listSearchCall->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
      break;

    case callAuthorizedByDispatcherCid:
      l = callAuthorizedByDispatcher->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
      break;

    case shortNumberAddressingCid:
      l = shortNumberAddressing->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 7);
      break;

    case areaSelectionCid:
      l = areaSelection->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 8);
      break;

    case accessPriorityCid:
      l = accessPriority->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 9);
      break;

    case priorityCallCid:
      l = priorityCall->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 10);
      break;

    case callWaitingCid:
      l = callWaiting->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 11);
      break;

    case callHoldCid:
      l = callHold->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 12);
      break;

    case callCompletionToBusySubscriberCid:
      l = callCompletionToBusySubscriber->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 13);
      break;

    case lateEntryCid:
      l = lateEntry->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 14);
      break;

    case preEmptivePriorityCallCid:
      l = preEmptivePriorityCall->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 16);
      break;

    case includeCallCid:
      l = includeCall->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 17);
      break;

    case barringOfOutgoingCallsCid:
      l = barringOfOutgoingCalls->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 18);
      break;

    case barringOfIncomingCallsCid:
      l = barringOfIncomingCalls->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 19);
      break;

    case discreetListeningCid:
      l = discreetListening->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 20);
      break;

    case ambienceListeningCid:
      l = ambienceListening->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 21);
      break;

    case dynamicGroupNumberAssignmentCid:
      l = dynamicGroupNumberAssignment->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 22);
      break;

    case callCompletionOnNoReplyCid:
      l = callCompletionOnNoReply->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 23);
      break;

    case callRetentionCid:
      l = callRetention->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 24);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // SS_AbortCauseType::BEncContent


void SS_AbortCauseType::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("SS_AbortCauseType::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 1):
      choiceId = callIdentificationCid;
        callIdentification = new AsnInt;
        callIdentification->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 2):
      choiceId = callReportCid;
        callReport = new AsnInt;
        callReport->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 3):
      choiceId = talkingPartyIdentificationCid;
        talkingPartyIdentification = new AsnInt;
        talkingPartyIdentification->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 4):
      choiceId = callForwardingCid;
        callForwarding = new AsnInt;
        callForwarding->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 5):
      choiceId = listSearchCallCid;
        listSearchCall = new AsnInt;
        listSearchCall->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 6):
      choiceId = callAuthorizedByDispatcherCid;
        callAuthorizedByDispatcher = new SS_AbortCauseTypeInt;
        callAuthorizedByDispatcher->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 7):
      choiceId = shortNumberAddressingCid;
        shortNumberAddressing = new AsnInt;
        shortNumberAddressing->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 8):
      choiceId = areaSelectionCid;
        areaSelection = new AsnInt;
        areaSelection->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 9):
      choiceId = accessPriorityCid;
        accessPriority = new AsnInt;
        accessPriority->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 10):
      choiceId = priorityCallCid;
        priorityCall = new AsnInt;
        priorityCall->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 11):
      choiceId = callWaitingCid;
        callWaiting = new AsnInt;
        callWaiting->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 12):
      choiceId = callHoldCid;
        callHold = new AsnInt;
        callHold->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 13):
      choiceId = callCompletionToBusySubscriberCid;
        callCompletionToBusySubscriber = new AsnInt;
        callCompletionToBusySubscriber->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 14):
      choiceId = lateEntryCid;
        lateEntry = new AsnInt;
        lateEntry->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 16):
      choiceId = preEmptivePriorityCallCid;
        preEmptivePriorityCall = new AsnInt;
        preEmptivePriorityCall->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 17):
      choiceId = includeCallCid;
        includeCall = new AsnInt;
        includeCall->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 18):
      choiceId = barringOfOutgoingCallsCid;
        barringOfOutgoingCalls = new AsnInt;
        barringOfOutgoingCalls->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 19):
      choiceId = barringOfIncomingCallsCid;
        barringOfIncomingCalls = new AsnInt;
        barringOfIncomingCalls->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 20):
      choiceId = discreetListeningCid;
        discreetListening = new AsnInt;
        discreetListening->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 21):
      choiceId = ambienceListeningCid;
        ambienceListening = new SS_AbortCauseTypeInt1;
        ambienceListening->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 22):
      choiceId = dynamicGroupNumberAssignmentCid;
        dynamicGroupNumberAssignment = new AsnInt;
        dynamicGroupNumberAssignment->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 23):
      choiceId = callCompletionOnNoReplyCid;
        callCompletionOnNoReply = new AsnInt;
        callCompletionOnNoReply->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, PRIM, 24):
      choiceId = callRetentionCid;
        callRetention = new AsnInt;
        callRetention->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // SS_AbortCauseType::BDecContent


AsnLen SS_AbortCauseType::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void SS_AbortCauseType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void SS_AbortCauseType::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case callIdentificationCid:
		os << "callIdentification ";
		if (callIdentification)
			callIdentification->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case callReportCid:
		os << "callReport ";
		if (callReport)
			callReport->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case talkingPartyIdentificationCid:
		os << "talkingPartyIdentification ";
		if (talkingPartyIdentification)
			talkingPartyIdentification->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case callForwardingCid:
		os << "callForwarding ";
		if (callForwarding)
			callForwarding->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case listSearchCallCid:
		os << "listSearchCall ";
		if (listSearchCall)
			listSearchCall->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case callAuthorizedByDispatcherCid:
		os << "callAuthorizedByDispatcher ";
		if (callAuthorizedByDispatcher)
			callAuthorizedByDispatcher->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case shortNumberAddressingCid:
		os << "shortNumberAddressing ";
		if (shortNumberAddressing)
			shortNumberAddressing->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case areaSelectionCid:
		os << "areaSelection ";
		if (areaSelection)
			areaSelection->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case accessPriorityCid:
		os << "accessPriority ";
		if (accessPriority)
			accessPriority->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case priorityCallCid:
		os << "priorityCall ";
		if (priorityCall)
			priorityCall->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case callWaitingCid:
		os << "callWaiting ";
		if (callWaiting)
			callWaiting->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case callHoldCid:
		os << "callHold ";
		if (callHold)
			callHold->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case callCompletionToBusySubscriberCid:
		os << "callCompletionToBusySubscriber ";
		if (callCompletionToBusySubscriber)
			callCompletionToBusySubscriber->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case lateEntryCid:
		os << "lateEntry ";
		if (lateEntry)
			lateEntry->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case preEmptivePriorityCallCid:
		os << "preEmptivePriorityCall ";
		if (preEmptivePriorityCall)
			preEmptivePriorityCall->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case includeCallCid:
		os << "includeCall ";
		if (includeCall)
			includeCall->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case barringOfOutgoingCallsCid:
		os << "barringOfOutgoingCalls ";
		if (barringOfOutgoingCalls)
			barringOfOutgoingCalls->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case barringOfIncomingCallsCid:
		os << "barringOfIncomingCalls ";
		if (barringOfIncomingCalls)
			barringOfIncomingCalls->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case discreetListeningCid:
		os << "discreetListening ";
		if (discreetListening)
			discreetListening->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case ambienceListeningCid:
		os << "ambienceListening ";
		if (ambienceListening)
			ambienceListening->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case dynamicGroupNumberAssignmentCid:
		os << "dynamicGroupNumberAssignment ";
		if (dynamicGroupNumberAssignment)
			dynamicGroupNumberAssignment->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case callCompletionOnNoReplyCid:
		os << "callCompletionOnNoReply ";
		if (callCompletionOnNoReply)
			callCompletionOnNoReply->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case callRetentionCid:
		os << "callRetention ";
		if (callRetention)
			callRetention->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of SS_AbortCauseType::Print()

void SS_AbortCauseType::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"SS_AbortCauseType\" type=\"CHOICE\">";
  }
  else
        os << "<SS_AbortCauseType type=\"CHOICE\">";
  switch (choiceId)
  {
    case callIdentificationCid:
      if (callIdentification)
        callIdentification->PrintXML(os,"callIdentification");
      else
      {
        os << "<callIdentification -- void3 -- /callIdentification>" << std::endl;
      }
      break;

    case callReportCid:
      if (callReport)
        callReport->PrintXML(os,"callReport");
      else
      {
        os << "<callReport -- void3 -- /callReport>" << std::endl;
      }
      break;

    case talkingPartyIdentificationCid:
      if (talkingPartyIdentification)
        talkingPartyIdentification->PrintXML(os,"talkingPartyIdentification");
      else
      {
        os << "<talkingPartyIdentification -- void3 -- /talkingPartyIdentification>" << std::endl;
      }
      break;

    case callForwardingCid:
      if (callForwarding)
        callForwarding->PrintXML(os,"callForwarding");
      else
      {
        os << "<callForwarding -- void3 -- /callForwarding>" << std::endl;
      }
      break;

    case listSearchCallCid:
      if (listSearchCall)
        listSearchCall->PrintXML(os,"listSearchCall");
      else
      {
        os << "<listSearchCall -- void3 -- /listSearchCall>" << std::endl;
      }
      break;

    case callAuthorizedByDispatcherCid:
      if (callAuthorizedByDispatcher)
        callAuthorizedByDispatcher->PrintXML(os,"callAuthorizedByDispatcher");
      else
      {
        os << "<callAuthorizedByDispatcher -- void3 -- /callAuthorizedByDispatcher>" << std::endl;
      }
      break;

    case shortNumberAddressingCid:
      if (shortNumberAddressing)
        shortNumberAddressing->PrintXML(os,"shortNumberAddressing");
      else
      {
        os << "<shortNumberAddressing -- void3 -- /shortNumberAddressing>" << std::endl;
      }
      break;

    case areaSelectionCid:
      if (areaSelection)
        areaSelection->PrintXML(os,"areaSelection");
      else
      {
        os << "<areaSelection -- void3 -- /areaSelection>" << std::endl;
      }
      break;

    case accessPriorityCid:
      if (accessPriority)
        accessPriority->PrintXML(os,"accessPriority");
      else
      {
        os << "<accessPriority -- void3 -- /accessPriority>" << std::endl;
      }
      break;

    case priorityCallCid:
      if (priorityCall)
        priorityCall->PrintXML(os,"priorityCall");
      else
      {
        os << "<priorityCall -- void3 -- /priorityCall>" << std::endl;
      }
      break;

    case callWaitingCid:
      if (callWaiting)
        callWaiting->PrintXML(os,"callWaiting");
      else
      {
        os << "<callWaiting -- void3 -- /callWaiting>" << std::endl;
      }
      break;

    case callHoldCid:
      if (callHold)
        callHold->PrintXML(os,"callHold");
      else
      {
        os << "<callHold -- void3 -- /callHold>" << std::endl;
      }
      break;

    case callCompletionToBusySubscriberCid:
      if (callCompletionToBusySubscriber)
        callCompletionToBusySubscriber->PrintXML(os,"callCompletionToBusySubscriber");
      else
      {
        os << "<callCompletionToBusySubscriber -- void3 -- /callCompletionToBusySubscriber>" << std::endl;
      }
      break;

    case lateEntryCid:
      if (lateEntry)
        lateEntry->PrintXML(os,"lateEntry");
      else
      {
        os << "<lateEntry -- void3 -- /lateEntry>" << std::endl;
      }
      break;

    case preEmptivePriorityCallCid:
      if (preEmptivePriorityCall)
        preEmptivePriorityCall->PrintXML(os,"preEmptivePriorityCall");
      else
      {
        os << "<preEmptivePriorityCall -- void3 -- /preEmptivePriorityCall>" << std::endl;
      }
      break;

    case includeCallCid:
      if (includeCall)
        includeCall->PrintXML(os,"includeCall");
      else
      {
        os << "<includeCall -- void3 -- /includeCall>" << std::endl;
      }
      break;

    case barringOfOutgoingCallsCid:
      if (barringOfOutgoingCalls)
        barringOfOutgoingCalls->PrintXML(os,"barringOfOutgoingCalls");
      else
      {
        os << "<barringOfOutgoingCalls -- void3 -- /barringOfOutgoingCalls>" << std::endl;
      }
      break;

    case barringOfIncomingCallsCid:
      if (barringOfIncomingCalls)
        barringOfIncomingCalls->PrintXML(os,"barringOfIncomingCalls");
      else
      {
        os << "<barringOfIncomingCalls -- void3 -- /barringOfIncomingCalls>" << std::endl;
      }
      break;

    case discreetListeningCid:
      if (discreetListening)
        discreetListening->PrintXML(os,"discreetListening");
      else
      {
        os << "<discreetListening -- void3 -- /discreetListening>" << std::endl;
      }
      break;

    case ambienceListeningCid:
      if (ambienceListening)
        ambienceListening->PrintXML(os,"ambienceListening");
      else
      {
        os << "<ambienceListening -- void3 -- /ambienceListening>" << std::endl;
      }
      break;

    case dynamicGroupNumberAssignmentCid:
      if (dynamicGroupNumberAssignment)
        dynamicGroupNumberAssignment->PrintXML(os,"dynamicGroupNumberAssignment");
      else
      {
        os << "<dynamicGroupNumberAssignment -- void3 -- /dynamicGroupNumberAssignment>" << std::endl;
      }
      break;

    case callCompletionOnNoReplyCid:
      if (callCompletionOnNoReply)
        callCompletionOnNoReply->PrintXML(os,"callCompletionOnNoReply");
      else
      {
        os << "<callCompletionOnNoReply -- void3 -- /callCompletionOnNoReply>" << std::endl;
      }
      break;

    case callRetentionCid:
      if (callRetention)
        callRetention->PrintXML(os,"callRetention");
      else
      {
        os << "<callRetention -- void3 -- /callRetention>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</SS_AbortCauseType>";
} // SS_AbortCauseType::PrintXML

const SizeConstraint*  
ACAPI_OpenService::LoginName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint loginName_SizeConstraintList[] = 
			{{ 0, 32, 1 }};

	sizeList = 1;
	return &loginName_SizeConstraintList[0];
}


void ACAPI_OpenService::Init(void)
{
  lineResourceInfo = NULL;
}


int ACAPI_OpenService::checkConstraints(ConstraintFailList* pConstraintFails) const{
	loginName.checkConstraints(pConstraintFails);

	version.checkConstraints(pConstraintFails);

	serviceReq.checkConstraints(pConstraintFails);

	ssiReq.checkConstraints(pConstraintFails);

	if (lineResourceInfo != NULL)
		lineResourceInfo->checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_OpenService::Clear()
{
  ssiReq.Clear();
  if(lineResourceInfo)
    delete lineResourceInfo;
  lineResourceInfo = NULL;
}

ACAPI_OpenService::ACAPI_OpenService(const ACAPI_OpenService &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_OpenService::Clone() const
{
  return new ACAPI_OpenService(*this);
}

ACAPI_OpenService &ACAPI_OpenService::operator = (const ACAPI_OpenService &that)
{
  if (this != &that)
  {
    Clear();
    loginName = that.loginName;
    version = that.version;
    serviceReq = that.serviceReq;
    ssiReq = that.ssiReq;
    if (that.lineResourceInfo)
    {
      if (!lineResourceInfo)
        lineResourceInfo = new ACAPI_OpenServiceSeqOf;
      *lineResourceInfo = *that.lineResourceInfo;
    }
    else
    {
      delete lineResourceInfo;
      lineResourceInfo = NULL;
    }
  }

  return *this;
}

AsnLen
ACAPI_OpenService::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (lineResourceInfo))
  {
    l = lineResourceInfo->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;
  }

    l = ssiReq.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = serviceReq.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = version.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = loginName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_OpenService::BEncContent


void ACAPI_OpenService::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_OpenService::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    loginName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    version.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    ssiReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  lineResourceInfo = new ACAPI_OpenServiceSeqOf;
    lineResourceInfo->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_OpenService::BDecContent

AsnLen ACAPI_OpenService::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 10);
  return l;
}

void ACAPI_OpenService::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_OpenService::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 10))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_OpenService::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "loginName ";
	loginName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "version ";
	version.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceReq ";
	serviceReq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "ssiReq ";
	ssiReq.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (lineResourceInfo))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineResourceInfo ";
		lineResourceInfo->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_OpenService::Print()

void ACAPI_OpenService::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    loginName.PrintXML(os, "loginName");

    version.PrintXML(os, "version");

    serviceReq.PrintXML(os, "serviceReq");

    ssiReq.PrintXML(os, "ssiReq");

  if (NOT_NULL (lineResourceInfo))
  {
    lineResourceInfo->PrintXML(os, "lineResourceInfo");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_OpenService::PrintXML


void ACAPI_OpenService_Ack::Init(void)
{
}


int ACAPI_OpenService_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	version.checkConstraints(pConstraintFails);

	serviceResp.checkConstraints(pConstraintFails);

	ssiResp.checkConstraints(pConstraintFails);

	serviceHandle.checkConstraints(pConstraintFails);

	applWindowSize.checkConstraints(pConstraintFails);

	serviceWindowSize.checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_OpenService_Ack::Clear()
{
  ssiResp.Clear();
}

ACAPI_OpenService_Ack::ACAPI_OpenService_Ack(const ACAPI_OpenService_Ack &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_OpenService_Ack::Clone() const
{
  return new ACAPI_OpenService_Ack(*this);
}

ACAPI_OpenService_Ack &ACAPI_OpenService_Ack::operator = (const ACAPI_OpenService_Ack &that)
{
  if (this != &that)
  {
    Clear();
    version = that.version;
    serviceResp = that.serviceResp;
    ssiResp = that.ssiResp;
    serviceHandle = that.serviceHandle;
    applWindowSize = that.applWindowSize;
    serviceWindowSize = that.serviceWindowSize;
  }

  return *this;
}

AsnLen
ACAPI_OpenService_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = serviceWindowSize.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = applWindowSize.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = serviceHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = ssiResp.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = serviceResp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = version.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_OpenService_Ack::BEncContent


void ACAPI_OpenService_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_OpenService_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    version.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceResp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    ssiResp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    applWindowSize.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceWindowSize.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_OpenService_Ack::BDecContent

AsnLen ACAPI_OpenService_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 11);
  return l;
}

void ACAPI_OpenService_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_OpenService_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 11))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_OpenService_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "version ";
	version.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceResp ";
	serviceResp.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "ssiResp ";
	ssiResp.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceHandle ";
	serviceHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "applWindowSize ";
	applWindowSize.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceWindowSize ";
	serviceWindowSize.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_OpenService_Ack::Print()

void ACAPI_OpenService_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    version.PrintXML(os, "version");

    serviceResp.PrintXML(os, "serviceResp");

    ssiResp.PrintXML(os, "ssiResp");

    serviceHandle.PrintXML(os, "serviceHandle");

    applWindowSize.PrintXML(os, "applWindowSize");

    serviceWindowSize.PrintXML(os, "serviceWindowSize");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_OpenService_Ack::PrintXML


void ACAPI_CloseService::Init(void)
{
  serviceReq = NULL;
  ssiReq = NULL;
}


int ACAPI_CloseService::checkConstraints(ConstraintFailList* pConstraintFails) const{
	result.checkConstraints(pConstraintFails);

	if (serviceReq != NULL)
		serviceReq->checkConstraints(pConstraintFails);

	if (ssiReq != NULL)
		ssiReq->checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_CloseService::Clear()
{
  if(serviceReq)
    delete serviceReq;
  serviceReq = NULL;
  if(ssiReq)
    delete ssiReq;
  ssiReq = NULL;
}

ACAPI_CloseService::ACAPI_CloseService(const ACAPI_CloseService &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_CloseService::Clone() const
{
  return new ACAPI_CloseService(*this);
}

ACAPI_CloseService &ACAPI_CloseService::operator = (const ACAPI_CloseService &that)
{
  if (this != &that)
  {
    Clear();
    result = that.result;
    if (that.serviceReq)
    {
      if (!serviceReq)
        serviceReq = new ServiceIDType;
      *serviceReq = *that.serviceReq;
    }
    else
    {
      delete serviceReq;
      serviceReq = NULL;
    }
    if (that.ssiReq)
    {
      if (!ssiReq)
        ssiReq = new TETRA_Address;
      *ssiReq = *that.ssiReq;
    }
    else
    {
      delete ssiReq;
      ssiReq = NULL;
    }
  }

  return *this;
}

AsnLen
ACAPI_CloseService::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (ssiReq))
  {
    l = ssiReq->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

  if (NOT_NULL (serviceReq))
  {
    l = serviceReq->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_CloseService::BEncContent


void ACAPI_CloseService::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_CloseService::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  serviceReq = new ServiceIDType;
    serviceReq->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssiReq = new TETRA_Address;
    ssiReq->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_CloseService::BDecContent

AsnLen ACAPI_CloseService::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 12);
  return l;
}

void ACAPI_CloseService::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_CloseService::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 12))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_CloseService::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (serviceReq))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "serviceReq ";
		serviceReq->Print(os, indent);
	}

	if (NOT_NULL (ssiReq))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssiReq ";
		ssiReq->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_CloseService::Print()

void ACAPI_CloseService::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    result.PrintXML(os, "result");

  if (NOT_NULL (serviceReq))
  {
    serviceReq->PrintXML(os, "serviceReq");
  }

  if (NOT_NULL (ssiReq))
  {
    ssiReq->PrintXML(os, "ssiReq");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_CloseService::PrintXML


const SizeConstraint*  
ACAPI_Authorization_Req::LoginName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint loginName_SizeConstraintList[] = 
			{{ 0, 32, 1 }};

	sizeList = 1;
	return &loginName_SizeConstraintList[0];
}


const SizeConstraint*  
ACAPI_Authorization_Req::RequestString::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint requestString_SizeConstraintList[] = 
			{{ 0, 255, 1 }};

	sizeList = 1;
	return &requestString_SizeConstraintList[0];
}


const SizeConstraint*  
ACAPI_Authorization_Req::RandomSeed::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint randomSeed_SizeConstraintList[] = 
			{{ 0, 255, 1 }};

	sizeList = 1;
	return &randomSeed_SizeConstraintList[0];
}


void ACAPI_Authorization_Req::Init(void)
{
  requestString = NULL;
  randomSeed = NULL;
}


int ACAPI_Authorization_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	loginName.checkConstraints(pConstraintFails);

	serviceReq.checkConstraints(pConstraintFails);

	ssiReq.checkConstraints(pConstraintFails);

	serviceHandle.checkConstraints(pConstraintFails);

	authorizationMethod.checkConstraints(pConstraintFails);

	if (requestString != NULL)
		requestString->checkConstraints(pConstraintFails);

	if (randomSeed != NULL)
		randomSeed->checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_Authorization_Req::Clear()
{
  ssiReq.Clear();
  if(requestString)
    delete requestString;
  requestString = NULL;
  if(randomSeed)
    delete randomSeed;
  randomSeed = NULL;
}

ACAPI_Authorization_Req::ACAPI_Authorization_Req(const ACAPI_Authorization_Req &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_Authorization_Req::Clone() const
{
  return new ACAPI_Authorization_Req(*this);
}

ACAPI_Authorization_Req &ACAPI_Authorization_Req::operator = (const ACAPI_Authorization_Req &that)
{
  if (this != &that)
  {
    Clear();
    loginName = that.loginName;
    serviceReq = that.serviceReq;
    ssiReq = that.ssiReq;
    serviceHandle = that.serviceHandle;
    authorizationMethod = that.authorizationMethod;
    if (that.requestString)
    {
      if (!requestString)
        requestString = new RequestString;
      *requestString = *that.requestString;
    }
    else
    {
      delete requestString;
      requestString = NULL;
    }
    if (that.randomSeed)
    {
      if (!randomSeed)
        randomSeed = new RandomSeed;
      *randomSeed = *that.randomSeed;
    }
    else
    {
      delete randomSeed;
      randomSeed = NULL;
    }
  }

  return *this;
}

AsnLen
ACAPI_Authorization_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (randomSeed))
  {
    l = randomSeed->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (requestString))
  {
    l = requestString->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

    l = authorizationMethod.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = serviceHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = ssiReq.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = serviceReq.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = loginName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_Authorization_Req::BEncContent


void ACAPI_Authorization_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Authorization_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    loginName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    ssiReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    authorizationMethod.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  requestString = new RequestString;
    requestString->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  randomSeed = new RandomSeed;
    randomSeed->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_Authorization_Req::BDecContent

AsnLen ACAPI_Authorization_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 14);
  return l;
}

void ACAPI_Authorization_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Authorization_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 14))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_Authorization_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "loginName ";
	loginName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceReq ";
	serviceReq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "ssiReq ";
	ssiReq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceHandle ";
	serviceHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "authorizationMethod ";
	authorizationMethod.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (requestString))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "requestString ";
		requestString->Print(os, indent);
	}

	if (NOT_NULL (randomSeed))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "randomSeed ";
		randomSeed->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_Authorization_Req::Print()

void ACAPI_Authorization_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    loginName.PrintXML(os, "loginName");

    serviceReq.PrintXML(os, "serviceReq");

    ssiReq.PrintXML(os, "ssiReq");

    serviceHandle.PrintXML(os, "serviceHandle");

    authorizationMethod.PrintXML(os, "authorizationMethod");

  if (NOT_NULL (requestString))
  {
    requestString->PrintXML(os, "requestString");
  }

  if (NOT_NULL (randomSeed))
  {
    randomSeed->PrintXML(os, "randomSeed");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_Authorization_Req::PrintXML


const SizeConstraint*  
ACAPI_Authorization::LoginName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint loginName_SizeConstraintList[] = 
			{{ 0, 32, 1 }};

	sizeList = 1;
	return &loginName_SizeConstraintList[0];
}


const SizeConstraint*  
ACAPI_Authorization::AuthorizationString::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint authorizationString_SizeConstraintList[] = 
			{{ 0, 255, 1 }};

	sizeList = 1;
	return &authorizationString_SizeConstraintList[0];
}


const SizeConstraint*  
ACAPI_Authorization::RandomSeed::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint randomSeed_SizeConstraintList[] = 
			{{ 0, 255, 1 }};

	sizeList = 1;
	return &randomSeed_SizeConstraintList[0];
}


void ACAPI_Authorization::Init(void)
{
  randomSeed = NULL;
}


int ACAPI_Authorization::checkConstraints(ConstraintFailList* pConstraintFails) const{
	loginName.checkConstraints(pConstraintFails);

	serviceReq.checkConstraints(pConstraintFails);

	ssiReq.checkConstraints(pConstraintFails);

	authorizationMethod.checkConstraints(pConstraintFails);

	authorizationString.checkConstraints(pConstraintFails);

	if (randomSeed != NULL)
		randomSeed->checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_Authorization::Clear()
{
  ssiReq.Clear();
  if(randomSeed)
    delete randomSeed;
  randomSeed = NULL;
}

ACAPI_Authorization::ACAPI_Authorization(const ACAPI_Authorization &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_Authorization::Clone() const
{
  return new ACAPI_Authorization(*this);
}

ACAPI_Authorization &ACAPI_Authorization::operator = (const ACAPI_Authorization &that)
{
  if (this != &that)
  {
    Clear();
    loginName = that.loginName;
    serviceReq = that.serviceReq;
    ssiReq = that.ssiReq;
    authorizationMethod = that.authorizationMethod;
    authorizationString = that.authorizationString;
    if (that.randomSeed)
    {
      if (!randomSeed)
        randomSeed = new RandomSeed;
      *randomSeed = *that.randomSeed;
    }
    else
    {
      delete randomSeed;
      randomSeed = NULL;
    }
  }

  return *this;
}

AsnLen
ACAPI_Authorization::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (randomSeed))
  {
    l = randomSeed->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

    l = authorizationString.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = authorizationMethod.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = ssiReq.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = serviceReq.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = loginName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_Authorization::BEncContent


void ACAPI_Authorization::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Authorization::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    loginName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    ssiReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    authorizationMethod.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    authorizationString.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  randomSeed = new RandomSeed;
    randomSeed->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_Authorization::BDecContent

AsnLen ACAPI_Authorization::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 15);
  return l;
}

void ACAPI_Authorization::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Authorization::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 15))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_Authorization::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "loginName ";
	loginName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceReq ";
	serviceReq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "ssiReq ";
	ssiReq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "authorizationMethod ";
	authorizationMethod.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "authorizationString ";
	authorizationString.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (randomSeed))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "randomSeed ";
		randomSeed->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_Authorization::Print()

void ACAPI_Authorization::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    loginName.PrintXML(os, "loginName");

    serviceReq.PrintXML(os, "serviceReq");

    ssiReq.PrintXML(os, "ssiReq");

    authorizationMethod.PrintXML(os, "authorizationMethod");

    authorizationString.PrintXML(os, "authorizationString");

  if (NOT_NULL (randomSeed))
  {
    randomSeed->PrintXML(os, "randomSeed");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_Authorization::PrintXML


const SizeConstraint*  
ACAPI_Error_Info::ErrorText::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint errorText_SizeConstraintList[] = 
			{{ 0, 255, 1 }};

	sizeList = 1;
	return &errorText_SizeConstraintList[0];
}


void ACAPI_Error_Info::Init(void)
{
  affectedSSI = NULL;
  callID = NULL;
}


int ACAPI_Error_Info::checkConstraints(ConstraintFailList* pConstraintFails) const{
	errorText.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	if (affectedSSI != NULL)
		affectedSSI->checkConstraints(pConstraintFails);

	if (callID != NULL)
		callID->checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_Error_Info::Clear()
{
  if(affectedSSI)
    delete affectedSSI;
  affectedSSI = NULL;
  if(callID)
    delete callID;
  callID = NULL;
}

ACAPI_Error_Info::ACAPI_Error_Info(const ACAPI_Error_Info &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_Error_Info::Clone() const
{
  return new ACAPI_Error_Info(*this);
}

ACAPI_Error_Info &ACAPI_Error_Info::operator = (const ACAPI_Error_Info &that)
{
  if (this != &that)
  {
    Clear();
    errorText = that.errorText;
    timeStamp = that.timeStamp;
    if (that.affectedSSI)
    {
      if (!affectedSSI)
        affectedSSI = new TETRA_Address;
      *affectedSSI = *that.affectedSSI;
    }
    else
    {
      delete affectedSSI;
      affectedSSI = NULL;
    }
    if (that.callID)
    {
      if (!callID)
        callID = new AsnInt;
      *callID = *that.callID;
    }
    else
    {
      delete callID;
      callID = NULL;
    }
  }

  return *this;
}

AsnLen
ACAPI_Error_Info::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (callID))
  {
    l = callID->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (affectedSSI))
  {
    l = affectedSSI->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = errorText.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_Error_Info::BEncContent


void ACAPI_Error_Info::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Error_Info::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    errorText.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  affectedSSI = new TETRA_Address;
    affectedSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callID = new AsnInt;
    callID->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_Error_Info::BDecContent

AsnLen ACAPI_Error_Info::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 17);
  return l;
}

void ACAPI_Error_Info::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Error_Info::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 17))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_Error_Info::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "errorText ";
	errorText.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (affectedSSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "affectedSSI ";
		affectedSSI->Print(os, indent);
	}

	if (NOT_NULL (callID))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callID ";
		callID->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_Error_Info::Print()

void ACAPI_Error_Info::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    errorText.PrintXML(os, "errorText");

    timeStamp.PrintXML(os, "timeStamp");

  if (NOT_NULL (affectedSSI))
  {
    affectedSSI->PrintXML(os, "affectedSSI");
  }

  if (NOT_NULL (callID))
  {
    callID->PrintXML(os, "callID");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_Error_Info::PrintXML


void SDS_Data::Init(void)
{
  areaSelection = NULL;
  priorityClass = NULL;
  acknowlegeExpected = NULL;
  sourceLocation = NULL;
  macFacility = NULL;
}


int SDS_Data::checkConstraints(ConstraintFailList* pConstraintFails) const{
	calledParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	sdsHandle.checkConstraints(pConstraintFails);

	sdsData.checkConstraints(pConstraintFails);

	if (areaSelection != NULL)
		areaSelection->checkConstraints(pConstraintFails);

	if (priorityClass != NULL)
		priorityClass->checkConstraints(pConstraintFails);

	if (acknowlegeExpected != NULL)
		acknowlegeExpected->checkConstraints(pConstraintFails);

	if (sourceLocation != NULL)
		sourceLocation->checkConstraints(pConstraintFails);

	if (macFacility != NULL)
		macFacility->checkConstraints(pConstraintFails);

	return 0;
}


void SDS_Data::Clear()
{
  calledParty.Clear();
  callingParty.Clear();
  sdsData.Clear();
  if(areaSelection)
    delete areaSelection;
  areaSelection = NULL;
  if(priorityClass)
    delete priorityClass;
  priorityClass = NULL;
  if(acknowlegeExpected)
    delete acknowlegeExpected;
  acknowlegeExpected = NULL;
  if(sourceLocation)
    delete sourceLocation;
  sourceLocation = NULL;
  if(macFacility)
    delete macFacility;
  macFacility = NULL;
}

SDS_Data::SDS_Data(const SDS_Data &that)
{
   Init();
   *this = that;
}
AsnType *SDS_Data::Clone() const
{
  return new SDS_Data(*this);
}

SDS_Data &SDS_Data::operator = (const SDS_Data &that)
{
  if (this != &that)
  {
    Clear();
    calledParty = that.calledParty;
    callingParty = that.callingParty;
    sdsHandle = that.sdsHandle;
    sdsData = that.sdsData;
    if (that.areaSelection)
    {
      if (!areaSelection)
        areaSelection = new AreaType;
      *areaSelection = *that.areaSelection;
    }
    else
    {
      delete areaSelection;
      areaSelection = NULL;
    }
    if (that.priorityClass)
    {
      if (!priorityClass)
        priorityClass = new PriorityType;
      *priorityClass = *that.priorityClass;
    }
    else
    {
      delete priorityClass;
      priorityClass = NULL;
    }
    if (that.acknowlegeExpected)
    {
      if (!acknowlegeExpected)
        acknowlegeExpected = new AsnBool;
      *acknowlegeExpected = *that.acknowlegeExpected;
    }
    else
    {
      delete acknowlegeExpected;
      acknowlegeExpected = NULL;
    }
    if (that.sourceLocation)
    {
      if (!sourceLocation)
        sourceLocation = new LocationAreaType;
      *sourceLocation = *that.sourceLocation;
    }
    else
    {
      delete sourceLocation;
      sourceLocation = NULL;
    }
    if (that.macFacility)
    {
      if (!macFacility)
        macFacility = new MacFacilityType;
      *macFacility = *that.macFacility;
    }
    else
    {
      delete macFacility;
      macFacility = NULL;
    }
  }

  return *this;
}

AsnLen
SDS_Data::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (macFacility))
  {
    l = macFacility->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 8);
    totalLen += l;
  }

  if (NOT_NULL (sourceLocation))
  {
    l = sourceLocation->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 7);
    totalLen += l;
  }

  if (NOT_NULL (acknowlegeExpected))
  {
    l = acknowlegeExpected->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (priorityClass))
  {
    l = priorityClass->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (areaSelection))
  {
    l = areaSelection->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = sdsData.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = sdsHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = calledParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SDS_Data::BEncContent


void SDS_Data::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SDS_Data::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    calledParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    sdsHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    sdsData.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  areaSelection = new AreaType;
    areaSelection->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  priorityClass = new PriorityType;
    priorityClass->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  acknowlegeExpected = new AsnBool;
    acknowlegeExpected->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  sourceLocation = new LocationAreaType;
    sourceLocation->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  macFacility = new MacFacilityType;
    macFacility->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SDS_Data::BDecContent

AsnLen SDS_Data::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 20);
  return l;
}

void SDS_Data::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SDS_Data::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 20))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SDS_Data::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "calledParty ";
	calledParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "sdsHandle ";
	sdsHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "sdsData ";
	sdsData.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (areaSelection))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "areaSelection ";
		areaSelection->Print(os, indent);
	}

	if (NOT_NULL (priorityClass))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "priorityClass ";
		priorityClass->Print(os, indent);
	}

	if (NOT_NULL (acknowlegeExpected))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "acknowlegeExpected ";
		acknowlegeExpected->Print(os, indent);
	}

	if (NOT_NULL (sourceLocation))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "sourceLocation ";
		sourceLocation->Print(os, indent);
	}

	if (NOT_NULL (macFacility))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "macFacility ";
		macFacility->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SDS_Data::Print()

void SDS_Data::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    calledParty.PrintXML(os, "calledParty");

    callingParty.PrintXML(os, "callingParty");

    sdsHandle.PrintXML(os, "sdsHandle");

    sdsData.PrintXML(os, "sdsData");

  if (NOT_NULL (areaSelection))
  {
    areaSelection->PrintXML(os, "areaSelection");
  }

  if (NOT_NULL (priorityClass))
  {
    priorityClass->PrintXML(os, "priorityClass");
  }

  if (NOT_NULL (acknowlegeExpected))
  {
    acknowlegeExpected->PrintXML(os, "acknowlegeExpected");
  }

  if (NOT_NULL (sourceLocation))
  {
    sourceLocation->PrintXML(os, "sourceLocation");
  }

  if (NOT_NULL (macFacility))
  {
    macFacility->PrintXML(os, "macFacility");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SDS_Data::PrintXML


void SDS_Data_Ack::Init(void)
{
  isStatus = NULL;
}


int SDS_Data_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	calledParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	sdsHandle.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	if (isStatus != NULL)
		isStatus->checkConstraints(pConstraintFails);

	return 0;
}


void SDS_Data_Ack::Clear()
{
  calledParty.Clear();
  callingParty.Clear();
  if(isStatus)
    delete isStatus;
  isStatus = NULL;
}

SDS_Data_Ack::SDS_Data_Ack(const SDS_Data_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SDS_Data_Ack::Clone() const
{
  return new SDS_Data_Ack(*this);
}

SDS_Data_Ack &SDS_Data_Ack::operator = (const SDS_Data_Ack &that)
{
  if (this != &that)
  {
    Clear();
    calledParty = that.calledParty;
    callingParty = that.callingParty;
    sdsHandle = that.sdsHandle;
    result = that.result;
    if (that.isStatus)
    {
      if (!isStatus)
        isStatus = new AsnBool;
      *isStatus = *that.isStatus;
    }
    else
    {
      delete isStatus;
      isStatus = NULL;
    }
  }

  return *this;
}

AsnLen
SDS_Data_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (isStatus))
  {
    l = isStatus->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = sdsHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = calledParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SDS_Data_Ack::BEncContent


void SDS_Data_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SDS_Data_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    calledParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    sdsHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  isStatus = new AsnBool;
    isStatus->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SDS_Data_Ack::BDecContent

AsnLen SDS_Data_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 21);
  return l;
}

void SDS_Data_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SDS_Data_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 21))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SDS_Data_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "calledParty ";
	calledParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "sdsHandle ";
	sdsHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (isStatus))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "isStatus ";
		isStatus->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SDS_Data_Ack::Print()

void SDS_Data_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    calledParty.PrintXML(os, "calledParty");

    callingParty.PrintXML(os, "callingParty");

    sdsHandle.PrintXML(os, "sdsHandle");

    result.PrintXML(os, "result");

  if (NOT_NULL (isStatus))
  {
    isStatus->PrintXML(os, "isStatus");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SDS_Data_Ack::PrintXML


void CC_Setup_Req::Init(void)
{
  requestToTransmit = NULL;
  cliControl = NULL;
  areaSelection = NULL;
  priorityClass = NULL;
  callPriority = NULL;
  basicService = NULL;
  callTransfer = NULL;
  ambienceListening = NULL;
}


int CC_Setup_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	calledParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	hookSignalling.checkConstraints(pConstraintFails);

	duplexRequest.checkConstraints(pConstraintFails);

	lineInformation.checkConstraints(pConstraintFails);

	if (requestToTransmit != NULL)
		requestToTransmit->checkConstraints(pConstraintFails);

	if (cliControl != NULL)
		cliControl->checkConstraints(pConstraintFails);

	if (areaSelection != NULL)
		areaSelection->checkConstraints(pConstraintFails);

	if (priorityClass != NULL)
		priorityClass->checkConstraints(pConstraintFails);

	if (callPriority != NULL)
		callPriority->checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (callTransfer != NULL)
		callTransfer->checkConstraints(pConstraintFails);

	if (ambienceListening != NULL)
		ambienceListening->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Setup_Req::Clear()
{
  calledParty.Clear();
  callingParty.Clear();
  lineInformation.Clear();
  if(requestToTransmit)
    delete requestToTransmit;
  requestToTransmit = NULL;
  if(cliControl)
    delete cliControl;
  cliControl = NULL;
  if(areaSelection)
    delete areaSelection;
  areaSelection = NULL;
  if(priorityClass)
    delete priorityClass;
  priorityClass = NULL;
  if(callPriority)
    delete callPriority;
  callPriority = NULL;
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(callTransfer)
    delete callTransfer;
  callTransfer = NULL;
  if(ambienceListening)
    delete ambienceListening;
  ambienceListening = NULL;
}

CC_Setup_Req::CC_Setup_Req(const CC_Setup_Req &that)
{
   Init();
   *this = that;
}
AsnType *CC_Setup_Req::Clone() const
{
  return new CC_Setup_Req(*this);
}

CC_Setup_Req &CC_Setup_Req::operator = (const CC_Setup_Req &that)
{
  if (this != &that)
  {
    Clear();
    calledParty = that.calledParty;
    callingParty = that.callingParty;
    hookSignalling = that.hookSignalling;
    duplexRequest = that.duplexRequest;
    lineInformation = that.lineInformation;
    if (that.requestToTransmit)
    {
      if (!requestToTransmit)
        requestToTransmit = new AsnBool;
      *requestToTransmit = *that.requestToTransmit;
    }
    else
    {
      delete requestToTransmit;
      requestToTransmit = NULL;
    }
    if (that.cliControl)
    {
      if (!cliControl)
        cliControl = new CliType;
      *cliControl = *that.cliControl;
    }
    else
    {
      delete cliControl;
      cliControl = NULL;
    }
    if (that.areaSelection)
    {
      if (!areaSelection)
        areaSelection = new AreaType;
      *areaSelection = *that.areaSelection;
    }
    else
    {
      delete areaSelection;
      areaSelection = NULL;
    }
    if (that.priorityClass)
    {
      if (!priorityClass)
        priorityClass = new PriorityType;
      *priorityClass = *that.priorityClass;
    }
    else
    {
      delete priorityClass;
      priorityClass = NULL;
    }
    if (that.callPriority)
    {
      if (!callPriority)
        callPriority = new CallPriorityType;
      *callPriority = *that.callPriority;
    }
    else
    {
      delete callPriority;
      callPriority = NULL;
    }
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.callTransfer)
    {
      if (!callTransfer)
        callTransfer = new CallTransferType;
      *callTransfer = *that.callTransfer;
    }
    else
    {
      delete callTransfer;
      callTransfer = NULL;
    }
    if (that.ambienceListening)
    {
      if (!ambienceListening)
        ambienceListening = new AsnBool;
      *ambienceListening = *that.ambienceListening;
    }
    else
    {
      delete ambienceListening;
      ambienceListening = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Setup_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (ambienceListening))
  {
    l = ambienceListening->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 12);
    totalLen += l;
  }

  if (NOT_NULL (callTransfer))
  {
    l = callTransfer->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 11);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 10);
    totalLen += l;
  }

  if (NOT_NULL (callPriority))
  {
    l = callPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 9);
    totalLen += l;
  }

  if (NOT_NULL (priorityClass))
  {
    l = priorityClass->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 8);
    totalLen += l;
  }

  if (NOT_NULL (areaSelection))
  {
    l = areaSelection->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (cliControl))
  {
    l = cliControl->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (requestToTransmit))
  {
    l = requestToTransmit->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

    l = lineInformation.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;

    l = duplexRequest.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = hookSignalling.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = calledParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Setup_Req::BEncContent


void CC_Setup_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Setup_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    calledParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    hookSignalling.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    duplexRequest.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    lineInformation.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  requestToTransmit = new AsnBool;
    requestToTransmit->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  cliControl = new CliType;
    cliControl->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  areaSelection = new AreaType;
    areaSelection->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  priorityClass = new PriorityType;
    priorityClass->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 9)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callPriority = new CallPriorityType;
    callPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 10)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 11)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callTransfer = new CallTransferType;
    callTransfer->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 12)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ambienceListening = new AsnBool;
    ambienceListening->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Setup_Req::BDecContent

AsnLen CC_Setup_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 30);
  return l;
}

void CC_Setup_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Setup_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 30))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Setup_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "calledParty ";
	calledParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "hookSignalling ";
	hookSignalling.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "duplexRequest ";
	duplexRequest.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineInformation ";
	lineInformation.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (requestToTransmit))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "requestToTransmit ";
		requestToTransmit->Print(os, indent);
	}

	if (NOT_NULL (cliControl))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "cliControl ";
		cliControl->Print(os, indent);
	}

	if (NOT_NULL (areaSelection))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "areaSelection ";
		areaSelection->Print(os, indent);
	}

	if (NOT_NULL (priorityClass))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "priorityClass ";
		priorityClass->Print(os, indent);
	}

	if (NOT_NULL (callPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callPriority ";
		callPriority->Print(os, indent);
	}

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (callTransfer))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callTransfer ";
		callTransfer->Print(os, indent);
	}

	if (NOT_NULL (ambienceListening))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ambienceListening ";
		ambienceListening->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Setup_Req::Print()

void CC_Setup_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    calledParty.PrintXML(os, "calledParty");

    callingParty.PrintXML(os, "callingParty");

    hookSignalling.PrintXML(os, "hookSignalling");

    duplexRequest.PrintXML(os, "duplexRequest");

    lineInformation.PrintXML(os, "lineInformation");

  if (NOT_NULL (requestToTransmit))
  {
    requestToTransmit->PrintXML(os, "requestToTransmit");
  }

  if (NOT_NULL (cliControl))
  {
    cliControl->PrintXML(os, "cliControl");
  }

  if (NOT_NULL (areaSelection))
  {
    areaSelection->PrintXML(os, "areaSelection");
  }

  if (NOT_NULL (priorityClass))
  {
    priorityClass->PrintXML(os, "priorityClass");
  }

  if (NOT_NULL (callPriority))
  {
    callPriority->PrintXML(os, "callPriority");
  }

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (callTransfer))
  {
    callTransfer->PrintXML(os, "callTransfer");
  }

  if (NOT_NULL (ambienceListening))
  {
    ambienceListening->PrintXML(os, "ambienceListening");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Setup_Req::PrintXML


void CC_SetupInclude_Req::Init(void)
{
  cliControl = NULL;
  divertCall = NULL;
}


int CC_SetupInclude_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	includeParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	hookSignalling.checkConstraints(pConstraintFails);

	include2CallID.checkConstraints(pConstraintFails);

	if (cliControl != NULL)
		cliControl->checkConstraints(pConstraintFails);

	if (divertCall != NULL)
		divertCall->checkConstraints(pConstraintFails);

	return 0;
}


void CC_SetupInclude_Req::Clear()
{
  includeParty.Clear();
  callingParty.Clear();
  if(cliControl)
    delete cliControl;
  cliControl = NULL;
  if(divertCall)
    delete divertCall;
  divertCall = NULL;
}

CC_SetupInclude_Req::CC_SetupInclude_Req(const CC_SetupInclude_Req &that)
{
   Init();
   *this = that;
}
AsnType *CC_SetupInclude_Req::Clone() const
{
  return new CC_SetupInclude_Req(*this);
}

CC_SetupInclude_Req &CC_SetupInclude_Req::operator = (const CC_SetupInclude_Req &that)
{
  if (this != &that)
  {
    Clear();
    includeParty = that.includeParty;
    callingParty = that.callingParty;
    hookSignalling = that.hookSignalling;
    include2CallID = that.include2CallID;
    if (that.cliControl)
    {
      if (!cliControl)
        cliControl = new CliType;
      *cliControl = *that.cliControl;
    }
    else
    {
      delete cliControl;
      cliControl = NULL;
    }
    if (that.divertCall)
    {
      if (!divertCall)
        divertCall = new AsnBool;
      *divertCall = *that.divertCall;
    }
    else
    {
      delete divertCall;
      divertCall = NULL;
    }
  }

  return *this;
}

AsnLen
CC_SetupInclude_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (divertCall))
  {
    l = divertCall->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (cliControl))
  {
    l = cliControl->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = include2CallID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = hookSignalling.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = includeParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_SetupInclude_Req::BEncContent


void CC_SetupInclude_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_SetupInclude_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    includeParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    hookSignalling.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    include2CallID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  cliControl = new CliType;
    cliControl->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  divertCall = new AsnBool;
    divertCall->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_SetupInclude_Req::BDecContent

AsnLen CC_SetupInclude_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 120);
  return l;
}

void CC_SetupInclude_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_SetupInclude_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 120))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_SetupInclude_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "includeParty ";
	includeParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "hookSignalling ";
	hookSignalling.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "include2CallID ";
	include2CallID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (cliControl))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "cliControl ";
		cliControl->Print(os, indent);
	}

	if (NOT_NULL (divertCall))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "divertCall ";
		divertCall->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_SetupInclude_Req::Print()

void CC_SetupInclude_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    includeParty.PrintXML(os, "includeParty");

    callingParty.PrintXML(os, "callingParty");

    hookSignalling.PrintXML(os, "hookSignalling");

    include2CallID.PrintXML(os, "include2CallID");

  if (NOT_NULL (cliControl))
  {
    cliControl->PrintXML(os, "cliControl");
  }

  if (NOT_NULL (divertCall))
  {
    divertCall->PrintXML(os, "divertCall");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_SetupInclude_Req::PrintXML


void CC_Setup_Ind::Init(void)
{
  txGrant = NULL;
  txReqPermission = NULL;
  cliControl = NULL;
  callPriority = NULL;
  basicService = NULL;
  sourceLocation = NULL;
  ssNotification = NULL;
  temporarySSI = NULL;
  airEncryption = NULL;
  originalCalledParty = NULL;
  callForwardingReason = NULL;
  authorizationReq = NULL;
}


int CC_Setup_Ind::checkConstraints(ConstraintFailList* pConstraintFails) const{
	calledParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	hookSignalling.checkConstraints(pConstraintFails);

	duplexRequest.checkConstraints(pConstraintFails);

	callTimeOut.checkConstraints(pConstraintFails);

	if (txGrant != NULL)
		txGrant->checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (cliControl != NULL)
		cliControl->checkConstraints(pConstraintFails);

	if (callPriority != NULL)
		callPriority->checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (sourceLocation != NULL)
		sourceLocation->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	if (temporarySSI != NULL)
		temporarySSI->checkConstraints(pConstraintFails);

	if (airEncryption != NULL)
		airEncryption->checkConstraints(pConstraintFails);

	if (originalCalledParty != NULL)
		originalCalledParty->checkConstraints(pConstraintFails);

	if (callForwardingReason != NULL)
		callForwardingReason->checkConstraints(pConstraintFails);

	if (authorizationReq != NULL)
		authorizationReq->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Setup_Ind::Clear()
{
  calledParty.Clear();
  callingParty.Clear();
  if(txGrant)
    delete txGrant;
  txGrant = NULL;
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(cliControl)
    delete cliControl;
  cliControl = NULL;
  if(callPriority)
    delete callPriority;
  callPriority = NULL;
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(sourceLocation)
    delete sourceLocation;
  sourceLocation = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
  if(temporarySSI)
    delete temporarySSI;
  temporarySSI = NULL;
  if(airEncryption)
    delete airEncryption;
  airEncryption = NULL;
  if(originalCalledParty)
    delete originalCalledParty;
  originalCalledParty = NULL;
  if(callForwardingReason)
    delete callForwardingReason;
  callForwardingReason = NULL;
  if(authorizationReq)
    delete authorizationReq;
  authorizationReq = NULL;
}

CC_Setup_Ind::CC_Setup_Ind(const CC_Setup_Ind &that)
{
   Init();
   *this = that;
}
AsnType *CC_Setup_Ind::Clone() const
{
  return new CC_Setup_Ind(*this);
}

CC_Setup_Ind &CC_Setup_Ind::operator = (const CC_Setup_Ind &that)
{
  if (this != &that)
  {
    Clear();
    calledParty = that.calledParty;
    callingParty = that.callingParty;
    callID = that.callID;
    hookSignalling = that.hookSignalling;
    duplexRequest = that.duplexRequest;
    callTimeOut = that.callTimeOut;
    if (that.txGrant)
    {
      if (!txGrant)
        txGrant = new TxGrantType;
      *txGrant = *that.txGrant;
    }
    else
    {
      delete txGrant;
      txGrant = NULL;
    }
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.cliControl)
    {
      if (!cliControl)
        cliControl = new CliType;
      *cliControl = *that.cliControl;
    }
    else
    {
      delete cliControl;
      cliControl = NULL;
    }
    if (that.callPriority)
    {
      if (!callPriority)
        callPriority = new CallPriorityType;
      *callPriority = *that.callPriority;
    }
    else
    {
      delete callPriority;
      callPriority = NULL;
    }
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.sourceLocation)
    {
      if (!sourceLocation)
        sourceLocation = new LocationAreaType;
      *sourceLocation = *that.sourceLocation;
    }
    else
    {
      delete sourceLocation;
      sourceLocation = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
    if (that.temporarySSI)
    {
      if (!temporarySSI)
        temporarySSI = new TETRA_Address;
      *temporarySSI = *that.temporarySSI;
    }
    else
    {
      delete temporarySSI;
      temporarySSI = NULL;
    }
    if (that.airEncryption)
    {
      if (!airEncryption)
        airEncryption = new AirEncryptionType;
      *airEncryption = *that.airEncryption;
    }
    else
    {
      delete airEncryption;
      airEncryption = NULL;
    }
    if (that.originalCalledParty)
    {
      if (!originalCalledParty)
        originalCalledParty = new AddressType;
      *originalCalledParty = *that.originalCalledParty;
    }
    else
    {
      delete originalCalledParty;
      originalCalledParty = NULL;
    }
    if (that.callForwardingReason)
    {
      if (!callForwardingReason)
        callForwardingReason = new CallForwardingReasonType;
      *callForwardingReason = *that.callForwardingReason;
    }
    else
    {
      delete callForwardingReason;
      callForwardingReason = NULL;
    }
    if (that.authorizationReq)
    {
      if (!authorizationReq)
        authorizationReq = new AsnBool;
      *authorizationReq = *that.authorizationReq;
    }
    else
    {
      delete authorizationReq;
      authorizationReq = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Setup_Ind::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (authorizationReq))
  {
    l = authorizationReq->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 19);
    totalLen += l;
  }

  if (NOT_NULL (callForwardingReason))
  {
    l = callForwardingReason->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 18);
    totalLen += l;
  }

  if (NOT_NULL (originalCalledParty))
  {
    l = originalCalledParty->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 17);
    totalLen += l;
  }

  if (NOT_NULL (airEncryption))
  {
    l = airEncryption->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 14);
    totalLen += l;
  }

  if (NOT_NULL (temporarySSI))
  {
    l = temporarySSI->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 13);
    totalLen += l;
  }

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 12);
    totalLen += l;
  }

  if (NOT_NULL (sourceLocation))
  {
    l = sourceLocation->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 11);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 10);
    totalLen += l;
  }

  if (NOT_NULL (callPriority))
  {
    l = callPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 9);
    totalLen += l;
  }

  if (NOT_NULL (cliControl))
  {
    l = cliControl->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 8);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (txGrant))
  {
    l = txGrant->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

    l = callTimeOut.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = duplexRequest.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = hookSignalling.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = calledParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Setup_Ind::BEncContent


void CC_Setup_Ind::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Setup_Ind::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    calledParty.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    hookSignalling.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    duplexRequest.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callTimeOut.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txGrant = new TxGrantType;
    txGrant->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  cliControl = new CliType;
    cliControl->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 9)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callPriority = new CallPriorityType;
    callPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 10)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 11)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  sourceLocation = new LocationAreaType;
    sourceLocation->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 12)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 13)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  temporarySSI = new TETRA_Address;
    temporarySSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 14)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  airEncryption = new AirEncryptionType;
    airEncryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 17)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  originalCalledParty = new AddressType;
    originalCalledParty->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 18)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callForwardingReason = new CallForwardingReasonType;
    callForwardingReason->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 19)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  authorizationReq = new AsnBool;
    authorizationReq->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Setup_Ind::BDecContent

AsnLen CC_Setup_Ind::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 31);
  return l;
}

void CC_Setup_Ind::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Setup_Ind::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 31))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Setup_Ind::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "calledParty ";
	calledParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "hookSignalling ";
	hookSignalling.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "duplexRequest ";
	duplexRequest.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callTimeOut ";
	callTimeOut.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txGrant))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txGrant ";
		txGrant->Print(os, indent);
	}

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (cliControl))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "cliControl ";
		cliControl->Print(os, indent);
	}

	if (NOT_NULL (callPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callPriority ";
		callPriority->Print(os, indent);
	}

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (sourceLocation))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "sourceLocation ";
		sourceLocation->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	if (NOT_NULL (temporarySSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "temporarySSI ";
		temporarySSI->Print(os, indent);
	}

	if (NOT_NULL (airEncryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "airEncryption ";
		airEncryption->Print(os, indent);
	}

	if (NOT_NULL (originalCalledParty))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "originalCalledParty ";
		originalCalledParty->Print(os, indent);
	}

	if (NOT_NULL (callForwardingReason))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callForwardingReason ";
		callForwardingReason->Print(os, indent);
	}

	if (NOT_NULL (authorizationReq))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "authorizationReq ";
		authorizationReq->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Setup_Ind::Print()

void CC_Setup_Ind::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    calledParty.PrintXML(os, "calledParty");

    callingParty.PrintXML(os, "callingParty");

    callID.PrintXML(os, "callID");

    hookSignalling.PrintXML(os, "hookSignalling");

    duplexRequest.PrintXML(os, "duplexRequest");

    callTimeOut.PrintXML(os, "callTimeOut");

  if (NOT_NULL (txGrant))
  {
    txGrant->PrintXML(os, "txGrant");
  }

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (cliControl))
  {
    cliControl->PrintXML(os, "cliControl");
  }

  if (NOT_NULL (callPriority))
  {
    callPriority->PrintXML(os, "callPriority");
  }

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (sourceLocation))
  {
    sourceLocation->PrintXML(os, "sourceLocation");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (NOT_NULL (temporarySSI))
  {
    temporarySSI->PrintXML(os, "temporarySSI");
  }

  if (NOT_NULL (airEncryption))
  {
    airEncryption->PrintXML(os, "airEncryption");
  }

  if (NOT_NULL (originalCalledParty))
  {
    originalCalledParty->PrintXML(os, "originalCalledParty");
  }

  if (NOT_NULL (callForwardingReason))
  {
    callForwardingReason->PrintXML(os, "callForwardingReason");
  }

  if (NOT_NULL (authorizationReq))
  {
    authorizationReq->PrintXML(os, "authorizationReq");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Setup_Ind::PrintXML


void CC_Setup_Ack::Init(void)
{
  hookSignalling = NULL;
  duplexMode = NULL;
  basicService = NULL;
  callSetupTime = NULL;
  callTransfer = NULL;
  authorizationReq = NULL;
}


int CC_Setup_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	calledParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	if (hookSignalling != NULL)
		hookSignalling->checkConstraints(pConstraintFails);

	if (duplexMode != NULL)
		duplexMode->checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (callSetupTime != NULL)
		callSetupTime->checkConstraints(pConstraintFails);

	if (callTransfer != NULL)
		callTransfer->checkConstraints(pConstraintFails);

	if (authorizationReq != NULL)
		authorizationReq->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Setup_Ack::Clear()
{
  calledParty.Clear();
  callingParty.Clear();
  if(hookSignalling)
    delete hookSignalling;
  hookSignalling = NULL;
  if(duplexMode)
    delete duplexMode;
  duplexMode = NULL;
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(callSetupTime)
    delete callSetupTime;
  callSetupTime = NULL;
  if(callTransfer)
    delete callTransfer;
  callTransfer = NULL;
  if(authorizationReq)
    delete authorizationReq;
  authorizationReq = NULL;
}

CC_Setup_Ack::CC_Setup_Ack(const CC_Setup_Ack &that)
{
   Init();
   *this = that;
}
AsnType *CC_Setup_Ack::Clone() const
{
  return new CC_Setup_Ack(*this);
}

CC_Setup_Ack &CC_Setup_Ack::operator = (const CC_Setup_Ack &that)
{
  if (this != &that)
  {
    Clear();
    calledParty = that.calledParty;
    callingParty = that.callingParty;
    callID = that.callID;
    if (that.hookSignalling)
    {
      if (!hookSignalling)
        hookSignalling = new AsnBool;
      *hookSignalling = *that.hookSignalling;
    }
    else
    {
      delete hookSignalling;
      hookSignalling = NULL;
    }
    if (that.duplexMode)
    {
      if (!duplexMode)
        duplexMode = new AsnBool;
      *duplexMode = *that.duplexMode;
    }
    else
    {
      delete duplexMode;
      duplexMode = NULL;
    }
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.callSetupTime)
    {
      if (!callSetupTime)
        callSetupTime = new CallSetupTime;
      *callSetupTime = *that.callSetupTime;
    }
    else
    {
      delete callSetupTime;
      callSetupTime = NULL;
    }
    if (that.callTransfer)
    {
      if (!callTransfer)
        callTransfer = new CallTransferType;
      *callTransfer = *that.callTransfer;
    }
    else
    {
      delete callTransfer;
      callTransfer = NULL;
    }
    if (that.authorizationReq)
    {
      if (!authorizationReq)
        authorizationReq = new AsnBool;
      *authorizationReq = *that.authorizationReq;
    }
    else
    {
      delete authorizationReq;
      authorizationReq = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Setup_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (authorizationReq))
  {
    l = authorizationReq->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 8);
    totalLen += l;
  }

  if (NOT_NULL (callTransfer))
  {
    l = callTransfer->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 7);
    totalLen += l;
  }

  if (NOT_NULL (callSetupTime))
  {
    l = callSetupTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 5);
    totalLen += l;
  }

  if (NOT_NULL (duplexMode))
  {
    l = duplexMode->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (hookSignalling))
  {
    l = hookSignalling->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = calledParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Setup_Ack::BEncContent


void CC_Setup_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Setup_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    calledParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  hookSignalling = new AsnBool;
    hookSignalling->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  duplexMode = new AsnBool;
    duplexMode->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callSetupTime = new CallSetupTime;
    callSetupTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callTransfer = new CallTransferType;
    callTransfer->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  authorizationReq = new AsnBool;
    authorizationReq->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Setup_Ack::BDecContent

AsnLen CC_Setup_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 32);
  return l;
}

void CC_Setup_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Setup_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 32))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Setup_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "calledParty ";
	calledParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (hookSignalling))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "hookSignalling ";
		hookSignalling->Print(os, indent);
	}

	if (NOT_NULL (duplexMode))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "duplexMode ";
		duplexMode->Print(os, indent);
	}

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (callSetupTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callSetupTime ";
		callSetupTime->Print(os, indent);
	}

	if (NOT_NULL (callTransfer))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callTransfer ";
		callTransfer->Print(os, indent);
	}

	if (NOT_NULL (authorizationReq))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "authorizationReq ";
		authorizationReq->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Setup_Ack::Print()

void CC_Setup_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    calledParty.PrintXML(os, "calledParty");

    callingParty.PrintXML(os, "callingParty");

    callID.PrintXML(os, "callID");

  if (NOT_NULL (hookSignalling))
  {
    hookSignalling->PrintXML(os, "hookSignalling");
  }

  if (NOT_NULL (duplexMode))
  {
    duplexMode->PrintXML(os, "duplexMode");
  }

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (callSetupTime))
  {
    callSetupTime->PrintXML(os, "callSetupTime");
  }

  if (NOT_NULL (callTransfer))
  {
    callTransfer->PrintXML(os, "callTransfer");
  }

  if (NOT_NULL (authorizationReq))
  {
    authorizationReq->PrintXML(os, "authorizationReq");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Setup_Ack::PrintXML


CC_Information::PollRespNumber & 
CC_Information::PollRespNumber::operator =(const PollRespNumber &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
CC_Information::PollRespNumber::ValueRanges(int &sizeVRList) const
{
		static const ValueRange pollRespNumber_ValueRangeList[] = 
			{{ 0, 63, 1 }};

		sizeVRList = 1;
		return &pollRespNumber_ValueRangeList[0];
}

CC_Information::PollRespPercent & 
CC_Information::PollRespPercent::operator =(const PollRespPercent &that)
{
	m_len = that.m_len;
	delete m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
CC_Information::PollRespPercent::ValueRanges(int &sizeVRList) const
{
		static const ValueRange pollRespPercent_ValueRangeList[] = 
			{{ 0, 100, 1 }};

		sizeVRList = 1;
		return &pollRespPercent_ValueRangeList[0];
}

void CC_Information::Init(void)
{
  callState = NULL;
  duplexMode = NULL;
  basicService = NULL;
  ssNotification = NULL;
  temporarySSI = NULL;
  pollRequest = NULL;
  pollRespNumber = NULL;
  pollRespPercent = NULL;
  pollRespAddresses = NULL;
  dTMF = NULL;
  callSetupTime = NULL;
  lineInformation = NULL;
  alertedParty = NULL;
  dtmfErrorCode = NULL;
}


int CC_Information::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	if (callState != NULL)
		callState->checkConstraints(pConstraintFails);

	if (duplexMode != NULL)
		duplexMode->checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	if (temporarySSI != NULL)
		temporarySSI->checkConstraints(pConstraintFails);

	if (pollRequest != NULL)
		pollRequest->checkConstraints(pConstraintFails);

	if (pollRespNumber != NULL)
		pollRespNumber->checkConstraints(pConstraintFails);

	if (pollRespPercent != NULL)
		pollRespPercent->checkConstraints(pConstraintFails);

	if (pollRespAddresses != NULL)
		pollRespAddresses->checkConstraints(pConstraintFails);

	if (dTMF != NULL)
		dTMF->checkConstraints(pConstraintFails);

	if (callSetupTime != NULL)
		callSetupTime->checkConstraints(pConstraintFails);

	if (lineInformation != NULL)
		lineInformation->checkConstraints(pConstraintFails);

	if (alertedParty != NULL)
		alertedParty->checkConstraints(pConstraintFails);

	if (dtmfErrorCode != NULL)
		dtmfErrorCode->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Information::Clear()
{
  callPartySSI.Clear();
  if(callState)
    delete callState;
  callState = NULL;
  if(duplexMode)
    delete duplexMode;
  duplexMode = NULL;
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
  if(temporarySSI)
    delete temporarySSI;
  temporarySSI = NULL;
  if(pollRequest)
    delete pollRequest;
  pollRequest = NULL;
  if(pollRespNumber)
    delete pollRespNumber;
  pollRespNumber = NULL;
  if(pollRespPercent)
    delete pollRespPercent;
  pollRespPercent = NULL;
  if(pollRespAddresses)
    delete pollRespAddresses;
  pollRespAddresses = NULL;
  if(dTMF)
    delete dTMF;
  dTMF = NULL;
  if(callSetupTime)
    delete callSetupTime;
  callSetupTime = NULL;
  if(lineInformation)
    delete lineInformation;
  lineInformation = NULL;
  if(alertedParty)
    delete alertedParty;
  alertedParty = NULL;
  if(dtmfErrorCode)
    delete dtmfErrorCode;
  dtmfErrorCode = NULL;
}

CC_Information::CC_Information(const CC_Information &that)
{
   Init();
   *this = that;
}
AsnType *CC_Information::Clone() const
{
  return new CC_Information(*this);
}

CC_Information &CC_Information::operator = (const CC_Information &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    callID = that.callID;
    if (that.callState)
    {
      if (!callState)
        callState = new CallStateType;
      *callState = *that.callState;
    }
    else
    {
      delete callState;
      callState = NULL;
    }
    if (that.duplexMode)
    {
      if (!duplexMode)
        duplexMode = new AsnBool;
      *duplexMode = *that.duplexMode;
    }
    else
    {
      delete duplexMode;
      duplexMode = NULL;
    }
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
    if (that.temporarySSI)
    {
      if (!temporarySSI)
        temporarySSI = new TETRA_Address;
      *temporarySSI = *that.temporarySSI;
    }
    else
    {
      delete temporarySSI;
      temporarySSI = NULL;
    }
    if (that.pollRequest)
    {
      if (!pollRequest)
        pollRequest = new AsnBool;
      *pollRequest = *that.pollRequest;
    }
    else
    {
      delete pollRequest;
      pollRequest = NULL;
    }
    if (that.pollRespNumber)
    {
      if (!pollRespNumber)
        pollRespNumber = new PollRespNumber;
      *pollRespNumber = *that.pollRespNumber;
    }
    else
    {
      delete pollRespNumber;
      pollRespNumber = NULL;
    }
    if (that.pollRespPercent)
    {
      if (!pollRespPercent)
        pollRespPercent = new PollRespPercent;
      *pollRespPercent = *that.pollRespPercent;
    }
    else
    {
      delete pollRespPercent;
      pollRespPercent = NULL;
    }
    if (that.pollRespAddresses)
    {
      if (!pollRespAddresses)
        pollRespAddresses = new CC_InformationSeqOf;
      *pollRespAddresses = *that.pollRespAddresses;
    }
    else
    {
      delete pollRespAddresses;
      pollRespAddresses = NULL;
    }
    if (that.dTMF)
    {
      if (!dTMF)
        dTMF = new DTMFString;
      *dTMF = *that.dTMF;
    }
    else
    {
      delete dTMF;
      dTMF = NULL;
    }
    if (that.callSetupTime)
    {
      if (!callSetupTime)
        callSetupTime = new CallSetupTime;
      *callSetupTime = *that.callSetupTime;
    }
    else
    {
      delete callSetupTime;
      callSetupTime = NULL;
    }
    if (that.lineInformation)
    {
      if (!lineInformation)
        lineInformation = new LineInfoAckType;
      *lineInformation = *that.lineInformation;
    }
    else
    {
      delete lineInformation;
      lineInformation = NULL;
    }
    if (that.alertedParty)
    {
      if (!alertedParty)
        alertedParty = new AddressType;
      *alertedParty = *that.alertedParty;
    }
    else
    {
      delete alertedParty;
      alertedParty = NULL;
    }
    if (that.dtmfErrorCode)
    {
      if (!dtmfErrorCode)
        dtmfErrorCode = new CC_InformationInt;
      *dtmfErrorCode = *that.dtmfErrorCode;
    }
    else
    {
      delete dtmfErrorCode;
      dtmfErrorCode = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Information::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (dtmfErrorCode))
  {
    l = dtmfErrorCode->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 15);
    totalLen += l;
  }

  if (NOT_NULL (alertedParty))
  {
    l = alertedParty->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 14);
    totalLen += l;
  }

  if (NOT_NULL (lineInformation))
  {
    l = lineInformation->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 13);
    totalLen += l;
  }

  if (NOT_NULL (callSetupTime))
  {
    l = callSetupTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 12);
    totalLen += l;
  }

  if (NOT_NULL (dTMF))
  {
    l = dTMF->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 11);
    totalLen += l;
  }

  if (NOT_NULL (pollRespAddresses))
  {
    l = pollRespAddresses->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 10);
    totalLen += l;
  }

  if (NOT_NULL (pollRespPercent))
  {
    l = pollRespPercent->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 9);
    totalLen += l;
  }

  if (NOT_NULL (pollRespNumber))
  {
    l = pollRespNumber->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 8);
    totalLen += l;
  }

  if (NOT_NULL (pollRequest))
  {
    l = pollRequest->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (temporarySSI))
  {
    l = temporarySSI->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 6);
    totalLen += l;
  }

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;
  }

  if (NOT_NULL (duplexMode))
  {
    l = duplexMode->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (callState))
  {
    l = callState->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Information::BEncContent


void CC_Information::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Information::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callState = new CallStateType;
    callState->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  duplexMode = new AsnBool;
    duplexMode->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  temporarySSI = new TETRA_Address;
    temporarySSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  pollRequest = new AsnBool;
    pollRequest->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  pollRespNumber = new PollRespNumber;
    pollRespNumber->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 9)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  pollRespPercent = new PollRespPercent;
    pollRespPercent->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 10)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  pollRespAddresses = new CC_InformationSeqOf;
    pollRespAddresses->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 11))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 11)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  dTMF = new DTMFString;
    dTMF->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 12)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callSetupTime = new CallSetupTime;
    callSetupTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 13)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  lineInformation = new LineInfoAckType;
    lineInformation->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 14)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  alertedParty = new AddressType;
    alertedParty->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 15)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  dtmfErrorCode = new CC_InformationInt;
    dtmfErrorCode->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Information::BDecContent

AsnLen CC_Information::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 33);
  return l;
}

void CC_Information::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Information::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 33))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Information::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (callState))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callState ";
		callState->Print(os, indent);
	}

	if (NOT_NULL (duplexMode))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "duplexMode ";
		duplexMode->Print(os, indent);
	}

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	if (NOT_NULL (temporarySSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "temporarySSI ";
		temporarySSI->Print(os, indent);
	}

	if (NOT_NULL (pollRequest))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "pollRequest ";
		pollRequest->Print(os, indent);
	}

	if (NOT_NULL (pollRespNumber))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "pollRespNumber ";
		pollRespNumber->Print(os, indent);
	}

	if (NOT_NULL (pollRespPercent))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "pollRespPercent ";
		pollRespPercent->Print(os, indent);
	}

	if (NOT_NULL (pollRespAddresses))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "pollRespAddresses ";
		pollRespAddresses->Print(os, indent);
	}

	if (NOT_NULL (dTMF))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "dTMF ";
		dTMF->Print(os, indent);
	}

	if (NOT_NULL (callSetupTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callSetupTime ";
		callSetupTime->Print(os, indent);
	}

	if (NOT_NULL (lineInformation))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineInformation ";
		lineInformation->Print(os, indent);
	}

	if (NOT_NULL (alertedParty))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "alertedParty ";
		alertedParty->Print(os, indent);
	}

	if (NOT_NULL (dtmfErrorCode))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "dtmfErrorCode ";
		dtmfErrorCode->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Information::Print()

void CC_Information::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    callID.PrintXML(os, "callID");

  if (NOT_NULL (callState))
  {
    callState->PrintXML(os, "callState");
  }

  if (NOT_NULL (duplexMode))
  {
    duplexMode->PrintXML(os, "duplexMode");
  }

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (NOT_NULL (temporarySSI))
  {
    temporarySSI->PrintXML(os, "temporarySSI");
  }

  if (NOT_NULL (pollRequest))
  {
    pollRequest->PrintXML(os, "pollRequest");
  }

  if (NOT_NULL (pollRespNumber))
  {
    pollRespNumber->PrintXML(os, "pollRespNumber");
  }

  if (NOT_NULL (pollRespPercent))
  {
    pollRespPercent->PrintXML(os, "pollRespPercent");
  }

  if (NOT_NULL (pollRespAddresses))
  {
    pollRespAddresses->PrintXML(os, "pollRespAddresses");
  }

  if (NOT_NULL (dTMF))
  {
    dTMF->PrintXML(os, "dTMF");
  }

  if (NOT_NULL (callSetupTime))
  {
    callSetupTime->PrintXML(os, "callSetupTime");
  }

  if (NOT_NULL (lineInformation))
  {
    lineInformation->PrintXML(os, "lineInformation");
  }

  if (NOT_NULL (alertedParty))
  {
    alertedParty->PrintXML(os, "alertedParty");
  }

  if (NOT_NULL (dtmfErrorCode))
  {
    dtmfErrorCode->PrintXML(os, "dtmfErrorCode");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Information::PrintXML


void CC_Connect_Req::Init(void)
{
  duplexMode = NULL;
  basicService = NULL;
  ambienceListening = NULL;
}


int CC_Connect_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	lineInformation.checkConstraints(pConstraintFails);

	if (duplexMode != NULL)
		duplexMode->checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (ambienceListening != NULL)
		ambienceListening->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Connect_Req::Clear()
{
  callParty.Clear();
  lineInformation.Clear();
  if(duplexMode)
    delete duplexMode;
  duplexMode = NULL;
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(ambienceListening)
    delete ambienceListening;
  ambienceListening = NULL;
}

CC_Connect_Req::CC_Connect_Req(const CC_Connect_Req &that)
{
   Init();
   *this = that;
}
AsnType *CC_Connect_Req::Clone() const
{
  return new CC_Connect_Req(*this);
}

CC_Connect_Req &CC_Connect_Req::operator = (const CC_Connect_Req &that)
{
  if (this != &that)
  {
    Clear();
    callParty = that.callParty;
    callID = that.callID;
    lineInformation = that.lineInformation;
    if (that.duplexMode)
    {
      if (!duplexMode)
        duplexMode = new AsnBool;
      *duplexMode = *that.duplexMode;
    }
    else
    {
      delete duplexMode;
      duplexMode = NULL;
    }
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.ambienceListening)
    {
      if (!ambienceListening)
        ambienceListening = new AsnBool;
      *ambienceListening = *that.ambienceListening;
    }
    else
    {
      delete ambienceListening;
      ambienceListening = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Connect_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (ambienceListening))
  {
    l = ambienceListening->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;
  }

  if (NOT_NULL (duplexMode))
  {
    l = duplexMode->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = lineInformation.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Connect_Req::BEncContent


void CC_Connect_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Connect_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    lineInformation.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  duplexMode = new AsnBool;
    duplexMode->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ambienceListening = new AsnBool;
    ambienceListening->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Connect_Req::BDecContent

AsnLen CC_Connect_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 34);
  return l;
}

void CC_Connect_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Connect_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 34))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Connect_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callParty ";
	callParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineInformation ";
	lineInformation.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (duplexMode))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "duplexMode ";
		duplexMode->Print(os, indent);
	}

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (ambienceListening))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ambienceListening ";
		ambienceListening->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Connect_Req::Print()

void CC_Connect_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callParty.PrintXML(os, "callParty");

    callID.PrintXML(os, "callID");

    lineInformation.PrintXML(os, "lineInformation");

  if (NOT_NULL (duplexMode))
  {
    duplexMode->PrintXML(os, "duplexMode");
  }

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (ambienceListening))
  {
    ambienceListening->PrintXML(os, "ambienceListening");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Connect_Req::PrintXML


void CC_Connect_Ind::Init(void)
{
  txReqPermission = NULL;
  callPriority = NULL;
  basicService = NULL;
  ssNotification = NULL;
  connectedParty = NULL;
  airEncryption = NULL;
  callTimeOut = NULL;
}


int CC_Connect_Ind::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	hookSignalling.checkConstraints(pConstraintFails);

	duplexMode.checkConstraints(pConstraintFails);

	txGrant.checkConstraints(pConstraintFails);

	lineInfoAck.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (callPriority != NULL)
		callPriority->checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	if (connectedParty != NULL)
		connectedParty->checkConstraints(pConstraintFails);

	if (airEncryption != NULL)
		airEncryption->checkConstraints(pConstraintFails);

	if (callTimeOut != NULL)
		callTimeOut->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Connect_Ind::Clear()
{
  callParty.Clear();
  lineInfoAck.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(callPriority)
    delete callPriority;
  callPriority = NULL;
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
  if(connectedParty)
    delete connectedParty;
  connectedParty = NULL;
  if(airEncryption)
    delete airEncryption;
  airEncryption = NULL;
  if(callTimeOut)
    delete callTimeOut;
  callTimeOut = NULL;
}

CC_Connect_Ind::CC_Connect_Ind(const CC_Connect_Ind &that)
{
   Init();
   *this = that;
}
AsnType *CC_Connect_Ind::Clone() const
{
  return new CC_Connect_Ind(*this);
}

CC_Connect_Ind &CC_Connect_Ind::operator = (const CC_Connect_Ind &that)
{
  if (this != &that)
  {
    Clear();
    callParty = that.callParty;
    callID = that.callID;
    hookSignalling = that.hookSignalling;
    duplexMode = that.duplexMode;
    txGrant = that.txGrant;
    lineInfoAck = that.lineInfoAck;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.callPriority)
    {
      if (!callPriority)
        callPriority = new CallPriorityType;
      *callPriority = *that.callPriority;
    }
    else
    {
      delete callPriority;
      callPriority = NULL;
    }
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
    if (that.connectedParty)
    {
      if (!connectedParty)
        connectedParty = new AddressType;
      *connectedParty = *that.connectedParty;
    }
    else
    {
      delete connectedParty;
      connectedParty = NULL;
    }
    if (that.airEncryption)
    {
      if (!airEncryption)
        airEncryption = new AirEncryptionType;
      *airEncryption = *that.airEncryption;
    }
    else
    {
      delete airEncryption;
      airEncryption = NULL;
    }
    if (that.callTimeOut)
    {
      if (!callTimeOut)
        callTimeOut = new TetraCallTime;
      *callTimeOut = *that.callTimeOut;
    }
    else
    {
      delete callTimeOut;
      callTimeOut = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Connect_Ind::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (callTimeOut))
  {
    l = callTimeOut->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 12);
    totalLen += l;
  }

  if (NOT_NULL (airEncryption))
  {
    l = airEncryption->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 11);
    totalLen += l;
  }

  if (NOT_NULL (connectedParty))
  {
    l = connectedParty->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 10);
    totalLen += l;
  }

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 9);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 8);
    totalLen += l;
  }

  if (NOT_NULL (callPriority))
  {
    l = callPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

    l = lineInfoAck.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 5);
    totalLen += l;

    l = txGrant.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = duplexMode.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = hookSignalling.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Connect_Ind::BEncContent


void CC_Connect_Ind::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Connect_Ind::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    hookSignalling.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    duplexMode.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    txGrant.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    lineInfoAck.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callPriority = new CallPriorityType;
    callPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 9)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 10)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  connectedParty = new AddressType;
    connectedParty->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 11)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  airEncryption = new AirEncryptionType;
    airEncryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 12)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callTimeOut = new TetraCallTime;
    callTimeOut->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Connect_Ind::BDecContent

AsnLen CC_Connect_Ind::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 35);
  return l;
}

void CC_Connect_Ind::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Connect_Ind::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 35))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Connect_Ind::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callParty ";
	callParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "hookSignalling ";
	hookSignalling.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "duplexMode ";
	duplexMode.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "txGrant ";
	txGrant.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineInfoAck ";
	lineInfoAck.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (callPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callPriority ";
		callPriority->Print(os, indent);
	}

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	if (NOT_NULL (connectedParty))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "connectedParty ";
		connectedParty->Print(os, indent);
	}

	if (NOT_NULL (airEncryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "airEncryption ";
		airEncryption->Print(os, indent);
	}

	if (NOT_NULL (callTimeOut))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callTimeOut ";
		callTimeOut->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Connect_Ind::Print()

void CC_Connect_Ind::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callParty.PrintXML(os, "callParty");

    callID.PrintXML(os, "callID");

    hookSignalling.PrintXML(os, "hookSignalling");

    duplexMode.PrintXML(os, "duplexMode");

    txGrant.PrintXML(os, "txGrant");

    lineInfoAck.PrintXML(os, "lineInfoAck");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (callPriority))
  {
    callPriority->PrintXML(os, "callPriority");
  }

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (NOT_NULL (connectedParty))
  {
    connectedParty->PrintXML(os, "connectedParty");
  }

  if (NOT_NULL (airEncryption))
  {
    airEncryption->PrintXML(os, "airEncryption");
  }

  if (NOT_NULL (callTimeOut))
  {
    callTimeOut->PrintXML(os, "callTimeOut");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Connect_Ind::PrintXML


void CC_Connect_Ack::Init(void)
{
  txReqPermission = NULL;
  callPriority = NULL;
  ssNotification = NULL;
  callTimeOut = NULL;
}


int CC_Connect_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	txGrant.checkConstraints(pConstraintFails);

	lineInfoAck.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (callPriority != NULL)
		callPriority->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	if (callTimeOut != NULL)
		callTimeOut->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Connect_Ack::Clear()
{
  callPartySSI.Clear();
  lineInfoAck.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(callPriority)
    delete callPriority;
  callPriority = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
  if(callTimeOut)
    delete callTimeOut;
  callTimeOut = NULL;
}

CC_Connect_Ack::CC_Connect_Ack(const CC_Connect_Ack &that)
{
   Init();
   *this = that;
}
AsnType *CC_Connect_Ack::Clone() const
{
  return new CC_Connect_Ack(*this);
}

CC_Connect_Ack &CC_Connect_Ack::operator = (const CC_Connect_Ack &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    callID = that.callID;
    txGrant = that.txGrant;
    lineInfoAck = that.lineInfoAck;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.callPriority)
    {
      if (!callPriority)
        callPriority = new CallPriorityType;
      *callPriority = *that.callPriority;
    }
    else
    {
      delete callPriority;
      callPriority = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
    if (that.callTimeOut)
    {
      if (!callTimeOut)
        callTimeOut = new TetraCallTime;
      *callTimeOut = *that.callTimeOut;
    }
    else
    {
      delete callTimeOut;
      callTimeOut = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Connect_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (callTimeOut))
  {
    l = callTimeOut->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (callPriority))
  {
    l = callPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = lineInfoAck.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = txGrant.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Connect_Ack::BEncContent


void CC_Connect_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Connect_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    txGrant.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    lineInfoAck.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callPriority = new CallPriorityType;
    callPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callTimeOut = new TetraCallTime;
    callTimeOut->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Connect_Ack::BDecContent

AsnLen CC_Connect_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 36);
  return l;
}

void CC_Connect_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Connect_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 36))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Connect_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "txGrant ";
	txGrant.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineInfoAck ";
	lineInfoAck.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (callPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callPriority ";
		callPriority->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	if (NOT_NULL (callTimeOut))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callTimeOut ";
		callTimeOut->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Connect_Ack::Print()

void CC_Connect_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    callID.PrintXML(os, "callID");

    txGrant.PrintXML(os, "txGrant");

    lineInfoAck.PrintXML(os, "lineInfoAck");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (callPriority))
  {
    callPriority->PrintXML(os, "callPriority");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (NOT_NULL (callTimeOut))
  {
    callTimeOut->PrintXML(os, "callTimeOut");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Connect_Ack::PrintXML


void CC_TxDemand::Init(void)
{
  txPriority = NULL;
  encryption = NULL;
  lineInformation = NULL;
  noNfLoopBack = NULL;
}


int CC_TxDemand::checkConstraints(ConstraintFailList* pConstraintFails) const{
	demandPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	if (txPriority != NULL)
		txPriority->checkConstraints(pConstraintFails);

	if (encryption != NULL)
		encryption->checkConstraints(pConstraintFails);

	if (lineInformation != NULL)
		lineInformation->checkConstraints(pConstraintFails);

	if (noNfLoopBack != NULL)
		noNfLoopBack->checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxDemand::Clear()
{
  demandPartySSI.Clear();
  if(txPriority)
    delete txPriority;
  txPriority = NULL;
  if(encryption)
    delete encryption;
  encryption = NULL;
  if(lineInformation)
    delete lineInformation;
  lineInformation = NULL;
  if(noNfLoopBack)
    delete noNfLoopBack;
  noNfLoopBack = NULL;
}

CC_TxDemand::CC_TxDemand(const CC_TxDemand &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxDemand::Clone() const
{
  return new CC_TxDemand(*this);
}

CC_TxDemand &CC_TxDemand::operator = (const CC_TxDemand &that)
{
  if (this != &that)
  {
    Clear();
    demandPartySSI = that.demandPartySSI;
    callID = that.callID;
    if (that.txPriority)
    {
      if (!txPriority)
        txPriority = new TxPriorityType;
      *txPriority = *that.txPriority;
    }
    else
    {
      delete txPriority;
      txPriority = NULL;
    }
    if (that.encryption)
    {
      if (!encryption)
        encryption = new AsnBool;
      *encryption = *that.encryption;
    }
    else
    {
      delete encryption;
      encryption = NULL;
    }
    if (that.lineInformation)
    {
      if (!lineInformation)
        lineInformation = new LineInformationType;
      *lineInformation = *that.lineInformation;
    }
    else
    {
      delete lineInformation;
      lineInformation = NULL;
    }
    if (that.noNfLoopBack)
    {
      if (!noNfLoopBack)
        noNfLoopBack = new AsnBool;
      *noNfLoopBack = *that.noNfLoopBack;
    }
    else
    {
      delete noNfLoopBack;
      noNfLoopBack = NULL;
    }
  }

  return *this;
}

AsnLen
CC_TxDemand::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (noNfLoopBack))
  {
    l = noNfLoopBack->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (lineInformation))
  {
    l = lineInformation->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;
  }

  if (NOT_NULL (encryption))
  {
    l = encryption->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (txPriority))
  {
    l = txPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = demandPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxDemand::BEncContent


void CC_TxDemand::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxDemand::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    demandPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txPriority = new TxPriorityType;
    txPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  encryption = new AsnBool;
    encryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  lineInformation = new LineInformationType;
    lineInformation->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  noNfLoopBack = new AsnBool;
    noNfLoopBack->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxDemand::BDecContent

AsnLen CC_TxDemand::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 37);
  return l;
}

void CC_TxDemand::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxDemand::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 37))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxDemand::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "demandPartySSI ";
	demandPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txPriority ";
		txPriority->Print(os, indent);
	}

	if (NOT_NULL (encryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "encryption ";
		encryption->Print(os, indent);
	}

	if (NOT_NULL (lineInformation))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineInformation ";
		lineInformation->Print(os, indent);
	}

	if (NOT_NULL (noNfLoopBack))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "noNfLoopBack ";
		noNfLoopBack->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxDemand::Print()

void CC_TxDemand::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    demandPartySSI.PrintXML(os, "demandPartySSI");

    callID.PrintXML(os, "callID");

  if (NOT_NULL (txPriority))
  {
    txPriority->PrintXML(os, "txPriority");
  }

  if (NOT_NULL (encryption))
  {
    encryption->PrintXML(os, "encryption");
  }

  if (NOT_NULL (lineInformation))
  {
    lineInformation->PrintXML(os, "lineInformation");
  }

  if (NOT_NULL (noNfLoopBack))
  {
    noNfLoopBack->PrintXML(os, "noNfLoopBack");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxDemand::PrintXML


void CC_TxGrant::Init(void)
{
  txReqPermission = NULL;
  encryption = NULL;
  tpiRestriction = NULL;
  ssNotification = NULL;
}


int CC_TxGrant::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	transmittingParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	txGrant.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (encryption != NULL)
		encryption->checkConstraints(pConstraintFails);

	if (tpiRestriction != NULL)
		tpiRestriction->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxGrant::Clear()
{
  callPartySSI.Clear();
  transmittingParty.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(encryption)
    delete encryption;
  encryption = NULL;
  if(tpiRestriction)
    delete tpiRestriction;
  tpiRestriction = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
}

CC_TxGrant::CC_TxGrant(const CC_TxGrant &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxGrant::Clone() const
{
  return new CC_TxGrant(*this);
}

CC_TxGrant &CC_TxGrant::operator = (const CC_TxGrant &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    transmittingParty = that.transmittingParty;
    callID = that.callID;
    txGrant = that.txGrant;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.encryption)
    {
      if (!encryption)
        encryption = new AsnBool;
      *encryption = *that.encryption;
    }
    else
    {
      delete encryption;
      encryption = NULL;
    }
    if (that.tpiRestriction)
    {
      if (!tpiRestriction)
        tpiRestriction = new CliType;
      *tpiRestriction = *that.tpiRestriction;
    }
    else
    {
      delete tpiRestriction;
      tpiRestriction = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
  }

  return *this;
}

AsnLen
CC_TxGrant::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (tpiRestriction))
  {
    l = tpiRestriction->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (encryption))
  {
    l = encryption->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = txGrant.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = transmittingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxGrant::BEncContent


void CC_TxGrant::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxGrant::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    transmittingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    txGrant.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  encryption = new AsnBool;
    encryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  tpiRestriction = new CliType;
    tpiRestriction->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxGrant::BDecContent

AsnLen CC_TxGrant::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 38);
  return l;
}

void CC_TxGrant::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxGrant::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 38))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxGrant::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "transmittingParty ";
	transmittingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "txGrant ";
	txGrant.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (encryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "encryption ";
		encryption->Print(os, indent);
	}

	if (NOT_NULL (tpiRestriction))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "tpiRestriction ";
		tpiRestriction->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxGrant::Print()

void CC_TxGrant::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    transmittingParty.PrintXML(os, "transmittingParty");

    callID.PrintXML(os, "callID");

    txGrant.PrintXML(os, "txGrant");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (encryption))
  {
    encryption->PrintXML(os, "encryption");
  }

  if (NOT_NULL (tpiRestriction))
  {
    tpiRestriction->PrintXML(os, "tpiRestriction");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxGrant::PrintXML


void CC_TxCeased::Init(void)
{
  txReqPermission = NULL;
  ssNotification = NULL;
}


int CC_TxCeased::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxCeased::Clear()
{
  callParty.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
}

CC_TxCeased::CC_TxCeased(const CC_TxCeased &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxCeased::Clone() const
{
  return new CC_TxCeased(*this);
}

CC_TxCeased &CC_TxCeased::operator = (const CC_TxCeased &that)
{
  if (this != &that)
  {
    Clear();
    callParty = that.callParty;
    callID = that.callID;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
  }

  return *this;
}

AsnLen
CC_TxCeased::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxCeased::BEncContent


void CC_TxCeased::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxCeased::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxCeased::BDecContent

AsnLen CC_TxCeased::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 39);
  return l;
}

void CC_TxCeased::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxCeased::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 39))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxCeased::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callParty ";
	callParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxCeased::Print()

void CC_TxCeased::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callParty.PrintXML(os, "callParty");

    callID.PrintXML(os, "callID");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxCeased::PrintXML


void CC_TxInterrupt::Init(void)
{
  txReqPermission = NULL;
  encryption = NULL;
  tpiRestriction = NULL;
}


int CC_TxInterrupt::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	transmittingParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	txGrant.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (encryption != NULL)
		encryption->checkConstraints(pConstraintFails);

	if (tpiRestriction != NULL)
		tpiRestriction->checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxInterrupt::Clear()
{
  callPartySSI.Clear();
  transmittingParty.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(encryption)
    delete encryption;
  encryption = NULL;
  if(tpiRestriction)
    delete tpiRestriction;
  tpiRestriction = NULL;
}

CC_TxInterrupt::CC_TxInterrupt(const CC_TxInterrupt &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxInterrupt::Clone() const
{
  return new CC_TxInterrupt(*this);
}

CC_TxInterrupt &CC_TxInterrupt::operator = (const CC_TxInterrupt &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    transmittingParty = that.transmittingParty;
    callID = that.callID;
    txGrant = that.txGrant;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.encryption)
    {
      if (!encryption)
        encryption = new AsnBool;
      *encryption = *that.encryption;
    }
    else
    {
      delete encryption;
      encryption = NULL;
    }
    if (that.tpiRestriction)
    {
      if (!tpiRestriction)
        tpiRestriction = new CliType;
      *tpiRestriction = *that.tpiRestriction;
    }
    else
    {
      delete tpiRestriction;
      tpiRestriction = NULL;
    }
  }

  return *this;
}

AsnLen
CC_TxInterrupt::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (tpiRestriction))
  {
    l = tpiRestriction->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (encryption))
  {
    l = encryption->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = txGrant.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = transmittingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxInterrupt::BEncContent


void CC_TxInterrupt::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxInterrupt::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    transmittingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    txGrant.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  encryption = new AsnBool;
    encryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  tpiRestriction = new CliType;
    tpiRestriction->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxInterrupt::BDecContent

AsnLen CC_TxInterrupt::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 40);
  return l;
}

void CC_TxInterrupt::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxInterrupt::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 40))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxInterrupt::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "transmittingParty ";
	transmittingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "txGrant ";
	txGrant.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (encryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "encryption ";
		encryption->Print(os, indent);
	}

	if (NOT_NULL (tpiRestriction))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "tpiRestriction ";
		tpiRestriction->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxInterrupt::Print()

void CC_TxInterrupt::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    transmittingParty.PrintXML(os, "transmittingParty");

    callID.PrintXML(os, "callID");

    txGrant.PrintXML(os, "txGrant");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (encryption))
  {
    encryption->PrintXML(os, "encryption");
  }

  if (NOT_NULL (tpiRestriction))
  {
    tpiRestriction->PrintXML(os, "tpiRestriction");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxInterrupt::PrintXML


void CC_TxWait_Ind::Init(void)
{
  txReqPermission = NULL;
  ssNotification = NULL;
}


int CC_TxWait_Ind::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxWait_Ind::Clear()
{
  callPartySSI.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
}

CC_TxWait_Ind::CC_TxWait_Ind(const CC_TxWait_Ind &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxWait_Ind::Clone() const
{
  return new CC_TxWait_Ind(*this);
}

CC_TxWait_Ind &CC_TxWait_Ind::operator = (const CC_TxWait_Ind &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    callID = that.callID;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
  }

  return *this;
}

AsnLen
CC_TxWait_Ind::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxWait_Ind::BEncContent


void CC_TxWait_Ind::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxWait_Ind::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxWait_Ind::BDecContent

AsnLen CC_TxWait_Ind::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 45);
  return l;
}

void CC_TxWait_Ind::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxWait_Ind::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 45))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxWait_Ind::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxWait_Ind::Print()

void CC_TxWait_Ind::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    callID.PrintXML(os, "callID");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxWait_Ind::PrintXML


void CC_TxWait_Req::Init(void)
{
}


int CC_TxWait_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	otherParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxWait_Req::Clear()
{
  callPartySSI.Clear();
  otherParty.Clear();
}

CC_TxWait_Req::CC_TxWait_Req(const CC_TxWait_Req &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxWait_Req::Clone() const
{
  return new CC_TxWait_Req(*this);
}

CC_TxWait_Req &CC_TxWait_Req::operator = (const CC_TxWait_Req &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    otherParty = that.otherParty;
    callID = that.callID;
  }

  return *this;
}

AsnLen
CC_TxWait_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = otherParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxWait_Req::BEncContent


void CC_TxWait_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxWait_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    otherParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxWait_Req::BDecContent

AsnLen CC_TxWait_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 46);
  return l;
}

void CC_TxWait_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxWait_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 46))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxWait_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "otherParty ";
	otherParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxWait_Req::Print()

void CC_TxWait_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    otherParty.PrintXML(os, "otherParty");

    callID.PrintXML(os, "callID");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxWait_Req::PrintXML


void CC_TxWait_Ack::Init(void)
{
}


int CC_TxWait_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	otherParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxWait_Ack::Clear()
{
  callPartySSI.Clear();
  otherParty.Clear();
}

CC_TxWait_Ack::CC_TxWait_Ack(const CC_TxWait_Ack &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxWait_Ack::Clone() const
{
  return new CC_TxWait_Ack(*this);
}

CC_TxWait_Ack &CC_TxWait_Ack::operator = (const CC_TxWait_Ack &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    otherParty = that.otherParty;
    callID = that.callID;
    result = that.result;
  }

  return *this;
}

AsnLen
CC_TxWait_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = otherParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxWait_Ack::BEncContent


void CC_TxWait_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxWait_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    otherParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxWait_Ack::BDecContent

AsnLen CC_TxWait_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 47);
  return l;
}

void CC_TxWait_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxWait_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 47))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxWait_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "otherParty ";
	otherParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxWait_Ack::Print()

void CC_TxWait_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    otherParty.PrintXML(os, "otherParty");

    callID.PrintXML(os, "callID");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxWait_Ack::PrintXML


void CC_TxContinue_Ind::Init(void)
{
  txReqPermission = NULL;
  ssNotification = NULL;
}


int CC_TxContinue_Ind::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxContinue_Ind::Clear()
{
  callPartySSI.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
}

CC_TxContinue_Ind::CC_TxContinue_Ind(const CC_TxContinue_Ind &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxContinue_Ind::Clone() const
{
  return new CC_TxContinue_Ind(*this);
}

CC_TxContinue_Ind &CC_TxContinue_Ind::operator = (const CC_TxContinue_Ind &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    callID = that.callID;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
  }

  return *this;
}

AsnLen
CC_TxContinue_Ind::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxContinue_Ind::BEncContent


void CC_TxContinue_Ind::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxContinue_Ind::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxContinue_Ind::BDecContent

AsnLen CC_TxContinue_Ind::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 122);
  return l;
}

void CC_TxContinue_Ind::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxContinue_Ind::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 122))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxContinue_Ind::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxContinue_Ind::Print()

void CC_TxContinue_Ind::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    callID.PrintXML(os, "callID");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxContinue_Ind::PrintXML


void CC_TxContinue_Req::Init(void)
{
}


int CC_TxContinue_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	otherParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxContinue_Req::Clear()
{
  callPartySSI.Clear();
  otherParty.Clear();
}

CC_TxContinue_Req::CC_TxContinue_Req(const CC_TxContinue_Req &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxContinue_Req::Clone() const
{
  return new CC_TxContinue_Req(*this);
}

CC_TxContinue_Req &CC_TxContinue_Req::operator = (const CC_TxContinue_Req &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    otherParty = that.otherParty;
    callID = that.callID;
  }

  return *this;
}

AsnLen
CC_TxContinue_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = otherParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxContinue_Req::BEncContent


void CC_TxContinue_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxContinue_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    otherParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxContinue_Req::BDecContent

AsnLen CC_TxContinue_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 48);
  return l;
}

void CC_TxContinue_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxContinue_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 48))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxContinue_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "otherParty ";
	otherParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxContinue_Req::Print()

void CC_TxContinue_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    otherParty.PrintXML(os, "otherParty");

    callID.PrintXML(os, "callID");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxContinue_Req::PrintXML


void CC_TxContinue_Ack::Init(void)
{
}


int CC_TxContinue_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	otherParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void CC_TxContinue_Ack::Clear()
{
  callPartySSI.Clear();
  otherParty.Clear();
}

CC_TxContinue_Ack::CC_TxContinue_Ack(const CC_TxContinue_Ack &that)
{
   Init();
   *this = that;
}
AsnType *CC_TxContinue_Ack::Clone() const
{
  return new CC_TxContinue_Ack(*this);
}

CC_TxContinue_Ack &CC_TxContinue_Ack::operator = (const CC_TxContinue_Ack &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    otherParty = that.otherParty;
    callID = that.callID;
    result = that.result;
  }

  return *this;
}

AsnLen
CC_TxContinue_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = otherParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_TxContinue_Ack::BEncContent


void CC_TxContinue_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxContinue_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    otherParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_TxContinue_Ack::BDecContent

AsnLen CC_TxContinue_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 49);
  return l;
}

void CC_TxContinue_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_TxContinue_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 49))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_TxContinue_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "otherParty ";
	otherParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_TxContinue_Ack::Print()

void CC_TxContinue_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    otherParty.PrintXML(os, "otherParty");

    callID.PrintXML(os, "callID");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_TxContinue_Ack::PrintXML


void CC_CancelInclude::Init(void)
{
}


int CC_CancelInclude::checkConstraints(ConstraintFailList* pConstraintFails) const{
	includeParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	include2CallID.checkConstraints(pConstraintFails);

	return 0;
}


void CC_CancelInclude::Clear()
{
  includeParty.Clear();
  callingParty.Clear();
}

CC_CancelInclude::CC_CancelInclude(const CC_CancelInclude &that)
{
   Init();
   *this = that;
}
AsnType *CC_CancelInclude::Clone() const
{
  return new CC_CancelInclude(*this);
}

CC_CancelInclude &CC_CancelInclude::operator = (const CC_CancelInclude &that)
{
  if (this != &that)
  {
    Clear();
    includeParty = that.includeParty;
    callingParty = that.callingParty;
    include2CallID = that.include2CallID;
  }

  return *this;
}

AsnLen
CC_CancelInclude::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = include2CallID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = includeParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_CancelInclude::BEncContent


void CC_CancelInclude::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_CancelInclude::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    includeParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    include2CallID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_CancelInclude::BDecContent

AsnLen CC_CancelInclude::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 121);
  return l;
}

void CC_CancelInclude::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_CancelInclude::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 121))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_CancelInclude::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "includeParty ";
	includeParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "include2CallID ";
	include2CallID.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_CancelInclude::Print()

void CC_CancelInclude::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    includeParty.PrintXML(os, "includeParty");

    callingParty.PrintXML(os, "callingParty");

    include2CallID.PrintXML(os, "include2CallID");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_CancelInclude::PrintXML


void CC_Disconnect::Init(void)
{
  ssNotification = NULL;
  callTransfer = NULL;
  ssAbortCause = NULL;
  affectedParty = NULL;
  authorizationGranted = NULL;
}


int CC_Disconnect::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	disconnectCause.checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	if (callTransfer != NULL)
		callTransfer->checkConstraints(pConstraintFails);

	if (ssAbortCause != NULL)
		ssAbortCause->checkConstraints(pConstraintFails);

	if (affectedParty != NULL)
		affectedParty->checkConstraints(pConstraintFails);

	if (authorizationGranted != NULL)
		authorizationGranted->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Disconnect::Clear()
{
  callParty.Clear();
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
  if(callTransfer)
    delete callTransfer;
  callTransfer = NULL;
  if(ssAbortCause)
    delete ssAbortCause;
  ssAbortCause = NULL;
  if(affectedParty)
    delete affectedParty;
  affectedParty = NULL;
  if(authorizationGranted)
    delete authorizationGranted;
  authorizationGranted = NULL;
}

CC_Disconnect::CC_Disconnect(const CC_Disconnect &that)
{
   Init();
   *this = that;
}
AsnType *CC_Disconnect::Clone() const
{
  return new CC_Disconnect(*this);
}

CC_Disconnect &CC_Disconnect::operator = (const CC_Disconnect &that)
{
  if (this != &that)
  {
    Clear();
    callParty = that.callParty;
    callID = that.callID;
    disconnectCause = that.disconnectCause;
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
    if (that.callTransfer)
    {
      if (!callTransfer)
        callTransfer = new CallTransferType;
      *callTransfer = *that.callTransfer;
    }
    else
    {
      delete callTransfer;
      callTransfer = NULL;
    }
    if (that.ssAbortCause)
    {
      if (!ssAbortCause)
        ssAbortCause = new SS_AbortCauseType;
      *ssAbortCause = *that.ssAbortCause;
    }
    else
    {
      delete ssAbortCause;
      ssAbortCause = NULL;
    }
    if (that.affectedParty)
    {
      if (!affectedParty)
        affectedParty = new AddressType;
      *affectedParty = *that.affectedParty;
    }
    else
    {
      delete affectedParty;
      affectedParty = NULL;
    }
    if (that.authorizationGranted)
    {
      if (!authorizationGranted)
        authorizationGranted = new AsnBool;
      *authorizationGranted = *that.authorizationGranted;
    }
    else
    {
      delete authorizationGranted;
      authorizationGranted = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Disconnect::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (authorizationGranted))
  {
    l = authorizationGranted->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (affectedParty))
  {
    l = affectedParty->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 6);
    totalLen += l;
  }

  if (NOT_NULL (ssAbortCause))
  {
    l = ssAbortCause->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 5);
    totalLen += l;
  }

  if (NOT_NULL (callTransfer))
  {
    l = callTransfer->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;
  }

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = disconnectCause.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Disconnect::BEncContent


void CC_Disconnect::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Disconnect::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    disconnectCause.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callTransfer = new CallTransferType;
    callTransfer->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  ssAbortCause = new SS_AbortCauseType;
    ssAbortCause->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  affectedParty = new AddressType;
    affectedParty->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  authorizationGranted = new AsnBool;
    authorizationGranted->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Disconnect::BDecContent

AsnLen CC_Disconnect::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 41);
  return l;
}

void CC_Disconnect::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Disconnect::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 41))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Disconnect::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callParty ";
	callParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectCause ";
	disconnectCause.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	if (NOT_NULL (callTransfer))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callTransfer ";
		callTransfer->Print(os, indent);
	}

	if (NOT_NULL (ssAbortCause))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssAbortCause ";
		ssAbortCause->Print(os, indent);
	}

	if (NOT_NULL (affectedParty))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "affectedParty ";
		affectedParty->Print(os, indent);
	}

	if (NOT_NULL (authorizationGranted))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "authorizationGranted ";
		authorizationGranted->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Disconnect::Print()

void CC_Disconnect::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callParty.PrintXML(os, "callParty");

    callID.PrintXML(os, "callID");

    disconnectCause.PrintXML(os, "disconnectCause");

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (NOT_NULL (callTransfer))
  {
    callTransfer->PrintXML(os, "callTransfer");
  }

  if (NOT_NULL (ssAbortCause))
  {
    ssAbortCause->PrintXML(os, "ssAbortCause");
  }

  if (NOT_NULL (affectedParty))
  {
    affectedParty->PrintXML(os, "affectedParty");
  }

  if (NOT_NULL (authorizationGranted))
  {
    authorizationGranted->PrintXML(os, "authorizationGranted");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Disconnect::PrintXML


void CC_Disconnect_Ack::Init(void)
{
  callTransfer = NULL;
}


int CC_Disconnect_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	disconnectCause.checkConstraints(pConstraintFails);

	if (callTransfer != NULL)
		callTransfer->checkConstraints(pConstraintFails);

	return 0;
}


void CC_Disconnect_Ack::Clear()
{
  callParty.Clear();
  if(callTransfer)
    delete callTransfer;
  callTransfer = NULL;
}

CC_Disconnect_Ack::CC_Disconnect_Ack(const CC_Disconnect_Ack &that)
{
   Init();
   *this = that;
}
AsnType *CC_Disconnect_Ack::Clone() const
{
  return new CC_Disconnect_Ack(*this);
}

CC_Disconnect_Ack &CC_Disconnect_Ack::operator = (const CC_Disconnect_Ack &that)
{
  if (this != &that)
  {
    Clear();
    callParty = that.callParty;
    callID = that.callID;
    disconnectCause = that.disconnectCause;
    if (that.callTransfer)
    {
      if (!callTransfer)
        callTransfer = new CallTransferType;
      *callTransfer = *that.callTransfer;
    }
    else
    {
      delete callTransfer;
      callTransfer = NULL;
    }
  }

  return *this;
}

AsnLen
CC_Disconnect_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (callTransfer))
  {
    l = callTransfer->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;
  }

    l = disconnectCause.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = callParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_Disconnect_Ack::BEncContent


void CC_Disconnect_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_Disconnect_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    disconnectCause.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callTransfer = new CallTransferType;
    callTransfer->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_Disconnect_Ack::BDecContent

AsnLen CC_Disconnect_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 42);
  return l;
}

void CC_Disconnect_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_Disconnect_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 42))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_Disconnect_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callParty ";
	callParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectCause ";
	disconnectCause.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (callTransfer))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callTransfer ";
		callTransfer->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_Disconnect_Ack::Print()

void CC_Disconnect_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callParty.PrintXML(os, "callParty");

    callID.PrintXML(os, "callID");

    disconnectCause.PrintXML(os, "disconnectCause");

  if (NOT_NULL (callTransfer))
  {
    callTransfer->PrintXML(os, "callTransfer");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_Disconnect_Ack::PrintXML


void CC_DialupLine_Info::Init(void)
{
}


int CC_DialupLine_Info::checkConstraints(ConstraintFailList* pConstraintFails) const{
	dialupLineInfo.checkConstraints(pConstraintFails);

	dialupLineHandle.checkConstraints(pConstraintFails);

	dialupLineState.checkConstraints(pConstraintFails);

	return 0;
}


void CC_DialupLine_Info::Clear()
{
  dialupLineInfo.Clear();
}

CC_DialupLine_Info::CC_DialupLine_Info(const CC_DialupLine_Info &that)
{
   Init();
   *this = that;
}
AsnType *CC_DialupLine_Info::Clone() const
{
  return new CC_DialupLine_Info(*this);
}

CC_DialupLine_Info &CC_DialupLine_Info::operator = (const CC_DialupLine_Info &that)
{
  if (this != &that)
  {
    Clear();
    dialupLineInfo = that.dialupLineInfo;
    dialupLineHandle = that.dialupLineHandle;
    dialupLineState = that.dialupLineState;
  }

  return *this;
}

AsnLen
CC_DialupLine_Info::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = dialupLineState.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = dialupLineHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = dialupLineInfo.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // CC_DialupLine_Info::BEncContent


void CC_DialupLine_Info::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CC_DialupLine_Info::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dialupLineInfo.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dialupLineHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dialupLineState.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CC_DialupLine_Info::BDecContent

AsnLen CC_DialupLine_Info::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 43);
  return l;
}

void CC_DialupLine_Info::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CC_DialupLine_Info::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 43))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CC_DialupLine_Info::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "dialupLineInfo ";
	dialupLineInfo.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "dialupLineHandle ";
	dialupLineHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "dialupLineState ";
	dialupLineState.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CC_DialupLine_Info::Print()

void CC_DialupLine_Info::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    dialupLineInfo.PrintXML(os, "dialupLineInfo");

    dialupLineHandle.PrintXML(os, "dialupLineHandle");

    dialupLineState.PrintXML(os, "dialupLineState");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // CC_DialupLine_Info::PrintXML


void SS_GroupAttach::Init(void)
{
}


int SS_GroupAttach::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	groupSSI.checkConstraints(pConstraintFails);

	return 0;
}


void SS_GroupAttach::Clear()
{
  callPartySSI.Clear();
  groupSSI.Clear();
}

SS_GroupAttach::SS_GroupAttach(const SS_GroupAttach &that)
{
   Init();
   *this = that;
}
AsnType *SS_GroupAttach::Clone() const
{
  return new SS_GroupAttach(*this);
}

SS_GroupAttach &SS_GroupAttach::operator = (const SS_GroupAttach &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    groupSSI = that.groupSSI;
  }

  return *this;
}

AsnLen
SS_GroupAttach::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = groupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_GroupAttach::BEncContent


void SS_GroupAttach::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_GroupAttach::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    groupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_GroupAttach::BDecContent

AsnLen SS_GroupAttach::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 50);
  return l;
}

void SS_GroupAttach::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_GroupAttach::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 50))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_GroupAttach::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "groupSSI ";
	groupSSI.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_GroupAttach::Print()

void SS_GroupAttach::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    groupSSI.PrintXML(os, "groupSSI");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_GroupAttach::PrintXML


void SS_GroupAttach_Ack::Init(void)
{
}


int SS_GroupAttach_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	groupSSI.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void SS_GroupAttach_Ack::Clear()
{
  callPartySSI.Clear();
  groupSSI.Clear();
}

SS_GroupAttach_Ack::SS_GroupAttach_Ack(const SS_GroupAttach_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_GroupAttach_Ack::Clone() const
{
  return new SS_GroupAttach_Ack(*this);
}

SS_GroupAttach_Ack &SS_GroupAttach_Ack::operator = (const SS_GroupAttach_Ack &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    groupSSI = that.groupSSI;
    result = that.result;
  }

  return *this;
}

AsnLen
SS_GroupAttach_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = groupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_GroupAttach_Ack::BEncContent


void SS_GroupAttach_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_GroupAttach_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    groupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_GroupAttach_Ack::BDecContent

AsnLen SS_GroupAttach_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 51);
  return l;
}

void SS_GroupAttach_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_GroupAttach_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 51))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_GroupAttach_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "groupSSI ";
	groupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_GroupAttach_Ack::Print()

void SS_GroupAttach_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    groupSSI.PrintXML(os, "groupSSI");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_GroupAttach_Ack::PrintXML


void SS_GroupDetach::Init(void)
{
}


int SS_GroupDetach::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	groupSSI.checkConstraints(pConstraintFails);

	return 0;
}


void SS_GroupDetach::Clear()
{
  callPartySSI.Clear();
  groupSSI.Clear();
}

SS_GroupDetach::SS_GroupDetach(const SS_GroupDetach &that)
{
   Init();
   *this = that;
}
AsnType *SS_GroupDetach::Clone() const
{
  return new SS_GroupDetach(*this);
}

SS_GroupDetach &SS_GroupDetach::operator = (const SS_GroupDetach &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    groupSSI = that.groupSSI;
  }

  return *this;
}

AsnLen
SS_GroupDetach::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = groupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_GroupDetach::BEncContent


void SS_GroupDetach::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_GroupDetach::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    groupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_GroupDetach::BDecContent

AsnLen SS_GroupDetach::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 52);
  return l;
}

void SS_GroupDetach::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_GroupDetach::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 52))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_GroupDetach::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "groupSSI ";
	groupSSI.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_GroupDetach::Print()

void SS_GroupDetach::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    groupSSI.PrintXML(os, "groupSSI");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_GroupDetach::PrintXML


void SS_GroupDetach_Ack::Init(void)
{
}


int SS_GroupDetach_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	callPartySSI.checkConstraints(pConstraintFails);

	groupSSI.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	return 0;
}


void SS_GroupDetach_Ack::Clear()
{
  callPartySSI.Clear();
  groupSSI.Clear();
}

SS_GroupDetach_Ack::SS_GroupDetach_Ack(const SS_GroupDetach_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_GroupDetach_Ack::Clone() const
{
  return new SS_GroupDetach_Ack(*this);
}

SS_GroupDetach_Ack &SS_GroupDetach_Ack::operator = (const SS_GroupDetach_Ack &that)
{
  if (this != &that)
  {
    Clear();
    callPartySSI = that.callPartySSI;
    groupSSI = that.groupSSI;
    result = that.result;
  }

  return *this;
}

AsnLen
SS_GroupDetach_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = groupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_GroupDetach_Ack::BEncContent


void SS_GroupDetach_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_GroupDetach_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    groupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_GroupDetach_Ack::BDecContent

AsnLen SS_GroupDetach_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 53);
  return l;
}

void SS_GroupDetach_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_GroupDetach_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 53))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_GroupDetach_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "groupSSI ";
	groupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_GroupDetach_Ack::Print()

void SS_GroupDetach_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    callPartySSI.PrintXML(os, "callPartySSI");

    groupSSI.PrintXML(os, "groupSSI");

    result.PrintXML(os, "result");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_GroupDetach_Ack::PrintXML


const SizeConstraint*  
SS_DynGroupAdd::MnemonicGroupName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint mnemonicGroupName_SizeConstraintList[] = 
			{{ 1, 15, 1 }};

	sizeList = 1;
	return &mnemonicGroupName_SizeConstraintList[0];
}


void SS_DynGroupAdd::Init(void)
{
  groupAttachmentMode = NULL;
  mnemonicGroupName = NULL;
  classOfUsage = NULL;
}


int SS_DynGroupAdd::checkConstraints(ConstraintFailList* pConstraintFails) const{
	dynGroupSSI.checkConstraints(pConstraintFails);

	affectedSSI.checkConstraints(pConstraintFails);

	if (groupAttachmentMode != NULL)
		groupAttachmentMode->checkConstraints(pConstraintFails);

	if (mnemonicGroupName != NULL)
		mnemonicGroupName->checkConstraints(pConstraintFails);

	if (classOfUsage != NULL)
		classOfUsage->checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupAdd::Clear()
{
  dynGroupSSI.Clear();
  if(groupAttachmentMode)
    delete groupAttachmentMode;
  groupAttachmentMode = NULL;
  if(mnemonicGroupName)
    delete mnemonicGroupName;
  mnemonicGroupName = NULL;
  if(classOfUsage)
    delete classOfUsage;
  classOfUsage = NULL;
}

SS_DynGroupAdd::SS_DynGroupAdd(const SS_DynGroupAdd &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupAdd::Clone() const
{
  return new SS_DynGroupAdd(*this);
}

SS_DynGroupAdd &SS_DynGroupAdd::operator = (const SS_DynGroupAdd &that)
{
  if (this != &that)
  {
    Clear();
    dynGroupSSI = that.dynGroupSSI;
    affectedSSI = that.affectedSSI;
    if (that.groupAttachmentMode)
    {
      if (!groupAttachmentMode)
        groupAttachmentMode = new SS_DynGroupAddInt;
      *groupAttachmentMode = *that.groupAttachmentMode;
    }
    else
    {
      delete groupAttachmentMode;
      groupAttachmentMode = NULL;
    }
    if (that.mnemonicGroupName)
    {
      if (!mnemonicGroupName)
        mnemonicGroupName = new MnemonicGroupName;
      *mnemonicGroupName = *that.mnemonicGroupName;
    }
    else
    {
      delete mnemonicGroupName;
      mnemonicGroupName = NULL;
    }
    if (that.classOfUsage)
    {
      if (!classOfUsage)
        classOfUsage = new SS_DynGroupAddInt1;
      *classOfUsage = *that.classOfUsage;
    }
    else
    {
      delete classOfUsage;
      classOfUsage = NULL;
    }
  }

  return *this;
}

AsnLen
SS_DynGroupAdd::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (classOfUsage))
  {
    l = classOfUsage->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (mnemonicGroupName))
  {
    l = mnemonicGroupName->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (groupAttachmentMode))
  {
    l = groupAttachmentMode->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = affectedSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupAdd::BEncContent


void SS_DynGroupAdd::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupAdd::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    affectedSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  groupAttachmentMode = new SS_DynGroupAddInt;
    groupAttachmentMode->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  mnemonicGroupName = new MnemonicGroupName;
    mnemonicGroupName->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  classOfUsage = new SS_DynGroupAddInt1;
    classOfUsage->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupAdd::BDecContent

AsnLen SS_DynGroupAdd::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 54);
  return l;
}

void SS_DynGroupAdd::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupAdd::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 54))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupAdd::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "affectedSSI ";
	affectedSSI.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (groupAttachmentMode))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "groupAttachmentMode ";
		groupAttachmentMode->Print(os, indent);
	}

	if (NOT_NULL (mnemonicGroupName))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "mnemonicGroupName ";
		mnemonicGroupName->Print(os, indent);
	}

	if (NOT_NULL (classOfUsage))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "classOfUsage ";
		classOfUsage->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupAdd::Print()

void SS_DynGroupAdd::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    dynGroupSSI.PrintXML(os, "dynGroupSSI");

    affectedSSI.PrintXML(os, "affectedSSI");

  if (NOT_NULL (groupAttachmentMode))
  {
    groupAttachmentMode->PrintXML(os, "groupAttachmentMode");
  }

  if (NOT_NULL (mnemonicGroupName))
  {
    mnemonicGroupName->PrintXML(os, "mnemonicGroupName");
  }

  if (NOT_NULL (classOfUsage))
  {
    classOfUsage->PrintXML(os, "classOfUsage");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupAdd::PrintXML


void SS_DynGroupDel::Init(void)
{
}


int SS_DynGroupDel::checkConstraints(ConstraintFailList* pConstraintFails) const{
	dynGroupSSI.checkConstraints(pConstraintFails);

	affectedSSI.checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupDel::Clear()
{
  dynGroupSSI.Clear();
}

SS_DynGroupDel::SS_DynGroupDel(const SS_DynGroupDel &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupDel::Clone() const
{
  return new SS_DynGroupDel(*this);
}

SS_DynGroupDel &SS_DynGroupDel::operator = (const SS_DynGroupDel &that)
{
  if (this != &that)
  {
    Clear();
    dynGroupSSI = that.dynGroupSSI;
    affectedSSI = that.affectedSSI;
  }

  return *this;
}

AsnLen
SS_DynGroupDel::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = affectedSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupDel::BEncContent


void SS_DynGroupDel::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupDel::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    affectedSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupDel::BDecContent

AsnLen SS_DynGroupDel::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 55);
  return l;
}

void SS_DynGroupDel::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupDel::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 55))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupDel::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "affectedSSI ";
	affectedSSI.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupDel::Print()

void SS_DynGroupDel::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    dynGroupSSI.PrintXML(os, "dynGroupSSI");

    affectedSSI.PrintXML(os, "affectedSSI");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupDel::PrintXML


void SS_DynGroupAdd_Ack::Init(void)
{
  affectedSSI = NULL;
  resultOfAttachment = NULL;
}


int SS_DynGroupAdd_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	dynGroupSSI.checkConstraints(pConstraintFails);

	resultOfAssignment.checkConstraints(pConstraintFails);

	if (affectedSSI != NULL)
		affectedSSI->checkConstraints(pConstraintFails);

	if (resultOfAttachment != NULL)
		resultOfAttachment->checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupAdd_Ack::Clear()
{
  dynGroupSSI.Clear();
  if(affectedSSI)
    delete affectedSSI;
  affectedSSI = NULL;
  if(resultOfAttachment)
    delete resultOfAttachment;
  resultOfAttachment = NULL;
}

SS_DynGroupAdd_Ack::SS_DynGroupAdd_Ack(const SS_DynGroupAdd_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupAdd_Ack::Clone() const
{
  return new SS_DynGroupAdd_Ack(*this);
}

SS_DynGroupAdd_Ack &SS_DynGroupAdd_Ack::operator = (const SS_DynGroupAdd_Ack &that)
{
  if (this != &that)
  {
    Clear();
    dynGroupSSI = that.dynGroupSSI;
    resultOfAssignment = that.resultOfAssignment;
    if (that.affectedSSI)
    {
      if (!affectedSSI)
        affectedSSI = new TETRA_Address;
      *affectedSSI = *that.affectedSSI;
    }
    else
    {
      delete affectedSSI;
      affectedSSI = NULL;
    }
    if (that.resultOfAttachment)
    {
      if (!resultOfAttachment)
        resultOfAttachment = new SS_DynGroupAdd_AckInt1;
      *resultOfAttachment = *that.resultOfAttachment;
    }
    else
    {
      delete resultOfAttachment;
      resultOfAttachment = NULL;
    }
  }

  return *this;
}

AsnLen
SS_DynGroupAdd_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (resultOfAttachment))
  {
    l = resultOfAttachment->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (affectedSSI))
  {
    l = affectedSSI->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

    l = resultOfAssignment.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupAdd_Ack::BEncContent


void SS_DynGroupAdd_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupAdd_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resultOfAssignment.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  affectedSSI = new TETRA_Address;
    affectedSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  resultOfAttachment = new SS_DynGroupAdd_AckInt1;
    resultOfAttachment->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupAdd_Ack::BDecContent

AsnLen SS_DynGroupAdd_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 56);
  return l;
}

void SS_DynGroupAdd_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupAdd_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 56))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupAdd_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "resultOfAssignment ";
	resultOfAssignment.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (affectedSSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "affectedSSI ";
		affectedSSI->Print(os, indent);
	}

	if (NOT_NULL (resultOfAttachment))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "resultOfAttachment ";
		resultOfAttachment->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupAdd_Ack::Print()

void SS_DynGroupAdd_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    dynGroupSSI.PrintXML(os, "dynGroupSSI");

    resultOfAssignment.PrintXML(os, "resultOfAssignment");

  if (NOT_NULL (affectedSSI))
  {
    affectedSSI->PrintXML(os, "affectedSSI");
  }

  if (NOT_NULL (resultOfAttachment))
  {
    resultOfAttachment->PrintXML(os, "resultOfAttachment");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupAdd_Ack::PrintXML


void SS_DynGroupDel_Ack::Init(void)
{
  affectedSSI = NULL;
}


int SS_DynGroupDel_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	dynGroupSSI.checkConstraints(pConstraintFails);

	resultOfDeassignment.checkConstraints(pConstraintFails);

	if (affectedSSI != NULL)
		affectedSSI->checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupDel_Ack::Clear()
{
  dynGroupSSI.Clear();
  if(affectedSSI)
    delete affectedSSI;
  affectedSSI = NULL;
}

SS_DynGroupDel_Ack::SS_DynGroupDel_Ack(const SS_DynGroupDel_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupDel_Ack::Clone() const
{
  return new SS_DynGroupDel_Ack(*this);
}

SS_DynGroupDel_Ack &SS_DynGroupDel_Ack::operator = (const SS_DynGroupDel_Ack &that)
{
  if (this != &that)
  {
    Clear();
    dynGroupSSI = that.dynGroupSSI;
    resultOfDeassignment = that.resultOfDeassignment;
    if (that.affectedSSI)
    {
      if (!affectedSSI)
        affectedSSI = new TETRA_Address;
      *affectedSSI = *that.affectedSSI;
    }
    else
    {
      delete affectedSSI;
      affectedSSI = NULL;
    }
  }

  return *this;
}

AsnLen
SS_DynGroupDel_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (affectedSSI))
  {
    l = affectedSSI->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

    l = resultOfDeassignment.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupDel_Ack::BEncContent


void SS_DynGroupDel_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupDel_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resultOfDeassignment.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  affectedSSI = new TETRA_Address;
    affectedSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupDel_Ack::BDecContent

AsnLen SS_DynGroupDel_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 57);
  return l;
}

void SS_DynGroupDel_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupDel_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 57))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupDel_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "resultOfDeassignment ";
	resultOfDeassignment.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (affectedSSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "affectedSSI ";
		affectedSSI->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupDel_Ack::Print()

void SS_DynGroupDel_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    dynGroupSSI.PrintXML(os, "dynGroupSSI");

    resultOfDeassignment.PrintXML(os, "resultOfDeassignment");

  if (NOT_NULL (affectedSSI))
  {
    affectedSSI->PrintXML(os, "affectedSSI");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupDel_Ack::PrintXML


void SS_DynGroupInterrogate::Init(void)
{
}


int SS_DynGroupInterrogate::checkConstraints(ConstraintFailList* pConstraintFails) const{
	dynGroupSSI.checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupInterrogate::Clear()
{
  dynGroupSSI.Clear();
}

SS_DynGroupInterrogate::SS_DynGroupInterrogate(const SS_DynGroupInterrogate &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupInterrogate::Clone() const
{
  return new SS_DynGroupInterrogate(*this);
}

SS_DynGroupInterrogate &SS_DynGroupInterrogate::operator = (const SS_DynGroupInterrogate &that)
{
  if (this != &that)
  {
    Clear();
    dynGroupSSI = that.dynGroupSSI;
  }

  return *this;
}

AsnLen
SS_DynGroupInterrogate::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupInterrogate::BEncContent


void SS_DynGroupInterrogate::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupInterrogate::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupInterrogate::BDecContent

AsnLen SS_DynGroupInterrogate::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 58);
  return l;
}

void SS_DynGroupInterrogate::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupInterrogate::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 58))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupInterrogate::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupInterrogate::Print()

void SS_DynGroupInterrogate::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    dynGroupSSI.PrintXML(os, "dynGroupSSI");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupInterrogate::PrintXML


void SS_DynGroupInterrogate_Ack::Init(void)
{
}


int SS_DynGroupInterrogate_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	dynGroupSSI.checkConstraints(pConstraintFails);

	numberOfMembers.checkConstraints(pConstraintFails);

	memberState.checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupInterrogate_Ack::Clear()
{
  dynGroupSSI.Clear();
}

SS_DynGroupInterrogate_Ack::SS_DynGroupInterrogate_Ack(const SS_DynGroupInterrogate_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupInterrogate_Ack::Clone() const
{
  return new SS_DynGroupInterrogate_Ack(*this);
}

SS_DynGroupInterrogate_Ack &SS_DynGroupInterrogate_Ack::operator = (const SS_DynGroupInterrogate_Ack &that)
{
  if (this != &that)
  {
    Clear();
    dynGroupSSI = that.dynGroupSSI;
    numberOfMembers = that.numberOfMembers;
    memberState = that.memberState;
  }

  return *this;
}

AsnLen
SS_DynGroupInterrogate_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = memberState.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = numberOfMembers.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupInterrogate_Ack::BEncContent


void SS_DynGroupInterrogate_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupInterrogate_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    numberOfMembers.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    memberState.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupInterrogate_Ack::BDecContent

AsnLen SS_DynGroupInterrogate_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 59);
  return l;
}

void SS_DynGroupInterrogate_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupInterrogate_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 59))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupInterrogate_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "numberOfMembers ";
	numberOfMembers.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "memberState ";
	memberState.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupInterrogate_Ack::Print()

void SS_DynGroupInterrogate_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    dynGroupSSI.PrintXML(os, "dynGroupSSI");

    numberOfMembers.PrintXML(os, "numberOfMembers");

    memberState.PrintXML(os, "memberState");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupInterrogate_Ack::PrintXML


const SizeConstraint*  
SS_DynGroupAssign::MnemonicGroupName::SizeConstraints(int &sizeList)const
{
	static const SizeConstraint mnemonicGroupName_SizeConstraintList[] = 
			{{ 1, 15, 1 }};

	sizeList = 1;
	return &mnemonicGroupName_SizeConstraintList[0];
}


void SS_DynGroupAssign::Init(void)
{
  mnemonicGroupName = NULL;
  classOfUsage = NULL;
}


int SS_DynGroupAssign::checkConstraints(ConstraintFailList* pConstraintFails) const{
	applicationSSI.checkConstraints(pConstraintFails);

	dynGroupSSI.checkConstraints(pConstraintFails);

	groupAttachmentMode.checkConstraints(pConstraintFails);

	if (mnemonicGroupName != NULL)
		mnemonicGroupName->checkConstraints(pConstraintFails);

	if (classOfUsage != NULL)
		classOfUsage->checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupAssign::Clear()
{
  applicationSSI.Clear();
  dynGroupSSI.Clear();
  if(mnemonicGroupName)
    delete mnemonicGroupName;
  mnemonicGroupName = NULL;
  if(classOfUsage)
    delete classOfUsage;
  classOfUsage = NULL;
}

SS_DynGroupAssign::SS_DynGroupAssign(const SS_DynGroupAssign &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupAssign::Clone() const
{
  return new SS_DynGroupAssign(*this);
}

SS_DynGroupAssign &SS_DynGroupAssign::operator = (const SS_DynGroupAssign &that)
{
  if (this != &that)
  {
    Clear();
    applicationSSI = that.applicationSSI;
    dynGroupSSI = that.dynGroupSSI;
    groupAttachmentMode = that.groupAttachmentMode;
    if (that.mnemonicGroupName)
    {
      if (!mnemonicGroupName)
        mnemonicGroupName = new MnemonicGroupName;
      *mnemonicGroupName = *that.mnemonicGroupName;
    }
    else
    {
      delete mnemonicGroupName;
      mnemonicGroupName = NULL;
    }
    if (that.classOfUsage)
    {
      if (!classOfUsage)
        classOfUsage = new SS_DynGroupAssignInt1;
      *classOfUsage = *that.classOfUsage;
    }
    else
    {
      delete classOfUsage;
      classOfUsage = NULL;
    }
  }

  return *this;
}

AsnLen
SS_DynGroupAssign::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (classOfUsage))
  {
    l = classOfUsage->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (mnemonicGroupName))
  {
    l = mnemonicGroupName->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = groupAttachmentMode.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = applicationSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupAssign::BEncContent


void SS_DynGroupAssign::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupAssign::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    applicationSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    groupAttachmentMode.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  mnemonicGroupName = new MnemonicGroupName;
    mnemonicGroupName->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  classOfUsage = new SS_DynGroupAssignInt1;
    classOfUsage->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupAssign::BDecContent

AsnLen SS_DynGroupAssign::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 60);
  return l;
}

void SS_DynGroupAssign::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupAssign::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 60))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupAssign::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "applicationSSI ";
	applicationSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "groupAttachmentMode ";
	groupAttachmentMode.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (mnemonicGroupName))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "mnemonicGroupName ";
		mnemonicGroupName->Print(os, indent);
	}

	if (NOT_NULL (classOfUsage))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "classOfUsage ";
		classOfUsage->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupAssign::Print()

void SS_DynGroupAssign::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    applicationSSI.PrintXML(os, "applicationSSI");

    dynGroupSSI.PrintXML(os, "dynGroupSSI");

    groupAttachmentMode.PrintXML(os, "groupAttachmentMode");

  if (NOT_NULL (mnemonicGroupName))
  {
    mnemonicGroupName->PrintXML(os, "mnemonicGroupName");
  }

  if (NOT_NULL (classOfUsage))
  {
    classOfUsage->PrintXML(os, "classOfUsage");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupAssign::PrintXML


void SS_DynGroupAssign_Ack::Init(void)
{
}


int SS_DynGroupAssign_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	applicationSSI.checkConstraints(pConstraintFails);

	dynGroupSSI.checkConstraints(pConstraintFails);

	resultOfAssignment.checkConstraints(pConstraintFails);

	resultOfAttachment.checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupAssign_Ack::Clear()
{
  applicationSSI.Clear();
  dynGroupSSI.Clear();
}

SS_DynGroupAssign_Ack::SS_DynGroupAssign_Ack(const SS_DynGroupAssign_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupAssign_Ack::Clone() const
{
  return new SS_DynGroupAssign_Ack(*this);
}

SS_DynGroupAssign_Ack &SS_DynGroupAssign_Ack::operator = (const SS_DynGroupAssign_Ack &that)
{
  if (this != &that)
  {
    Clear();
    applicationSSI = that.applicationSSI;
    dynGroupSSI = that.dynGroupSSI;
    resultOfAssignment = that.resultOfAssignment;
    resultOfAttachment = that.resultOfAttachment;
  }

  return *this;
}

AsnLen
SS_DynGroupAssign_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = resultOfAttachment.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = resultOfAssignment.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = applicationSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupAssign_Ack::BEncContent


void SS_DynGroupAssign_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupAssign_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    applicationSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resultOfAssignment.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resultOfAttachment.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupAssign_Ack::BDecContent

AsnLen SS_DynGroupAssign_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 61);
  return l;
}

void SS_DynGroupAssign_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupAssign_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 61))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupAssign_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "applicationSSI ";
	applicationSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "resultOfAssignment ";
	resultOfAssignment.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "resultOfAttachment ";
	resultOfAttachment.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupAssign_Ack::Print()

void SS_DynGroupAssign_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    applicationSSI.PrintXML(os, "applicationSSI");

    dynGroupSSI.PrintXML(os, "dynGroupSSI");

    resultOfAssignment.PrintXML(os, "resultOfAssignment");

    resultOfAttachment.PrintXML(os, "resultOfAttachment");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupAssign_Ack::PrintXML


void SS_DynGroupDeassign::Init(void)
{
}


int SS_DynGroupDeassign::checkConstraints(ConstraintFailList* pConstraintFails) const{
	applicationSSI.checkConstraints(pConstraintFails);

	dynGroupSSI.checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupDeassign::Clear()
{
  applicationSSI.Clear();
  dynGroupSSI.Clear();
}

SS_DynGroupDeassign::SS_DynGroupDeassign(const SS_DynGroupDeassign &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupDeassign::Clone() const
{
  return new SS_DynGroupDeassign(*this);
}

SS_DynGroupDeassign &SS_DynGroupDeassign::operator = (const SS_DynGroupDeassign &that)
{
  if (this != &that)
  {
    Clear();
    applicationSSI = that.applicationSSI;
    dynGroupSSI = that.dynGroupSSI;
  }

  return *this;
}

AsnLen
SS_DynGroupDeassign::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = applicationSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupDeassign::BEncContent


void SS_DynGroupDeassign::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupDeassign::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    applicationSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupDeassign::BDecContent

AsnLen SS_DynGroupDeassign::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 62);
  return l;
}

void SS_DynGroupDeassign::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupDeassign::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 62))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupDeassign::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "applicationSSI ";
	applicationSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupDeassign::Print()

void SS_DynGroupDeassign::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    applicationSSI.PrintXML(os, "applicationSSI");

    dynGroupSSI.PrintXML(os, "dynGroupSSI");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupDeassign::PrintXML


void SS_DynGroupDeassign_Ack::Init(void)
{
}


int SS_DynGroupDeassign_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	applicationSSI.checkConstraints(pConstraintFails);

	dynGroupSSI.checkConstraints(pConstraintFails);

	resultOfDeassignment.checkConstraints(pConstraintFails);

	return 0;
}


void SS_DynGroupDeassign_Ack::Clear()
{
  applicationSSI.Clear();
  dynGroupSSI.Clear();
}

SS_DynGroupDeassign_Ack::SS_DynGroupDeassign_Ack(const SS_DynGroupDeassign_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_DynGroupDeassign_Ack::Clone() const
{
  return new SS_DynGroupDeassign_Ack(*this);
}

SS_DynGroupDeassign_Ack &SS_DynGroupDeassign_Ack::operator = (const SS_DynGroupDeassign_Ack &that)
{
  if (this != &that)
  {
    Clear();
    applicationSSI = that.applicationSSI;
    dynGroupSSI = that.dynGroupSSI;
    resultOfDeassignment = that.resultOfDeassignment;
  }

  return *this;
}

AsnLen
SS_DynGroupDeassign_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = resultOfDeassignment.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = dynGroupSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = applicationSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_DynGroupDeassign_Ack::BEncContent


void SS_DynGroupDeassign_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupDeassign_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    applicationSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    dynGroupSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resultOfDeassignment.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_DynGroupDeassign_Ack::BDecContent

AsnLen SS_DynGroupDeassign_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 63);
  return l;
}

void SS_DynGroupDeassign_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_DynGroupDeassign_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 63))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_DynGroupDeassign_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "applicationSSI ";
	applicationSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "dynGroupSSI ";
	dynGroupSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "resultOfDeassignment ";
	resultOfDeassignment.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_DynGroupDeassign_Ack::Print()

void SS_DynGroupDeassign_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    applicationSSI.PrintXML(os, "applicationSSI");

    dynGroupSSI.PrintXML(os, "dynGroupSSI");

    resultOfDeassignment.PrintXML(os, "resultOfDeassignment");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_DynGroupDeassign_Ack::PrintXML


void SS_CallForwardActivate::Init(void)
{
}


int SS_CallForwardActivate::checkConstraints(ConstraintFailList* pConstraintFails) const{
	forwardedPartySSI.checkConstraints(pConstraintFails);

	forwardToParty.checkConstraints(pConstraintFails);

	forwardingType.checkConstraints(pConstraintFails);

	forwardingService.checkConstraints(pConstraintFails);

	return 0;
}


void SS_CallForwardActivate::Clear()
{
  forwardedPartySSI.Clear();
  forwardToParty.Clear();
}

SS_CallForwardActivate::SS_CallForwardActivate(const SS_CallForwardActivate &that)
{
   Init();
   *this = that;
}
AsnType *SS_CallForwardActivate::Clone() const
{
  return new SS_CallForwardActivate(*this);
}

SS_CallForwardActivate &SS_CallForwardActivate::operator = (const SS_CallForwardActivate &that)
{
  if (this != &that)
  {
    Clear();
    forwardedPartySSI = that.forwardedPartySSI;
    forwardToParty = that.forwardToParty;
    forwardingType = that.forwardingType;
    forwardingService = that.forwardingService;
  }

  return *this;
}

AsnLen
SS_CallForwardActivate::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = forwardingService.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = forwardingType.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = forwardToParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = forwardedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_CallForwardActivate::BEncContent


void SS_CallForwardActivate::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardActivate::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardedPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    forwardToParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingType.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingService.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_CallForwardActivate::BDecContent

AsnLen SS_CallForwardActivate::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 64);
  return l;
}

void SS_CallForwardActivate::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardActivate::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 64))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_CallForwardActivate::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "forwardedPartySSI ";
	forwardedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardToParty ";
	forwardToParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingType ";
	forwardingType.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingService ";
	forwardingService.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_CallForwardActivate::Print()

void SS_CallForwardActivate::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    forwardedPartySSI.PrintXML(os, "forwardedPartySSI");

    forwardToParty.PrintXML(os, "forwardToParty");

    forwardingType.PrintXML(os, "forwardingType");

    forwardingService.PrintXML(os, "forwardingService");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_CallForwardActivate::PrintXML


void SS_CallForwardActivate_Ack::Init(void)
{
}


int SS_CallForwardActivate_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	forwardedPartySSI.checkConstraints(pConstraintFails);

	forwardToParty.checkConstraints(pConstraintFails);

	forwardingType.checkConstraints(pConstraintFails);

	forwardingService.checkConstraints(pConstraintFails);

	forwardingResult.checkConstraints(pConstraintFails);

	return 0;
}


void SS_CallForwardActivate_Ack::Clear()
{
  forwardedPartySSI.Clear();
  forwardToParty.Clear();
}

SS_CallForwardActivate_Ack::SS_CallForwardActivate_Ack(const SS_CallForwardActivate_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_CallForwardActivate_Ack::Clone() const
{
  return new SS_CallForwardActivate_Ack(*this);
}

SS_CallForwardActivate_Ack &SS_CallForwardActivate_Ack::operator = (const SS_CallForwardActivate_Ack &that)
{
  if (this != &that)
  {
    Clear();
    forwardedPartySSI = that.forwardedPartySSI;
    forwardToParty = that.forwardToParty;
    forwardingType = that.forwardingType;
    forwardingService = that.forwardingService;
    forwardingResult = that.forwardingResult;
  }

  return *this;
}

AsnLen
SS_CallForwardActivate_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = forwardingResult.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = forwardingService.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = forwardingType.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = forwardToParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = forwardedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_CallForwardActivate_Ack::BEncContent


void SS_CallForwardActivate_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardActivate_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardedPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    forwardToParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingType.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingService.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingResult.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_CallForwardActivate_Ack::BDecContent

AsnLen SS_CallForwardActivate_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 65);
  return l;
}

void SS_CallForwardActivate_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardActivate_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 65))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_CallForwardActivate_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "forwardedPartySSI ";
	forwardedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardToParty ";
	forwardToParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingType ";
	forwardingType.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingService ";
	forwardingService.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingResult ";
	forwardingResult.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_CallForwardActivate_Ack::Print()

void SS_CallForwardActivate_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    forwardedPartySSI.PrintXML(os, "forwardedPartySSI");

    forwardToParty.PrintXML(os, "forwardToParty");

    forwardingType.PrintXML(os, "forwardingType");

    forwardingService.PrintXML(os, "forwardingService");

    forwardingResult.PrintXML(os, "forwardingResult");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_CallForwardActivate_Ack::PrintXML


void SS_CallForwardDeactivate::Init(void)
{
}


int SS_CallForwardDeactivate::checkConstraints(ConstraintFailList* pConstraintFails) const{
	forwardedPartySSI.checkConstraints(pConstraintFails);

	forwardingType.checkConstraints(pConstraintFails);

	return 0;
}


void SS_CallForwardDeactivate::Clear()
{
  forwardedPartySSI.Clear();
}

SS_CallForwardDeactivate::SS_CallForwardDeactivate(const SS_CallForwardDeactivate &that)
{
   Init();
   *this = that;
}
AsnType *SS_CallForwardDeactivate::Clone() const
{
  return new SS_CallForwardDeactivate(*this);
}

SS_CallForwardDeactivate &SS_CallForwardDeactivate::operator = (const SS_CallForwardDeactivate &that)
{
  if (this != &that)
  {
    Clear();
    forwardedPartySSI = that.forwardedPartySSI;
    forwardingType = that.forwardingType;
  }

  return *this;
}

AsnLen
SS_CallForwardDeactivate::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = forwardingType.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = forwardedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_CallForwardDeactivate::BEncContent


void SS_CallForwardDeactivate::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardDeactivate::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardedPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingType.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_CallForwardDeactivate::BDecContent

AsnLen SS_CallForwardDeactivate::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 66);
  return l;
}

void SS_CallForwardDeactivate::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardDeactivate::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 66))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_CallForwardDeactivate::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "forwardedPartySSI ";
	forwardedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingType ";
	forwardingType.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_CallForwardDeactivate::Print()

void SS_CallForwardDeactivate::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    forwardedPartySSI.PrintXML(os, "forwardedPartySSI");

    forwardingType.PrintXML(os, "forwardingType");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_CallForwardDeactivate::PrintXML


void SS_CallForwardDeactivate_Ack::Init(void)
{
}


int SS_CallForwardDeactivate_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	forwardedPartySSI.checkConstraints(pConstraintFails);

	forwardingType.checkConstraints(pConstraintFails);

	forwardingResult.checkConstraints(pConstraintFails);

	return 0;
}


void SS_CallForwardDeactivate_Ack::Clear()
{
  forwardedPartySSI.Clear();
}

SS_CallForwardDeactivate_Ack::SS_CallForwardDeactivate_Ack(const SS_CallForwardDeactivate_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_CallForwardDeactivate_Ack::Clone() const
{
  return new SS_CallForwardDeactivate_Ack(*this);
}

SS_CallForwardDeactivate_Ack &SS_CallForwardDeactivate_Ack::operator = (const SS_CallForwardDeactivate_Ack &that)
{
  if (this != &that)
  {
    Clear();
    forwardedPartySSI = that.forwardedPartySSI;
    forwardingType = that.forwardingType;
    forwardingResult = that.forwardingResult;
  }

  return *this;
}

AsnLen
SS_CallForwardDeactivate_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = forwardingResult.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = forwardingType.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = forwardedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_CallForwardDeactivate_Ack::BEncContent


void SS_CallForwardDeactivate_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardDeactivate_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardedPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingType.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    forwardingResult.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_CallForwardDeactivate_Ack::BDecContent

AsnLen SS_CallForwardDeactivate_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 67);
  return l;
}

void SS_CallForwardDeactivate_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardDeactivate_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 67))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_CallForwardDeactivate_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "forwardedPartySSI ";
	forwardedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingType ";
	forwardingType.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "forwardingResult ";
	forwardingResult.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_CallForwardDeactivate_Ack::Print()

void SS_CallForwardDeactivate_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    forwardedPartySSI.PrintXML(os, "forwardedPartySSI");

    forwardingType.PrintXML(os, "forwardingType");

    forwardingResult.PrintXML(os, "forwardingResult");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_CallForwardDeactivate_Ack::PrintXML


void SS_CallForwardInterrogate_Ack::Init(void)
{
  numberOfEntries = NULL;
}


int SS_CallForwardInterrogate_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	fragmentationInfo.checkConstraints(pConstraintFails);

	callForwardingEntries.checkConstraints(pConstraintFails);

	if (numberOfEntries != NULL)
		numberOfEntries->checkConstraints(pConstraintFails);

	return 0;
}


void SS_CallForwardInterrogate_Ack::Clear()
{
  fragmentationInfo.Clear();
  if(numberOfEntries)
    delete numberOfEntries;
  numberOfEntries = NULL;
}

SS_CallForwardInterrogate_Ack::SS_CallForwardInterrogate_Ack(const SS_CallForwardInterrogate_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_CallForwardInterrogate_Ack::Clone() const
{
  return new SS_CallForwardInterrogate_Ack(*this);
}

SS_CallForwardInterrogate_Ack &SS_CallForwardInterrogate_Ack::operator = (const SS_CallForwardInterrogate_Ack &that)
{
  if (this != &that)
  {
    Clear();
    fragmentationInfo = that.fragmentationInfo;
    callForwardingEntries = that.callForwardingEntries;
    if (that.numberOfEntries)
    {
      if (!numberOfEntries)
        numberOfEntries = new AsnInt;
      *numberOfEntries = *that.numberOfEntries;
    }
    else
    {
      delete numberOfEntries;
      numberOfEntries = NULL;
    }
  }

  return *this;
}

AsnLen
SS_CallForwardInterrogate_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (numberOfEntries))
  {
    l = numberOfEntries->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = callForwardingEntries.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = fragmentationInfo.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_CallForwardInterrogate_Ack::BEncContent


void SS_CallForwardInterrogate_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardInterrogate_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    fragmentationInfo.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callForwardingEntries.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  numberOfEntries = new AsnInt;
    numberOfEntries->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_CallForwardInterrogate_Ack::BDecContent

AsnLen SS_CallForwardInterrogate_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag3 (_b, APPL, CONS, 131);
  return l;
}

void SS_CallForwardInterrogate_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_CallForwardInterrogate_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 131))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_CallForwardInterrogate_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "fragmentationInfo ";
	fragmentationInfo.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callForwardingEntries ";
	callForwardingEntries.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (numberOfEntries))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "numberOfEntries ";
		numberOfEntries->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_CallForwardInterrogate_Ack::Print()

void SS_CallForwardInterrogate_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    fragmentationInfo.PrintXML(os, "fragmentationInfo");

    callForwardingEntries.PrintXML(os, "callForwardingEntries");

  if (NOT_NULL (numberOfEntries))
  {
    numberOfEntries->PrintXML(os, "numberOfEntries");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_CallForwardInterrogate_Ack::PrintXML


void SS_ObjectIdentityAssign::Init(void)
{
  useOociAsCLI = NULL;
}


int SS_ObjectIdentityAssign::checkConstraints(ConstraintFailList* pConstraintFails) const{
	assignedOOCI.checkConstraints(pConstraintFails);

	affectedPartySSI.checkConstraints(pConstraintFails);

	if (useOociAsCLI != NULL)
		useOociAsCLI->checkConstraints(pConstraintFails);

	return 0;
}


void SS_ObjectIdentityAssign::Clear()
{
  assignedOOCI.Clear();
  affectedPartySSI.Clear();
  if(useOociAsCLI)
    delete useOociAsCLI;
  useOociAsCLI = NULL;
}

SS_ObjectIdentityAssign::SS_ObjectIdentityAssign(const SS_ObjectIdentityAssign &that)
{
   Init();
   *this = that;
}
AsnType *SS_ObjectIdentityAssign::Clone() const
{
  return new SS_ObjectIdentityAssign(*this);
}

SS_ObjectIdentityAssign &SS_ObjectIdentityAssign::operator = (const SS_ObjectIdentityAssign &that)
{
  if (this != &that)
  {
    Clear();
    assignedOOCI = that.assignedOOCI;
    affectedPartySSI = that.affectedPartySSI;
    if (that.useOociAsCLI)
    {
      if (!useOociAsCLI)
        useOociAsCLI = new UseOociAsCliType;
      *useOociAsCLI = *that.useOociAsCLI;
    }
    else
    {
      delete useOociAsCLI;
      useOociAsCLI = NULL;
    }
  }

  return *this;
}

AsnLen
SS_ObjectIdentityAssign::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (useOociAsCLI))
  {
    l = useOociAsCLI->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = affectedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = assignedOOCI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_ObjectIdentityAssign::BEncContent


void SS_ObjectIdentityAssign::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityAssign::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    assignedOOCI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    affectedPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  useOociAsCLI = new UseOociAsCliType;
    useOociAsCLI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_ObjectIdentityAssign::BDecContent

AsnLen SS_ObjectIdentityAssign::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 110);
  return l;
}

void SS_ObjectIdentityAssign::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityAssign::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 110))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_ObjectIdentityAssign::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "assignedOOCI ";
	assignedOOCI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "affectedPartySSI ";
	affectedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (useOociAsCLI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "useOociAsCLI ";
		useOociAsCLI->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_ObjectIdentityAssign::Print()

void SS_ObjectIdentityAssign::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    assignedOOCI.PrintXML(os, "assignedOOCI");

    affectedPartySSI.PrintXML(os, "affectedPartySSI");

  if (NOT_NULL (useOociAsCLI))
  {
    useOociAsCLI->PrintXML(os, "useOociAsCLI");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_ObjectIdentityAssign::PrintXML


void SS_ObjectIdentityAssign_Ack::Init(void)
{
}


int SS_ObjectIdentityAssign_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	assignedOOCI.checkConstraints(pConstraintFails);

	affectedPartySSI.checkConstraints(pConstraintFails);

	useOociAsCLI.checkConstraints(pConstraintFails);

	assingmentResult.checkConstraints(pConstraintFails);

	return 0;
}


void SS_ObjectIdentityAssign_Ack::Clear()
{
  assignedOOCI.Clear();
  affectedPartySSI.Clear();
}

SS_ObjectIdentityAssign_Ack::SS_ObjectIdentityAssign_Ack(const SS_ObjectIdentityAssign_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_ObjectIdentityAssign_Ack::Clone() const
{
  return new SS_ObjectIdentityAssign_Ack(*this);
}

SS_ObjectIdentityAssign_Ack &SS_ObjectIdentityAssign_Ack::operator = (const SS_ObjectIdentityAssign_Ack &that)
{
  if (this != &that)
  {
    Clear();
    assignedOOCI = that.assignedOOCI;
    affectedPartySSI = that.affectedPartySSI;
    useOociAsCLI = that.useOociAsCLI;
    assingmentResult = that.assingmentResult;
  }

  return *this;
}

AsnLen
SS_ObjectIdentityAssign_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = assingmentResult.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = useOociAsCLI.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = affectedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = assignedOOCI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_ObjectIdentityAssign_Ack::BEncContent


void SS_ObjectIdentityAssign_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityAssign_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    assignedOOCI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    affectedPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    useOociAsCLI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    assingmentResult.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_ObjectIdentityAssign_Ack::BDecContent

AsnLen SS_ObjectIdentityAssign_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 111);
  return l;
}

void SS_ObjectIdentityAssign_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityAssign_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 111))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_ObjectIdentityAssign_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "assignedOOCI ";
	assignedOOCI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "affectedPartySSI ";
	affectedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "useOociAsCLI ";
	useOociAsCLI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "assingmentResult ";
	assingmentResult.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_ObjectIdentityAssign_Ack::Print()

void SS_ObjectIdentityAssign_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    assignedOOCI.PrintXML(os, "assignedOOCI");

    affectedPartySSI.PrintXML(os, "affectedPartySSI");

    useOociAsCLI.PrintXML(os, "useOociAsCLI");

    assingmentResult.PrintXML(os, "assingmentResult");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_ObjectIdentityAssign_Ack::PrintXML


void SS_ObjectIdentityDeassign::Init(void)
{
  typeOfDeassignment = NULL;
}


int SS_ObjectIdentityDeassign::checkConstraints(ConstraintFailList* pConstraintFails) const{
	assignedOOCI.checkConstraints(pConstraintFails);

	if (typeOfDeassignment != NULL)
		typeOfDeassignment->checkConstraints(pConstraintFails);

	return 0;
}


void SS_ObjectIdentityDeassign::Clear()
{
  assignedOOCI.Clear();
  if(typeOfDeassignment)
    delete typeOfDeassignment;
  typeOfDeassignment = NULL;
}

SS_ObjectIdentityDeassign::SS_ObjectIdentityDeassign(const SS_ObjectIdentityDeassign &that)
{
   Init();
   *this = that;
}
AsnType *SS_ObjectIdentityDeassign::Clone() const
{
  return new SS_ObjectIdentityDeassign(*this);
}

SS_ObjectIdentityDeassign &SS_ObjectIdentityDeassign::operator = (const SS_ObjectIdentityDeassign &that)
{
  if (this != &that)
  {
    Clear();
    assignedOOCI = that.assignedOOCI;
    if (that.typeOfDeassignment)
    {
      if (!typeOfDeassignment)
        typeOfDeassignment = new SS_ObjectIdentityDeassignInt;
      *typeOfDeassignment = *that.typeOfDeassignment;
    }
    else
    {
      delete typeOfDeassignment;
      typeOfDeassignment = NULL;
    }
  }

  return *this;
}

AsnLen
SS_ObjectIdentityDeassign::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (typeOfDeassignment))
  {
    l = typeOfDeassignment->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;
  }

    l = assignedOOCI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_ObjectIdentityDeassign::BEncContent


void SS_ObjectIdentityDeassign::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityDeassign::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    assignedOOCI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  typeOfDeassignment = new SS_ObjectIdentityDeassignInt;
    typeOfDeassignment->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_ObjectIdentityDeassign::BDecContent

AsnLen SS_ObjectIdentityDeassign::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 112);
  return l;
}

void SS_ObjectIdentityDeassign::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityDeassign::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 112))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_ObjectIdentityDeassign::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "assignedOOCI ";
	assignedOOCI.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (typeOfDeassignment))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "typeOfDeassignment ";
		typeOfDeassignment->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_ObjectIdentityDeassign::Print()

void SS_ObjectIdentityDeassign::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    assignedOOCI.PrintXML(os, "assignedOOCI");

  if (NOT_NULL (typeOfDeassignment))
  {
    typeOfDeassignment->PrintXML(os, "typeOfDeassignment");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_ObjectIdentityDeassign::PrintXML


void SS_ObjectIdentityDeassign_Ack::Init(void)
{
}


int SS_ObjectIdentityDeassign_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	assignedOOCI.checkConstraints(pConstraintFails);

	deassingmentResult.checkConstraints(pConstraintFails);

	return 0;
}


void SS_ObjectIdentityDeassign_Ack::Clear()
{
  assignedOOCI.Clear();
}

SS_ObjectIdentityDeassign_Ack::SS_ObjectIdentityDeassign_Ack(const SS_ObjectIdentityDeassign_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_ObjectIdentityDeassign_Ack::Clone() const
{
  return new SS_ObjectIdentityDeassign_Ack(*this);
}

SS_ObjectIdentityDeassign_Ack &SS_ObjectIdentityDeassign_Ack::operator = (const SS_ObjectIdentityDeassign_Ack &that)
{
  if (this != &that)
  {
    Clear();
    assignedOOCI = that.assignedOOCI;
    deassingmentResult = that.deassingmentResult;
  }

  return *this;
}

AsnLen
SS_ObjectIdentityDeassign_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = deassingmentResult.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = assignedOOCI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // SS_ObjectIdentityDeassign_Ack::BEncContent


void SS_ObjectIdentityDeassign_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityDeassign_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    assignedOOCI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    deassingmentResult.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_ObjectIdentityDeassign_Ack::BDecContent

AsnLen SS_ObjectIdentityDeassign_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 113);
  return l;
}

void SS_ObjectIdentityDeassign_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityDeassign_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 113))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_ObjectIdentityDeassign_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "assignedOOCI ";
	assignedOOCI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "deassingmentResult ";
	deassingmentResult.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_ObjectIdentityDeassign_Ack::Print()

void SS_ObjectIdentityDeassign_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    assignedOOCI.PrintXML(os, "assignedOOCI");

    deassingmentResult.PrintXML(os, "deassingmentResult");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_ObjectIdentityDeassign_Ack::PrintXML


void SS_ObjectIdentityInterrogate_Ack::Init(void)
{
  numberOfEntries = NULL;
}


int SS_ObjectIdentityInterrogate_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	gatewaySSI.checkConstraints(pConstraintFails);

	fragmentationInfo.checkConstraints(pConstraintFails);

	oociEntries.checkConstraints(pConstraintFails);

	if (numberOfEntries != NULL)
		numberOfEntries->checkConstraints(pConstraintFails);

	return 0;
}


void SS_ObjectIdentityInterrogate_Ack::Clear()
{
  fragmentationInfo.Clear();
  if(numberOfEntries)
    delete numberOfEntries;
  numberOfEntries = NULL;
}

SS_ObjectIdentityInterrogate_Ack::SS_ObjectIdentityInterrogate_Ack(const SS_ObjectIdentityInterrogate_Ack &that)
{
   Init();
   *this = that;
}
AsnType *SS_ObjectIdentityInterrogate_Ack::Clone() const
{
  return new SS_ObjectIdentityInterrogate_Ack(*this);
}

SS_ObjectIdentityInterrogate_Ack &SS_ObjectIdentityInterrogate_Ack::operator = (const SS_ObjectIdentityInterrogate_Ack &that)
{
  if (this != &that)
  {
    Clear();
    gatewaySSI = that.gatewaySSI;
    fragmentationInfo = that.fragmentationInfo;
    oociEntries = that.oociEntries;
    if (that.numberOfEntries)
    {
      if (!numberOfEntries)
        numberOfEntries = new AsnInt;
      *numberOfEntries = *that.numberOfEntries;
    }
    else
    {
      delete numberOfEntries;
      numberOfEntries = NULL;
    }
  }

  return *this;
}

AsnLen
SS_ObjectIdentityInterrogate_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (numberOfEntries))
  {
    l = numberOfEntries->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = oociEntries.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = fragmentationInfo.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = gatewaySSI.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // SS_ObjectIdentityInterrogate_Ack::BEncContent


void SS_ObjectIdentityInterrogate_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityInterrogate_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    gatewaySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    fragmentationInfo.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    oociEntries.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  numberOfEntries = new AsnInt;
    numberOfEntries->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SS_ObjectIdentityInterrogate_Ack::BDecContent

AsnLen SS_ObjectIdentityInterrogate_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 117);
  return l;
}

void SS_ObjectIdentityInterrogate_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SS_ObjectIdentityInterrogate_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 117))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SS_ObjectIdentityInterrogate_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "gatewaySSI ";
	gatewaySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "fragmentationInfo ";
	fragmentationInfo.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "oociEntries ";
	oociEntries.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (numberOfEntries))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "numberOfEntries ";
		numberOfEntries->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SS_ObjectIdentityInterrogate_Ack::Print()

void SS_ObjectIdentityInterrogate_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    gatewaySSI.PrintXML(os, "gatewaySSI");

    fragmentationInfo.PrintXML(os, "fragmentationInfo");

    oociEntries.PrintXML(os, "oociEntries");

  if (NOT_NULL (numberOfEntries))
  {
    numberOfEntries->PrintXML(os, "numberOfEntries");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // SS_ObjectIdentityInterrogate_Ack::PrintXML


void MON_Monitoring_Req::Init(void)
{
  monEndSSI = NULL;
  monHandle = NULL;
  monStartTime = NULL;
  monEndTime = NULL;
  monPersistentData = NULL;
}


int MON_Monitoring_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monServices.checkConstraints(pConstraintFails);

	monBeginSSI.checkConstraints(pConstraintFails);

	if (monEndSSI != NULL)
		monEndSSI->checkConstraints(pConstraintFails);

	if (monHandle != NULL)
		monHandle->checkConstraints(pConstraintFails);

	if (monStartTime != NULL)
		monStartTime->checkConstraints(pConstraintFails);

	if (monEndTime != NULL)
		monEndTime->checkConstraints(pConstraintFails);

	if (monPersistentData != NULL)
		monPersistentData->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Monitoring_Req::Clear()
{
  monBeginSSI.Clear();
  if(monEndSSI)
    delete monEndSSI;
  monEndSSI = NULL;
  if(monHandle)
    delete monHandle;
  monHandle = NULL;
  if(monStartTime)
    delete monStartTime;
  monStartTime = NULL;
  if(monEndTime)
    delete monEndTime;
  monEndTime = NULL;
  if(monPersistentData)
    delete monPersistentData;
  monPersistentData = NULL;
}

MON_Monitoring_Req::MON_Monitoring_Req(const MON_Monitoring_Req &that)
{
   Init();
   *this = that;
}
AsnType *MON_Monitoring_Req::Clone() const
{
  return new MON_Monitoring_Req(*this);
}

MON_Monitoring_Req &MON_Monitoring_Req::operator = (const MON_Monitoring_Req &that)
{
  if (this != &that)
  {
    Clear();
    monServices = that.monServices;
    monBeginSSI = that.monBeginSSI;
    if (that.monEndSSI)
    {
      if (!monEndSSI)
        monEndSSI = new TETRA_Address;
      *monEndSSI = *that.monEndSSI;
    }
    else
    {
      delete monEndSSI;
      monEndSSI = NULL;
    }
    if (that.monHandle)
    {
      if (!monHandle)
        monHandle = new AsnInt;
      *monHandle = *that.monHandle;
    }
    else
    {
      delete monHandle;
      monHandle = NULL;
    }
    if (that.monStartTime)
    {
      if (!monStartTime)
        monStartTime = new GeneralizedTime;
      *monStartTime = *that.monStartTime;
    }
    else
    {
      delete monStartTime;
      monStartTime = NULL;
    }
    if (that.monEndTime)
    {
      if (!monEndTime)
        monEndTime = new GeneralizedTime;
      *monEndTime = *that.monEndTime;
    }
    else
    {
      delete monEndTime;
      monEndTime = NULL;
    }
    if (that.monPersistentData)
    {
      if (!monPersistentData)
        monPersistentData = new AsnBool;
      *monPersistentData = *that.monPersistentData;
    }
    else
    {
      delete monPersistentData;
      monPersistentData = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Monitoring_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (monPersistentData))
  {
    l = monPersistentData->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (monEndTime))
  {
    l = monEndTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (monStartTime))
  {
    l = monStartTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (monHandle))
  {
    l = monHandle->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

  if (NOT_NULL (monEndSSI))
  {
    l = monEndSSI->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

    l = monBeginSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = monServices.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Monitoring_Req::BEncContent


void MON_Monitoring_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Monitoring_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monServices.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monBeginSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monEndSSI = new TETRA_Address;
    monEndSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monHandle = new AsnInt;
    monHandle->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monStartTime = new GeneralizedTime;
    monStartTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monEndTime = new GeneralizedTime;
    monEndTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monPersistentData = new AsnBool;
    monPersistentData->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Monitoring_Req::BDecContent

AsnLen MON_Monitoring_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 70);
  return l;
}

void MON_Monitoring_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Monitoring_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 70))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Monitoring_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monServices ";
	monServices.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monBeginSSI ";
	monBeginSSI.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (monEndSSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monEndSSI ";
		monEndSSI->Print(os, indent);
	}

	if (NOT_NULL (monHandle))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monHandle ";
		monHandle->Print(os, indent);
	}

	if (NOT_NULL (monStartTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monStartTime ";
		monStartTime->Print(os, indent);
	}

	if (NOT_NULL (monEndTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monEndTime ";
		monEndTime->Print(os, indent);
	}

	if (NOT_NULL (monPersistentData))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monPersistentData ";
		monPersistentData->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Monitoring_Req::Print()

void MON_Monitoring_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monServices.PrintXML(os, "monServices");

    monBeginSSI.PrintXML(os, "monBeginSSI");

  if (NOT_NULL (monEndSSI))
  {
    monEndSSI->PrintXML(os, "monEndSSI");
  }

  if (NOT_NULL (monHandle))
  {
    monHandle->PrintXML(os, "monHandle");
  }

  if (NOT_NULL (monStartTime))
  {
    monStartTime->PrintXML(os, "monStartTime");
  }

  if (NOT_NULL (monEndTime))
  {
    monEndTime->PrintXML(os, "monEndTime");
  }

  if (NOT_NULL (monPersistentData))
  {
    monPersistentData->PrintXML(os, "monPersistentData");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Monitoring_Req::PrintXML


void MON_Monitoring_Ack::Init(void)
{
  monEndSSI = NULL;
  countMonParties = NULL;
  monStartTime = NULL;
  monEndTime = NULL;
  persistentData = NULL;
}


int MON_Monitoring_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monServices.checkConstraints(pConstraintFails);

	monBeginSSI.checkConstraints(pConstraintFails);

	if (monEndSSI != NULL)
		monEndSSI->checkConstraints(pConstraintFails);

	if (countMonParties != NULL)
		countMonParties->checkConstraints(pConstraintFails);

	if (monStartTime != NULL)
		monStartTime->checkConstraints(pConstraintFails);

	if (monEndTime != NULL)
		monEndTime->checkConstraints(pConstraintFails);

	if (persistentData != NULL)
		persistentData->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Monitoring_Ack::Clear()
{
  monBeginSSI.Clear();
  if(monEndSSI)
    delete monEndSSI;
  monEndSSI = NULL;
  if(countMonParties)
    delete countMonParties;
  countMonParties = NULL;
  if(monStartTime)
    delete monStartTime;
  monStartTime = NULL;
  if(monEndTime)
    delete monEndTime;
  monEndTime = NULL;
  if(persistentData)
    delete persistentData;
  persistentData = NULL;
}

MON_Monitoring_Ack::MON_Monitoring_Ack(const MON_Monitoring_Ack &that)
{
   Init();
   *this = that;
}
AsnType *MON_Monitoring_Ack::Clone() const
{
  return new MON_Monitoring_Ack(*this);
}

MON_Monitoring_Ack &MON_Monitoring_Ack::operator = (const MON_Monitoring_Ack &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monServices = that.monServices;
    monBeginSSI = that.monBeginSSI;
    if (that.monEndSSI)
    {
      if (!monEndSSI)
        monEndSSI = new TETRA_Address;
      *monEndSSI = *that.monEndSSI;
    }
    else
    {
      delete monEndSSI;
      monEndSSI = NULL;
    }
    if (that.countMonParties)
    {
      if (!countMonParties)
        countMonParties = new AsnInt;
      *countMonParties = *that.countMonParties;
    }
    else
    {
      delete countMonParties;
      countMonParties = NULL;
    }
    if (that.monStartTime)
    {
      if (!monStartTime)
        monStartTime = new GeneralizedTime;
      *monStartTime = *that.monStartTime;
    }
    else
    {
      delete monStartTime;
      monStartTime = NULL;
    }
    if (that.monEndTime)
    {
      if (!monEndTime)
        monEndTime = new GeneralizedTime;
      *monEndTime = *that.monEndTime;
    }
    else
    {
      delete monEndTime;
      monEndTime = NULL;
    }
    if (that.persistentData)
    {
      if (!persistentData)
        persistentData = new AsnBool;
      *persistentData = *that.persistentData;
    }
    else
    {
      delete persistentData;
      persistentData = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Monitoring_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (persistentData))
  {
    l = persistentData->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (monEndTime))
  {
    l = monEndTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (monStartTime))
  {
    l = monStartTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (countMonParties))
  {
    l = countMonParties->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (monEndSSI))
  {
    l = monEndSSI->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;
  }

    l = monBeginSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monServices.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Monitoring_Ack::BEncContent


void MON_Monitoring_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Monitoring_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monServices.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monBeginSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monEndSSI = new TETRA_Address;
    monEndSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  countMonParties = new AsnInt;
    countMonParties->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monStartTime = new GeneralizedTime;
    monStartTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monEndTime = new GeneralizedTime;
    monEndTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  persistentData = new AsnBool;
    persistentData->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Monitoring_Ack::BDecContent

AsnLen MON_Monitoring_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 71);
  return l;
}

void MON_Monitoring_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Monitoring_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 71))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Monitoring_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monServices ";
	monServices.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monBeginSSI ";
	monBeginSSI.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (monEndSSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monEndSSI ";
		monEndSSI->Print(os, indent);
	}

	if (NOT_NULL (countMonParties))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "countMonParties ";
		countMonParties->Print(os, indent);
	}

	if (NOT_NULL (monStartTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monStartTime ";
		monStartTime->Print(os, indent);
	}

	if (NOT_NULL (monEndTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monEndTime ";
		monEndTime->Print(os, indent);
	}

	if (NOT_NULL (persistentData))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "persistentData ";
		persistentData->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Monitoring_Ack::Print()

void MON_Monitoring_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monServices.PrintXML(os, "monServices");

    monBeginSSI.PrintXML(os, "monBeginSSI");

  if (NOT_NULL (monEndSSI))
  {
    monEndSSI->PrintXML(os, "monEndSSI");
  }

  if (NOT_NULL (countMonParties))
  {
    countMonParties->PrintXML(os, "countMonParties");
  }

  if (NOT_NULL (monStartTime))
  {
    monStartTime->PrintXML(os, "monStartTime");
  }

  if (NOT_NULL (monEndTime))
  {
    monEndTime->PrintXML(os, "monEndTime");
  }

  if (NOT_NULL (persistentData))
  {
    persistentData->PrintXML(os, "persistentData");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Monitoring_Ack::PrintXML


void MON_Close::Init(void)
{
  monEndSSI = NULL;
  monFleet = NULL;
}


int MON_Close::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monServices.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	monBeginSSI.checkConstraints(pConstraintFails);

	if (monEndSSI != NULL)
		monEndSSI->checkConstraints(pConstraintFails);

	if (monFleet != NULL)
		monFleet->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Close::Clear()
{
  monBeginSSI.Clear();
  if(monEndSSI)
    delete monEndSSI;
  monEndSSI = NULL;
  if(monFleet)
    delete monFleet;
  monFleet = NULL;
}

MON_Close::MON_Close(const MON_Close &that)
{
   Init();
   *this = that;
}
AsnType *MON_Close::Clone() const
{
  return new MON_Close(*this);
}

MON_Close &MON_Close::operator = (const MON_Close &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monServices = that.monServices;
    result = that.result;
    monBeginSSI = that.monBeginSSI;
    if (that.monEndSSI)
    {
      if (!monEndSSI)
        monEndSSI = new TETRA_Address;
      *monEndSSI = *that.monEndSSI;
    }
    else
    {
      delete monEndSSI;
      monEndSSI = NULL;
    }
    if (that.monFleet)
    {
      if (!monFleet)
        monFleet = new AsnInt;
      *monFleet = *that.monFleet;
    }
    else
    {
      delete monFleet;
      monFleet = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Close::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (monFleet))
  {
    l = monFleet->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (monEndSSI))
  {
    l = monEndSSI->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;
  }

    l = monBeginSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = monServices.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Close::BEncContent


void MON_Close::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Close::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monServices.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monBeginSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monEndSSI = new TETRA_Address;
    monEndSSI->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  monFleet = new AsnInt;
    monFleet->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Close::BDecContent

AsnLen MON_Close::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 75);
  return l;
}

void MON_Close::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Close::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 75))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Close::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monServices ";
	monServices.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monBeginSSI ";
	monBeginSSI.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (monEndSSI))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monEndSSI ";
		monEndSSI->Print(os, indent);
	}

	if (NOT_NULL (monFleet))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "monFleet ";
		monFleet->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Close::Print()

void MON_Close::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monServices.PrintXML(os, "monServices");

    result.PrintXML(os, "result");

    monBeginSSI.PrintXML(os, "monBeginSSI");

  if (NOT_NULL (monEndSSI))
  {
    monEndSSI->PrintXML(os, "monEndSSI");
  }

  if (NOT_NULL (monFleet))
  {
    monFleet->PrintXML(os, "monFleet");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Close::PrintXML


void MON_LocationUpdate::Init(void)
{
}


int MON_LocationUpdate::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	monSSI.checkConstraints(pConstraintFails);

	locationUpdate.checkConstraints(pConstraintFails);

	appendLocationArea.checkConstraints(pConstraintFails);

	locationArea.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	return 0;
}


void MON_LocationUpdate::Clear()
{
  monSSI.Clear();
  locationArea.Clear();
}

MON_LocationUpdate::MON_LocationUpdate(const MON_LocationUpdate &that)
{
   Init();
   *this = that;
}
AsnType *MON_LocationUpdate::Clone() const
{
  return new MON_LocationUpdate(*this);
}

MON_LocationUpdate &MON_LocationUpdate::operator = (const MON_LocationUpdate &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    monSSI = that.monSSI;
    locationUpdate = that.locationUpdate;
    appendLocationArea = that.appendLocationArea;
    locationArea = that.locationArea;
    timeStamp = that.timeStamp;
  }

  return *this;
}

AsnLen
MON_LocationUpdate::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;

    l = locationArea.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 5);
    totalLen += l;

    l = appendLocationArea.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = locationUpdate.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = monSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_LocationUpdate::BEncContent


void MON_LocationUpdate::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_LocationUpdate::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    locationUpdate.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    appendLocationArea.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    locationArea.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_LocationUpdate::BDecContent

AsnLen MON_LocationUpdate::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 77);
  return l;
}

void MON_LocationUpdate::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_LocationUpdate::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 77))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_LocationUpdate::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monSSI ";
	monSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "locationUpdate ";
	locationUpdate.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "appendLocationArea ";
	appendLocationArea.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "locationArea ";
	locationArea.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_LocationUpdate::Print()

void MON_LocationUpdate::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    monSSI.PrintXML(os, "monSSI");

    locationUpdate.PrintXML(os, "locationUpdate");

    appendLocationArea.PrintXML(os, "appendLocationArea");

    locationArea.PrintXML(os, "locationArea");

    timeStamp.PrintXML(os, "timeStamp");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_LocationUpdate::PrintXML


void MON_LocationDetach::Init(void)
{
}


int MON_LocationDetach::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	monSSI.checkConstraints(pConstraintFails);

	locationArea.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	return 0;
}


void MON_LocationDetach::Clear()
{
  monSSI.Clear();
  locationArea.Clear();
}

MON_LocationDetach::MON_LocationDetach(const MON_LocationDetach &that)
{
   Init();
   *this = that;
}
AsnType *MON_LocationDetach::Clone() const
{
  return new MON_LocationDetach(*this);
}

MON_LocationDetach &MON_LocationDetach::operator = (const MON_LocationDetach &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    monSSI = that.monSSI;
    locationArea = that.locationArea;
    timeStamp = that.timeStamp;
  }

  return *this;
}

AsnLen
MON_LocationDetach::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = locationArea.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = monSSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_LocationDetach::BEncContent


void MON_LocationDetach::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_LocationDetach::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monSSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    locationArea.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_LocationDetach::BDecContent

AsnLen MON_LocationDetach::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 78);
  return l;
}

void MON_LocationDetach::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_LocationDetach::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 78))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_LocationDetach::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monSSI ";
	monSSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "locationArea ";
	locationArea.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_LocationDetach::Print()

void MON_LocationDetach::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    monSSI.PrintXML(os, "monSSI");

    locationArea.PrintXML(os, "locationArea");

    timeStamp.PrintXML(os, "timeStamp");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_LocationDetach::PrintXML


void MON_SDS_Data::Init(void)
{
  acknowlegeExpected = NULL;
  macFacility = NULL;
}


int MON_SDS_Data::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	calledParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	sdsHandle.checkConstraints(pConstraintFails);

	sdsData.checkConstraints(pConstraintFails);

	sourceLocation.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	if (acknowlegeExpected != NULL)
		acknowlegeExpected->checkConstraints(pConstraintFails);

	if (macFacility != NULL)
		macFacility->checkConstraints(pConstraintFails);

	return 0;
}


void MON_SDS_Data::Clear()
{
  calledParty.Clear();
  callingParty.Clear();
  sdsData.Clear();
  sourceLocation.Clear();
  if(acknowlegeExpected)
    delete acknowlegeExpected;
  acknowlegeExpected = NULL;
  if(macFacility)
    delete macFacility;
  macFacility = NULL;
}

MON_SDS_Data::MON_SDS_Data(const MON_SDS_Data &that)
{
   Init();
   *this = that;
}
AsnType *MON_SDS_Data::Clone() const
{
  return new MON_SDS_Data(*this);
}

MON_SDS_Data &MON_SDS_Data::operator = (const MON_SDS_Data &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    calledParty = that.calledParty;
    callingParty = that.callingParty;
    sdsHandle = that.sdsHandle;
    sdsData = that.sdsData;
    sourceLocation = that.sourceLocation;
    timeStamp = that.timeStamp;
    if (that.acknowlegeExpected)
    {
      if (!acknowlegeExpected)
        acknowlegeExpected = new AsnBool;
      *acknowlegeExpected = *that.acknowlegeExpected;
    }
    else
    {
      delete acknowlegeExpected;
      acknowlegeExpected = NULL;
    }
    if (that.macFacility)
    {
      if (!macFacility)
        macFacility = new MacFacilityType;
      *macFacility = *that.macFacility;
    }
    else
    {
      delete macFacility;
      macFacility = NULL;
    }
  }

  return *this;
}

AsnLen
MON_SDS_Data::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (macFacility))
  {
    l = macFacility->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 9);
    totalLen += l;
  }

  if (NOT_NULL (acknowlegeExpected))
  {
    l = acknowlegeExpected->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 8);
    totalLen += l;
  }

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;

    l = sourceLocation.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 6);
    totalLen += l;

    l = sdsData.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 5);
    totalLen += l;

    l = sdsHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = calledParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_SDS_Data::BEncContent


void MON_SDS_Data::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_SDS_Data::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    calledParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    sdsHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    sdsData.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    sourceLocation.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  acknowlegeExpected = new AsnBool;
    acknowlegeExpected->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 9)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  macFacility = new MacFacilityType;
    macFacility->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_SDS_Data::BDecContent

AsnLen MON_SDS_Data::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 79);
  return l;
}

void MON_SDS_Data::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_SDS_Data::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 79))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_SDS_Data::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "calledParty ";
	calledParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "sdsHandle ";
	sdsHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "sdsData ";
	sdsData.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "sourceLocation ";
	sourceLocation.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (acknowlegeExpected))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "acknowlegeExpected ";
		acknowlegeExpected->Print(os, indent);
	}

	if (NOT_NULL (macFacility))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "macFacility ";
		macFacility->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_SDS_Data::Print()

void MON_SDS_Data::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    calledParty.PrintXML(os, "calledParty");

    callingParty.PrintXML(os, "callingParty");

    sdsHandle.PrintXML(os, "sdsHandle");

    sdsData.PrintXML(os, "sdsData");

    sourceLocation.PrintXML(os, "sourceLocation");

    timeStamp.PrintXML(os, "timeStamp");

  if (NOT_NULL (acknowlegeExpected))
  {
    acknowlegeExpected->PrintXML(os, "acknowlegeExpected");
  }

  if (NOT_NULL (macFacility))
  {
    macFacility->PrintXML(os, "macFacility");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_SDS_Data::PrintXML


void MON_SDS_Ack::Init(void)
{
}


int MON_SDS_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	calledParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	sdsHandle.checkConstraints(pConstraintFails);

	result.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	return 0;
}


void MON_SDS_Ack::Clear()
{
  calledParty.Clear();
  callingParty.Clear();
}

MON_SDS_Ack::MON_SDS_Ack(const MON_SDS_Ack &that)
{
   Init();
   *this = that;
}
AsnType *MON_SDS_Ack::Clone() const
{
  return new MON_SDS_Ack(*this);
}

MON_SDS_Ack &MON_SDS_Ack::operator = (const MON_SDS_Ack &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    calledParty = that.calledParty;
    callingParty = that.callingParty;
    sdsHandle = that.sdsHandle;
    result = that.result;
    timeStamp = that.timeStamp;
  }

  return *this;
}

AsnLen
MON_SDS_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;

    l = result.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = sdsHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = calledParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_SDS_Ack::BEncContent


void MON_SDS_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_SDS_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    calledParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    sdsHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    result.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_SDS_Ack::BDecContent

AsnLen MON_SDS_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 80);
  return l;
}

void MON_SDS_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_SDS_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 80))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_SDS_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "calledParty ";
	calledParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "sdsHandle ";
	sdsHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "result ";
	result.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_SDS_Ack::Print()

void MON_SDS_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    calledParty.PrintXML(os, "calledParty");

    callingParty.PrintXML(os, "callingParty");

    sdsHandle.PrintXML(os, "sdsHandle");

    result.PrintXML(os, "result");

    timeStamp.PrintXML(os, "timeStamp");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_SDS_Ack::PrintXML


void MON_CC_Information::Init(void)
{
  areaSelection = NULL;
  callTimeOut = NULL;
  callPriority = NULL;
  requestToTransmit = NULL;
  ssNotification = NULL;
  disconnectCause = NULL;
  callingLocationArea = NULL;
  calledLocationArea = NULL;
  basicService = NULL;
  groupMemberParty = NULL;
  elapsedTime = NULL;
  remainingTime = NULL;
  cliControl = NULL;
}


int MON_CC_Information::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	calledParty.checkConstraints(pConstraintFails);

	callingParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	callState.checkConstraints(pConstraintFails);

	hookSignalling.checkConstraints(pConstraintFails);

	duplexMode.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	if (areaSelection != NULL)
		areaSelection->checkConstraints(pConstraintFails);

	if (callTimeOut != NULL)
		callTimeOut->checkConstraints(pConstraintFails);

	if (callPriority != NULL)
		callPriority->checkConstraints(pConstraintFails);

	if (requestToTransmit != NULL)
		requestToTransmit->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	if (disconnectCause != NULL)
		disconnectCause->checkConstraints(pConstraintFails);

	if (callingLocationArea != NULL)
		callingLocationArea->checkConstraints(pConstraintFails);

	if (calledLocationArea != NULL)
		calledLocationArea->checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (groupMemberParty != NULL)
		groupMemberParty->checkConstraints(pConstraintFails);

	if (elapsedTime != NULL)
		elapsedTime->checkConstraints(pConstraintFails);

	if (remainingTime != NULL)
		remainingTime->checkConstraints(pConstraintFails);

	if (cliControl != NULL)
		cliControl->checkConstraints(pConstraintFails);

	return 0;
}


void MON_CC_Information::Clear()
{
  calledParty.Clear();
  callingParty.Clear();
  if(areaSelection)
    delete areaSelection;
  areaSelection = NULL;
  if(callTimeOut)
    delete callTimeOut;
  callTimeOut = NULL;
  if(callPriority)
    delete callPriority;
  callPriority = NULL;
  if(requestToTransmit)
    delete requestToTransmit;
  requestToTransmit = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
  if(disconnectCause)
    delete disconnectCause;
  disconnectCause = NULL;
  if(callingLocationArea)
    delete callingLocationArea;
  callingLocationArea = NULL;
  if(calledLocationArea)
    delete calledLocationArea;
  calledLocationArea = NULL;
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(groupMemberParty)
    delete groupMemberParty;
  groupMemberParty = NULL;
  if(elapsedTime)
    delete elapsedTime;
  elapsedTime = NULL;
  if(remainingTime)
    delete remainingTime;
  remainingTime = NULL;
  if(cliControl)
    delete cliControl;
  cliControl = NULL;
}

MON_CC_Information::MON_CC_Information(const MON_CC_Information &that)
{
   Init();
   *this = that;
}
AsnType *MON_CC_Information::Clone() const
{
  return new MON_CC_Information(*this);
}

MON_CC_Information &MON_CC_Information::operator = (const MON_CC_Information &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    calledParty = that.calledParty;
    callingParty = that.callingParty;
    callID = that.callID;
    callState = that.callState;
    hookSignalling = that.hookSignalling;
    duplexMode = that.duplexMode;
    timeStamp = that.timeStamp;
    if (that.areaSelection)
    {
      if (!areaSelection)
        areaSelection = new AreaType;
      *areaSelection = *that.areaSelection;
    }
    else
    {
      delete areaSelection;
      areaSelection = NULL;
    }
    if (that.callTimeOut)
    {
      if (!callTimeOut)
        callTimeOut = new TetraCallTime;
      *callTimeOut = *that.callTimeOut;
    }
    else
    {
      delete callTimeOut;
      callTimeOut = NULL;
    }
    if (that.callPriority)
    {
      if (!callPriority)
        callPriority = new CallPriorityType;
      *callPriority = *that.callPriority;
    }
    else
    {
      delete callPriority;
      callPriority = NULL;
    }
    if (that.requestToTransmit)
    {
      if (!requestToTransmit)
        requestToTransmit = new AsnBool;
      *requestToTransmit = *that.requestToTransmit;
    }
    else
    {
      delete requestToTransmit;
      requestToTransmit = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
    if (that.disconnectCause)
    {
      if (!disconnectCause)
        disconnectCause = new DisconnectType;
      *disconnectCause = *that.disconnectCause;
    }
    else
    {
      delete disconnectCause;
      disconnectCause = NULL;
    }
    if (that.callingLocationArea)
    {
      if (!callingLocationArea)
        callingLocationArea = new LocationAreaType;
      *callingLocationArea = *that.callingLocationArea;
    }
    else
    {
      delete callingLocationArea;
      callingLocationArea = NULL;
    }
    if (that.calledLocationArea)
    {
      if (!calledLocationArea)
        calledLocationArea = new LocationAreaType;
      *calledLocationArea = *that.calledLocationArea;
    }
    else
    {
      delete calledLocationArea;
      calledLocationArea = NULL;
    }
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.groupMemberParty)
    {
      if (!groupMemberParty)
        groupMemberParty = new AddressType;
      *groupMemberParty = *that.groupMemberParty;
    }
    else
    {
      delete groupMemberParty;
      groupMemberParty = NULL;
    }
    if (that.elapsedTime)
    {
      if (!elapsedTime)
        elapsedTime = new AsnInt;
      *elapsedTime = *that.elapsedTime;
    }
    else
    {
      delete elapsedTime;
      elapsedTime = NULL;
    }
    if (that.remainingTime)
    {
      if (!remainingTime)
        remainingTime = new AsnInt;
      *remainingTime = *that.remainingTime;
    }
    else
    {
      delete remainingTime;
      remainingTime = NULL;
    }
    if (that.cliControl)
    {
      if (!cliControl)
        cliControl = new CliType;
      *cliControl = *that.cliControl;
    }
    else
    {
      delete cliControl;
      cliControl = NULL;
    }
  }

  return *this;
}

AsnLen
MON_CC_Information::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (cliControl))
  {
    l = cliControl->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 21);
    totalLen += l;
  }

  if (NOT_NULL (remainingTime))
  {
    l = remainingTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 20);
    totalLen += l;
  }

  if (NOT_NULL (elapsedTime))
  {
    l = elapsedTime->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 19);
    totalLen += l;
  }

  if (NOT_NULL (groupMemberParty))
  {
    l = groupMemberParty->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 18);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 17);
    totalLen += l;
  }

  if (NOT_NULL (calledLocationArea))
  {
    l = calledLocationArea->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 16);
    totalLen += l;
  }

  if (NOT_NULL (callingLocationArea))
  {
    l = callingLocationArea->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 15);
    totalLen += l;
  }

  if (NOT_NULL (disconnectCause))
  {
    l = disconnectCause->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 14);
    totalLen += l;
  }

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 13);
    totalLen += l;
  }

  if (NOT_NULL (requestToTransmit))
  {
    l = requestToTransmit->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 12);
    totalLen += l;
  }

  if (NOT_NULL (callPriority))
  {
    l = callPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 11);
    totalLen += l;
  }

  if (NOT_NULL (callTimeOut))
  {
    l = callTimeOut->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 10);
    totalLen += l;
  }

  if (NOT_NULL (areaSelection))
  {
    l = areaSelection->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 9);
    totalLen += l;
  }

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 8);
    totalLen += l;

    l = duplexMode.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;

    l = hookSignalling.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;

    l = callState.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = callingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = calledParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_CC_Information::BEncContent


void MON_CC_Information::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_CC_Information::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    calledParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callState.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    hookSignalling.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    duplexMode.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 9)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  areaSelection = new AreaType;
    areaSelection->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 10)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callTimeOut = new TetraCallTime;
    callTimeOut->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 11)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callPriority = new CallPriorityType;
    callPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 12)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  requestToTransmit = new AsnBool;
    requestToTransmit->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 13)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 14)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  disconnectCause = new DisconnectType;
    disconnectCause->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 15)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callingLocationArea = new LocationAreaType;
    callingLocationArea->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 16)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  calledLocationArea = new LocationAreaType;
    calledLocationArea->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 17)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 18)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  groupMemberParty = new AddressType;
    groupMemberParty->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 19)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  elapsedTime = new AsnInt;
    elapsedTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 20)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  remainingTime = new AsnInt;
    remainingTime->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 21)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  cliControl = new CliType;
    cliControl->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_CC_Information::BDecContent

AsnLen MON_CC_Information::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 81);
  return l;
}

void MON_CC_Information::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_CC_Information::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 81))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_CC_Information::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "calledParty ";
	calledParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callingParty ";
	callingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callState ";
	callState.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "hookSignalling ";
	hookSignalling.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "duplexMode ";
	duplexMode.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (areaSelection))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "areaSelection ";
		areaSelection->Print(os, indent);
	}

	if (NOT_NULL (callTimeOut))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callTimeOut ";
		callTimeOut->Print(os, indent);
	}

	if (NOT_NULL (callPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callPriority ";
		callPriority->Print(os, indent);
	}

	if (NOT_NULL (requestToTransmit))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "requestToTransmit ";
		requestToTransmit->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	if (NOT_NULL (disconnectCause))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "disconnectCause ";
		disconnectCause->Print(os, indent);
	}

	if (NOT_NULL (callingLocationArea))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callingLocationArea ";
		callingLocationArea->Print(os, indent);
	}

	if (NOT_NULL (calledLocationArea))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "calledLocationArea ";
		calledLocationArea->Print(os, indent);
	}

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (groupMemberParty))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "groupMemberParty ";
		groupMemberParty->Print(os, indent);
	}

	if (NOT_NULL (elapsedTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "elapsedTime ";
		elapsedTime->Print(os, indent);
	}

	if (NOT_NULL (remainingTime))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "remainingTime ";
		remainingTime->Print(os, indent);
	}

	if (NOT_NULL (cliControl))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "cliControl ";
		cliControl->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_CC_Information::Print()

void MON_CC_Information::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    calledParty.PrintXML(os, "calledParty");

    callingParty.PrintXML(os, "callingParty");

    callID.PrintXML(os, "callID");

    callState.PrintXML(os, "callState");

    hookSignalling.PrintXML(os, "hookSignalling");

    duplexMode.PrintXML(os, "duplexMode");

    timeStamp.PrintXML(os, "timeStamp");

  if (NOT_NULL (areaSelection))
  {
    areaSelection->PrintXML(os, "areaSelection");
  }

  if (NOT_NULL (callTimeOut))
  {
    callTimeOut->PrintXML(os, "callTimeOut");
  }

  if (NOT_NULL (callPriority))
  {
    callPriority->PrintXML(os, "callPriority");
  }

  if (NOT_NULL (requestToTransmit))
  {
    requestToTransmit->PrintXML(os, "requestToTransmit");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (NOT_NULL (disconnectCause))
  {
    disconnectCause->PrintXML(os, "disconnectCause");
  }

  if (NOT_NULL (callingLocationArea))
  {
    callingLocationArea->PrintXML(os, "callingLocationArea");
  }

  if (NOT_NULL (calledLocationArea))
  {
    calledLocationArea->PrintXML(os, "calledLocationArea");
  }

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (groupMemberParty))
  {
    groupMemberParty->PrintXML(os, "groupMemberParty");
  }

  if (NOT_NULL (elapsedTime))
  {
    elapsedTime->PrintXML(os, "elapsedTime");
  }

  if (NOT_NULL (remainingTime))
  {
    remainingTime->PrintXML(os, "remainingTime");
  }

  if (NOT_NULL (cliControl))
  {
    cliControl->PrintXML(os, "cliControl");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_CC_Information::PrintXML


void MON_TxDemand::Init(void)
{
  txPriority = NULL;
  encryption = NULL;
}


int MON_TxDemand::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	demandPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	if (txPriority != NULL)
		txPriority->checkConstraints(pConstraintFails);

	if (encryption != NULL)
		encryption->checkConstraints(pConstraintFails);

	return 0;
}


void MON_TxDemand::Clear()
{
  demandPartySSI.Clear();
  if(txPriority)
    delete txPriority;
  txPriority = NULL;
  if(encryption)
    delete encryption;
  encryption = NULL;
}

MON_TxDemand::MON_TxDemand(const MON_TxDemand &that)
{
   Init();
   *this = that;
}
AsnType *MON_TxDemand::Clone() const
{
  return new MON_TxDemand(*this);
}

MON_TxDemand &MON_TxDemand::operator = (const MON_TxDemand &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    demandPartySSI = that.demandPartySSI;
    callID = that.callID;
    timeStamp = that.timeStamp;
    if (that.txPriority)
    {
      if (!txPriority)
        txPriority = new TxPriorityType;
      *txPriority = *that.txPriority;
    }
    else
    {
      delete txPriority;
      txPriority = NULL;
    }
    if (that.encryption)
    {
      if (!encryption)
        encryption = new AsnBool;
      *encryption = *that.encryption;
    }
    else
    {
      delete encryption;
      encryption = NULL;
    }
  }

  return *this;
}

AsnLen
MON_TxDemand::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (encryption))
  {
    l = encryption->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (txPriority))
  {
    l = txPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = demandPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_TxDemand::BEncContent


void MON_TxDemand::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_TxDemand::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    demandPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txPriority = new TxPriorityType;
    txPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  encryption = new AsnBool;
    encryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_TxDemand::BDecContent

AsnLen MON_TxDemand::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 82);
  return l;
}

void MON_TxDemand::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_TxDemand::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 82))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_TxDemand::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "demandPartySSI ";
	demandPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txPriority ";
		txPriority->Print(os, indent);
	}

	if (NOT_NULL (encryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "encryption ";
		encryption->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_TxDemand::Print()

void MON_TxDemand::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    demandPartySSI.PrintXML(os, "demandPartySSI");

    callID.PrintXML(os, "callID");

    timeStamp.PrintXML(os, "timeStamp");

  if (NOT_NULL (txPriority))
  {
    txPriority->PrintXML(os, "txPriority");
  }

  if (NOT_NULL (encryption))
  {
    encryption->PrintXML(os, "encryption");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_TxDemand::PrintXML


void MON_Uplink_TxDemand::Init(void)
{
  txPriority = NULL;
  encryption = NULL;
  lineInformation = NULL;
  noNfLoopBack = NULL;
}


int MON_Uplink_TxDemand::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	demandPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	if (txPriority != NULL)
		txPriority->checkConstraints(pConstraintFails);

	if (encryption != NULL)
		encryption->checkConstraints(pConstraintFails);

	if (lineInformation != NULL)
		lineInformation->checkConstraints(pConstraintFails);

	if (noNfLoopBack != NULL)
		noNfLoopBack->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Uplink_TxDemand::Clear()
{
  demandPartySSI.Clear();
  if(txPriority)
    delete txPriority;
  txPriority = NULL;
  if(encryption)
    delete encryption;
  encryption = NULL;
  if(lineInformation)
    delete lineInformation;
  lineInformation = NULL;
  if(noNfLoopBack)
    delete noNfLoopBack;
  noNfLoopBack = NULL;
}

MON_Uplink_TxDemand::MON_Uplink_TxDemand(const MON_Uplink_TxDemand &that)
{
   Init();
   *this = that;
}
AsnType *MON_Uplink_TxDemand::Clone() const
{
  return new MON_Uplink_TxDemand(*this);
}

MON_Uplink_TxDemand &MON_Uplink_TxDemand::operator = (const MON_Uplink_TxDemand &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    demandPartySSI = that.demandPartySSI;
    callID = that.callID;
    if (that.txPriority)
    {
      if (!txPriority)
        txPriority = new TxPriorityType;
      *txPriority = *that.txPriority;
    }
    else
    {
      delete txPriority;
      txPriority = NULL;
    }
    if (that.encryption)
    {
      if (!encryption)
        encryption = new AsnBool;
      *encryption = *that.encryption;
    }
    else
    {
      delete encryption;
      encryption = NULL;
    }
    if (that.lineInformation)
    {
      if (!lineInformation)
        lineInformation = new LineInformationType;
      *lineInformation = *that.lineInformation;
    }
    else
    {
      delete lineInformation;
      lineInformation = NULL;
    }
    if (that.noNfLoopBack)
    {
      if (!noNfLoopBack)
        noNfLoopBack = new AsnBool;
      *noNfLoopBack = *that.noNfLoopBack;
    }
    else
    {
      delete noNfLoopBack;
      noNfLoopBack = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Uplink_TxDemand::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (noNfLoopBack))
  {
    l = noNfLoopBack->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

  if (NOT_NULL (lineInformation))
  {
    l = lineInformation->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 5);
    totalLen += l;
  }

  if (NOT_NULL (encryption))
  {
    l = encryption->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (txPriority))
  {
    l = txPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = demandPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Uplink_TxDemand::BEncContent


void MON_Uplink_TxDemand::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Uplink_TxDemand::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    demandPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txPriority = new TxPriorityType;
    txPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  encryption = new AsnBool;
    encryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  lineInformation = new LineInformationType;
    lineInformation->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  noNfLoopBack = new AsnBool;
    noNfLoopBack->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Uplink_TxDemand::BDecContent

AsnLen MON_Uplink_TxDemand::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 93);
  return l;
}

void MON_Uplink_TxDemand::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Uplink_TxDemand::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 93))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Uplink_TxDemand::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "demandPartySSI ";
	demandPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txPriority ";
		txPriority->Print(os, indent);
	}

	if (NOT_NULL (encryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "encryption ";
		encryption->Print(os, indent);
	}

	if (NOT_NULL (lineInformation))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineInformation ";
		lineInformation->Print(os, indent);
	}

	if (NOT_NULL (noNfLoopBack))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "noNfLoopBack ";
		noNfLoopBack->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Uplink_TxDemand::Print()

void MON_Uplink_TxDemand::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    demandPartySSI.PrintXML(os, "demandPartySSI");

    callID.PrintXML(os, "callID");

  if (NOT_NULL (txPriority))
  {
    txPriority->PrintXML(os, "txPriority");
  }

  if (NOT_NULL (encryption))
  {
    encryption->PrintXML(os, "encryption");
  }

  if (NOT_NULL (lineInformation))
  {
    lineInformation->PrintXML(os, "lineInformation");
  }

  if (NOT_NULL (noNfLoopBack))
  {
    noNfLoopBack->PrintXML(os, "noNfLoopBack");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Uplink_TxDemand::PrintXML


void MON_TxCeased::Init(void)
{
  txReqPermission = NULL;
}


int MON_TxCeased::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	callPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	return 0;
}


void MON_TxCeased::Clear()
{
  callPartySSI.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
}

MON_TxCeased::MON_TxCeased(const MON_TxCeased &that)
{
   Init();
   *this = that;
}
AsnType *MON_TxCeased::Clone() const
{
  return new MON_TxCeased(*this);
}

MON_TxCeased &MON_TxCeased::operator = (const MON_TxCeased &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    callPartySSI = that.callPartySSI;
    callID = that.callID;
    timeStamp = that.timeStamp;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
  }

  return *this;
}

AsnLen
MON_TxCeased::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_TxCeased::BEncContent


void MON_TxCeased::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_TxCeased::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_TxCeased::BDecContent

AsnLen MON_TxCeased::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 83);
  return l;
}

void MON_TxCeased::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_TxCeased::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 83))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_TxCeased::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_TxCeased::Print()

void MON_TxCeased::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    callPartySSI.PrintXML(os, "callPartySSI");

    callID.PrintXML(os, "callID");

    timeStamp.PrintXML(os, "timeStamp");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_TxCeased::PrintXML


void MON_Uplink_TxCeased::Init(void)
{
  txReqPermission = NULL;
  ssNotification = NULL;
}


int MON_Uplink_TxCeased::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	callParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (ssNotification != NULL)
		ssNotification->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Uplink_TxCeased::Clear()
{
  callParty.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(ssNotification)
    delete ssNotification;
  ssNotification = NULL;
}

MON_Uplink_TxCeased::MON_Uplink_TxCeased(const MON_Uplink_TxCeased &that)
{
   Init();
   *this = that;
}
AsnType *MON_Uplink_TxCeased::Clone() const
{
  return new MON_Uplink_TxCeased(*this);
}

MON_Uplink_TxCeased &MON_Uplink_TxCeased::operator = (const MON_Uplink_TxCeased &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    callParty = that.callParty;
    callID = that.callID;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.ssNotification)
    {
      if (!ssNotification)
        ssNotification = new SS_NotificationType;
      *ssNotification = *that.ssNotification;
    }
    else
    {
      delete ssNotification;
      ssNotification = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Uplink_TxCeased::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (ssNotification))
  {
    l = ssNotification->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Uplink_TxCeased::BEncContent


void MON_Uplink_TxCeased::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Uplink_TxCeased::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    callParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  ssNotification = new SS_NotificationType;
    ssNotification->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Uplink_TxCeased::BDecContent

AsnLen MON_Uplink_TxCeased::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 95);
  return l;
}

void MON_Uplink_TxCeased::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Uplink_TxCeased::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 95))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Uplink_TxCeased::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callParty ";
	callParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (ssNotification))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "ssNotification ";
		ssNotification->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Uplink_TxCeased::Print()

void MON_Uplink_TxCeased::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    callParty.PrintXML(os, "callParty");

    callID.PrintXML(os, "callID");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (ssNotification))
  {
    ssNotification->PrintXML(os, "ssNotification");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Uplink_TxCeased::PrintXML


void MON_TxGrant::Init(void)
{
  txReqPermission = NULL;
  encryption = NULL;
  tpiRestriction = NULL;
}


int MON_TxGrant::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	callPartySSI.checkConstraints(pConstraintFails);

	transmittingParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	txGrant.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (encryption != NULL)
		encryption->checkConstraints(pConstraintFails);

	if (tpiRestriction != NULL)
		tpiRestriction->checkConstraints(pConstraintFails);

	return 0;
}


void MON_TxGrant::Clear()
{
  callPartySSI.Clear();
  transmittingParty.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(encryption)
    delete encryption;
  encryption = NULL;
  if(tpiRestriction)
    delete tpiRestriction;
  tpiRestriction = NULL;
}

MON_TxGrant::MON_TxGrant(const MON_TxGrant &that)
{
   Init();
   *this = that;
}
AsnType *MON_TxGrant::Clone() const
{
  return new MON_TxGrant(*this);
}

MON_TxGrant &MON_TxGrant::operator = (const MON_TxGrant &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    callPartySSI = that.callPartySSI;
    transmittingParty = that.transmittingParty;
    callID = that.callID;
    txGrant = that.txGrant;
    timeStamp = that.timeStamp;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.encryption)
    {
      if (!encryption)
        encryption = new AsnBool;
      *encryption = *that.encryption;
    }
    else
    {
      delete encryption;
      encryption = NULL;
    }
    if (that.tpiRestriction)
    {
      if (!tpiRestriction)
        tpiRestriction = new CliType;
      *tpiRestriction = *that.tpiRestriction;
    }
    else
    {
      delete tpiRestriction;
      tpiRestriction = NULL;
    }
  }

  return *this;
}

AsnLen
MON_TxGrant::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (tpiRestriction))
  {
    l = tpiRestriction->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 9);
    totalLen += l;
  }

  if (NOT_NULL (encryption))
  {
    l = encryption->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 8);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;

    l = txGrant.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = transmittingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_TxGrant::BEncContent


void MON_TxGrant::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_TxGrant::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    transmittingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    txGrant.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  encryption = new AsnBool;
    encryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 9)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  tpiRestriction = new CliType;
    tpiRestriction->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_TxGrant::BDecContent

AsnLen MON_TxGrant::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 84);
  return l;
}

void MON_TxGrant::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_TxGrant::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 84))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_TxGrant::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "transmittingParty ";
	transmittingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "txGrant ";
	txGrant.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (encryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "encryption ";
		encryption->Print(os, indent);
	}

	if (NOT_NULL (tpiRestriction))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "tpiRestriction ";
		tpiRestriction->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_TxGrant::Print()

void MON_TxGrant::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    callPartySSI.PrintXML(os, "callPartySSI");

    transmittingParty.PrintXML(os, "transmittingParty");

    callID.PrintXML(os, "callID");

    txGrant.PrintXML(os, "txGrant");

    timeStamp.PrintXML(os, "timeStamp");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (encryption))
  {
    encryption->PrintXML(os, "encryption");
  }

  if (NOT_NULL (tpiRestriction))
  {
    tpiRestriction->PrintXML(os, "tpiRestriction");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_TxGrant::PrintXML


void MON_Disconnect::Init(void)
{
  callEnd = NULL;
}


int MON_Disconnect::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	disconnectedPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	disconnectCause.checkConstraints(pConstraintFails);

	timeStamp.checkConstraints(pConstraintFails);

	if (callEnd != NULL)
		callEnd->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Disconnect::Clear()
{
  disconnectedPartySSI.Clear();
  if(callEnd)
    delete callEnd;
  callEnd = NULL;
}

MON_Disconnect::MON_Disconnect(const MON_Disconnect &that)
{
   Init();
   *this = that;
}
AsnType *MON_Disconnect::Clone() const
{
  return new MON_Disconnect(*this);
}

MON_Disconnect &MON_Disconnect::operator = (const MON_Disconnect &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    disconnectedPartySSI = that.disconnectedPartySSI;
    callID = that.callID;
    disconnectCause = that.disconnectCause;
    timeStamp = that.timeStamp;
    if (that.callEnd)
    {
      if (!callEnd)
        callEnd = new AsnBool;
      *callEnd = *that.callEnd;
    }
    else
    {
      delete callEnd;
      callEnd = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Disconnect::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (callEnd))
  {
    l = callEnd->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

    l = timeStamp.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = disconnectCause.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = disconnectedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Disconnect::BEncContent


void MON_Disconnect::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Disconnect::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    disconnectedPartySSI.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    disconnectCause.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    timeStamp.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callEnd = new AsnBool;
    callEnd->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Disconnect::BDecContent

AsnLen MON_Disconnect::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 85);
  return l;
}

void MON_Disconnect::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Disconnect::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 85))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Disconnect::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectedPartySSI ";
	disconnectedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectCause ";
	disconnectCause.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "timeStamp ";
	timeStamp.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (callEnd))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callEnd ";
		callEnd->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Disconnect::Print()

void MON_Disconnect::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    disconnectedPartySSI.PrintXML(os, "disconnectedPartySSI");

    callID.PrintXML(os, "callID");

    disconnectCause.PrintXML(os, "disconnectCause");

    timeStamp.PrintXML(os, "timeStamp");

  if (NOT_NULL (callEnd))
  {
    callEnd->PrintXML(os, "callEnd");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Disconnect::PrintXML


void MON_Intercept_Req::Init(void)
{
  basicService = NULL;
  lineInformation2 = NULL;
}


int MON_Intercept_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	callPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	lineInformation1.checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (lineInformation2 != NULL)
		lineInformation2->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Intercept_Req::Clear()
{
  callPartySSI.Clear();
  lineInformation1.Clear();
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(lineInformation2)
    delete lineInformation2;
  lineInformation2 = NULL;
}

MON_Intercept_Req::MON_Intercept_Req(const MON_Intercept_Req &that)
{
   Init();
   *this = that;
}
AsnType *MON_Intercept_Req::Clone() const
{
  return new MON_Intercept_Req(*this);
}

MON_Intercept_Req &MON_Intercept_Req::operator = (const MON_Intercept_Req &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    callPartySSI = that.callPartySSI;
    callID = that.callID;
    lineInformation1 = that.lineInformation1;
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.lineInformation2)
    {
      if (!lineInformation2)
        lineInformation2 = new LineInformationType;
      *lineInformation2 = *that.lineInformation2;
    }
    else
    {
      delete lineInformation2;
      lineInformation2 = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Intercept_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (lineInformation2))
  {
    l = lineInformation2->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 5);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 4);
    totalLen += l;
  }

    l = lineInformation1.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Intercept_Req::BEncContent


void MON_Intercept_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    lineInformation1.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  lineInformation2 = new LineInformationType;
    lineInformation2->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Intercept_Req::BDecContent

AsnLen MON_Intercept_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 86);
  return l;
}

void MON_Intercept_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 86))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Intercept_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineInformation1 ";
	lineInformation1.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (lineInformation2))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineInformation2 ";
		lineInformation2->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Intercept_Req::Print()

void MON_Intercept_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    callPartySSI.PrintXML(os, "callPartySSI");

    callID.PrintXML(os, "callID");

    lineInformation1.PrintXML(os, "lineInformation1");

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (lineInformation2))
  {
    lineInformation2->PrintXML(os, "lineInformation2");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Intercept_Req::PrintXML


void MON_Intercept_Ack::Init(void)
{
  basicService = NULL;
  lineInfoAck2 = NULL;
}


int MON_Intercept_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	callPartySSI.checkConstraints(pConstraintFails);

	interceptSSI1.checkConstraints(pConstraintFails);

	interceptSSI2.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	duplexMode.checkConstraints(pConstraintFails);

	lineInfoAck1.checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (lineInfoAck2 != NULL)
		lineInfoAck2->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Intercept_Ack::Clear()
{
  callPartySSI.Clear();
  interceptSSI1.Clear();
  interceptSSI2.Clear();
  lineInfoAck1.Clear();
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(lineInfoAck2)
    delete lineInfoAck2;
  lineInfoAck2 = NULL;
}

MON_Intercept_Ack::MON_Intercept_Ack(const MON_Intercept_Ack &that)
{
   Init();
   *this = that;
}
AsnType *MON_Intercept_Ack::Clone() const
{
  return new MON_Intercept_Ack(*this);
}

MON_Intercept_Ack &MON_Intercept_Ack::operator = (const MON_Intercept_Ack &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    callPartySSI = that.callPartySSI;
    interceptSSI1 = that.interceptSSI1;
    interceptSSI2 = that.interceptSSI2;
    callID = that.callID;
    duplexMode = that.duplexMode;
    lineInfoAck1 = that.lineInfoAck1;
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.lineInfoAck2)
    {
      if (!lineInfoAck2)
        lineInfoAck2 = new LineInfoAckType;
      *lineInfoAck2 = *that.lineInfoAck2;
    }
    else
    {
      delete lineInfoAck2;
      lineInfoAck2 = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Intercept_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (lineInfoAck2))
  {
    l = lineInfoAck2->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 8);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 7);
    totalLen += l;
  }

    l = lineInfoAck1.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 6);
    totalLen += l;

    l = duplexMode.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = interceptSSI2.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = interceptSSI1.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Intercept_Ack::BEncContent


void MON_Intercept_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    interceptSSI1.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    interceptSSI2.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    duplexMode.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    lineInfoAck1.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  lineInfoAck2 = new LineInfoAckType;
    lineInfoAck2->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Intercept_Ack::BDecContent

AsnLen MON_Intercept_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 87);
  return l;
}

void MON_Intercept_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 87))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Intercept_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "interceptSSI1 ";
	interceptSSI1.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "interceptSSI2 ";
	interceptSSI2.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "duplexMode ";
	duplexMode.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineInfoAck1 ";
	lineInfoAck1.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (lineInfoAck2))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineInfoAck2 ";
		lineInfoAck2->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Intercept_Ack::Print()

void MON_Intercept_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    callPartySSI.PrintXML(os, "callPartySSI");

    interceptSSI1.PrintXML(os, "interceptSSI1");

    interceptSSI2.PrintXML(os, "interceptSSI2");

    callID.PrintXML(os, "callID");

    duplexMode.PrintXML(os, "duplexMode");

    lineInfoAck1.PrintXML(os, "lineInfoAck1");

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (lineInfoAck2))
  {
    lineInfoAck2->PrintXML(os, "lineInfoAck2");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Intercept_Ack::PrintXML


void MON_Intercept_Connect::Init(void)
{
  txGrant = NULL;
  callPriority = NULL;
  basicService = NULL;
  lineInfoAck1 = NULL;
  lineInfoAck2 = NULL;
}


int MON_Intercept_Connect::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	callPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	duplexMode.checkConstraints(pConstraintFails);

	if (txGrant != NULL)
		txGrant->checkConstraints(pConstraintFails);

	if (callPriority != NULL)
		callPriority->checkConstraints(pConstraintFails);

	if (basicService != NULL)
		basicService->checkConstraints(pConstraintFails);

	if (lineInfoAck1 != NULL)
		lineInfoAck1->checkConstraints(pConstraintFails);

	if (lineInfoAck2 != NULL)
		lineInfoAck2->checkConstraints(pConstraintFails);

	return 0;
}


void MON_Intercept_Connect::Clear()
{
  callPartySSI.Clear();
  if(txGrant)
    delete txGrant;
  txGrant = NULL;
  if(callPriority)
    delete callPriority;
  callPriority = NULL;
  if(basicService)
    delete basicService;
  basicService = NULL;
  if(lineInfoAck1)
    delete lineInfoAck1;
  lineInfoAck1 = NULL;
  if(lineInfoAck2)
    delete lineInfoAck2;
  lineInfoAck2 = NULL;
}

MON_Intercept_Connect::MON_Intercept_Connect(const MON_Intercept_Connect &that)
{
   Init();
   *this = that;
}
AsnType *MON_Intercept_Connect::Clone() const
{
  return new MON_Intercept_Connect(*this);
}

MON_Intercept_Connect &MON_Intercept_Connect::operator = (const MON_Intercept_Connect &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    callPartySSI = that.callPartySSI;
    callID = that.callID;
    duplexMode = that.duplexMode;
    if (that.txGrant)
    {
      if (!txGrant)
        txGrant = new TxGrantType;
      *txGrant = *that.txGrant;
    }
    else
    {
      delete txGrant;
      txGrant = NULL;
    }
    if (that.callPriority)
    {
      if (!callPriority)
        callPriority = new CallPriorityType;
      *callPriority = *that.callPriority;
    }
    else
    {
      delete callPriority;
      callPriority = NULL;
    }
    if (that.basicService)
    {
      if (!basicService)
        basicService = new BasicServiceType;
      *basicService = *that.basicService;
    }
    else
    {
      delete basicService;
      basicService = NULL;
    }
    if (that.lineInfoAck1)
    {
      if (!lineInfoAck1)
        lineInfoAck1 = new LineInfoAckType;
      *lineInfoAck1 = *that.lineInfoAck1;
    }
    else
    {
      delete lineInfoAck1;
      lineInfoAck1 = NULL;
    }
    if (that.lineInfoAck2)
    {
      if (!lineInfoAck2)
        lineInfoAck2 = new LineInfoAckType;
      *lineInfoAck2 = *that.lineInfoAck2;
    }
    else
    {
      delete lineInfoAck2;
      lineInfoAck2 = NULL;
    }
  }

  return *this;
}

AsnLen
MON_Intercept_Connect::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (lineInfoAck2))
  {
    l = lineInfoAck2->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 8);
    totalLen += l;
  }

  if (NOT_NULL (lineInfoAck1))
  {
    l = lineInfoAck1->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 7);
    totalLen += l;
  }

  if (NOT_NULL (basicService))
  {
    l = basicService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 6);
    totalLen += l;
  }

  if (NOT_NULL (callPriority))
  {
    l = callPriority->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;
  }

  if (NOT_NULL (txGrant))
  {
    l = txGrant->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = duplexMode.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Intercept_Connect::BEncContent


void MON_Intercept_Connect::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Connect::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    duplexMode.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txGrant = new TxGrantType;
    txGrant->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  callPriority = new CallPriorityType;
    callPriority->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  basicService = new BasicServiceType;
    basicService->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  lineInfoAck1 = new LineInfoAckType;
    lineInfoAck1->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  lineInfoAck2 = new LineInfoAckType;
    lineInfoAck2->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Intercept_Connect::BDecContent

AsnLen MON_Intercept_Connect::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 88);
  return l;
}

void MON_Intercept_Connect::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Connect::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 88))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Intercept_Connect::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "duplexMode ";
	duplexMode.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txGrant))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txGrant ";
		txGrant->Print(os, indent);
	}

	if (NOT_NULL (callPriority))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "callPriority ";
		callPriority->Print(os, indent);
	}

	if (NOT_NULL (basicService))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "basicService ";
		basicService->Print(os, indent);
	}

	if (NOT_NULL (lineInfoAck1))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineInfoAck1 ";
		lineInfoAck1->Print(os, indent);
	}

	if (NOT_NULL (lineInfoAck2))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineInfoAck2 ";
		lineInfoAck2->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Intercept_Connect::Print()

void MON_Intercept_Connect::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    callPartySSI.PrintXML(os, "callPartySSI");

    callID.PrintXML(os, "callID");

    duplexMode.PrintXML(os, "duplexMode");

  if (NOT_NULL (txGrant))
  {
    txGrant->PrintXML(os, "txGrant");
  }

  if (NOT_NULL (callPriority))
  {
    callPriority->PrintXML(os, "callPriority");
  }

  if (NOT_NULL (basicService))
  {
    basicService->PrintXML(os, "basicService");
  }

  if (NOT_NULL (lineInfoAck1))
  {
    lineInfoAck1->PrintXML(os, "lineInfoAck1");
  }

  if (NOT_NULL (lineInfoAck2))
  {
    lineInfoAck2->PrintXML(os, "lineInfoAck2");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Intercept_Connect::PrintXML


void MON_Intercept_Disconnect::Init(void)
{
}


int MON_Intercept_Disconnect::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	disconnectedPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	disconnectCause.checkConstraints(pConstraintFails);

	return 0;
}


void MON_Intercept_Disconnect::Clear()
{
  disconnectedPartySSI.Clear();
}

MON_Intercept_Disconnect::MON_Intercept_Disconnect(const MON_Intercept_Disconnect &that)
{
   Init();
   *this = that;
}
AsnType *MON_Intercept_Disconnect::Clone() const
{
  return new MON_Intercept_Disconnect(*this);
}

MON_Intercept_Disconnect &MON_Intercept_Disconnect::operator = (const MON_Intercept_Disconnect &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    disconnectedPartySSI = that.disconnectedPartySSI;
    callID = that.callID;
    disconnectCause = that.disconnectCause;
  }

  return *this;
}

AsnLen
MON_Intercept_Disconnect::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = disconnectCause.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = disconnectedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Intercept_Disconnect::BEncContent


void MON_Intercept_Disconnect::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Disconnect::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    disconnectedPartySSI.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    disconnectCause.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Intercept_Disconnect::BDecContent

AsnLen MON_Intercept_Disconnect::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 89);
  return l;
}

void MON_Intercept_Disconnect::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Disconnect::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 89))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Intercept_Disconnect::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectedPartySSI ";
	disconnectedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectCause ";
	disconnectCause.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Intercept_Disconnect::Print()

void MON_Intercept_Disconnect::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    disconnectedPartySSI.PrintXML(os, "disconnectedPartySSI");

    callID.PrintXML(os, "callID");

    disconnectCause.PrintXML(os, "disconnectCause");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Intercept_Disconnect::PrintXML


void MON_Intercept_Disconnect_Ack::Init(void)
{
}


int MON_Intercept_Disconnect_Ack::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	disconnectedPartySSI.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	disconnectCause.checkConstraints(pConstraintFails);

	return 0;
}


void MON_Intercept_Disconnect_Ack::Clear()
{
  disconnectedPartySSI.Clear();
}

MON_Intercept_Disconnect_Ack::MON_Intercept_Disconnect_Ack(const MON_Intercept_Disconnect_Ack &that)
{
   Init();
   *this = that;
}
AsnType *MON_Intercept_Disconnect_Ack::Clone() const
{
  return new MON_Intercept_Disconnect_Ack(*this);
}

MON_Intercept_Disconnect_Ack &MON_Intercept_Disconnect_Ack::operator = (const MON_Intercept_Disconnect_Ack &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    disconnectedPartySSI = that.disconnectedPartySSI;
    callID = that.callID;
    disconnectCause = that.disconnectCause;
  }

  return *this;
}

AsnLen
MON_Intercept_Disconnect_Ack::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = disconnectCause.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = disconnectedPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_Intercept_Disconnect_Ack::BEncContent


void MON_Intercept_Disconnect_Ack::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Disconnect_Ack::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    disconnectedPartySSI.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    disconnectCause.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_Intercept_Disconnect_Ack::BDecContent

AsnLen MON_Intercept_Disconnect_Ack::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 90);
  return l;
}

void MON_Intercept_Disconnect_Ack::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_Intercept_Disconnect_Ack::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 90))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_Intercept_Disconnect_Ack::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectedPartySSI ";
	disconnectedPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "disconnectCause ";
	disconnectCause.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_Intercept_Disconnect_Ack::Print()

void MON_Intercept_Disconnect_Ack::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    disconnectedPartySSI.PrintXML(os, "disconnectedPartySSI");

    callID.PrintXML(os, "callID");

    disconnectCause.PrintXML(os, "disconnectCause");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_Intercept_Disconnect_Ack::PrintXML


void MON_TxInterrupt::Init(void)
{
  txReqPermission = NULL;
  encryption = NULL;
  tpiRestriction = NULL;
}


int MON_TxInterrupt::checkConstraints(ConstraintFailList* pConstraintFails) const{
	monHandle.checkConstraints(pConstraintFails);

	monMessageID.checkConstraints(pConstraintFails);

	callPartySSI.checkConstraints(pConstraintFails);

	transmittingParty.checkConstraints(pConstraintFails);

	callID.checkConstraints(pConstraintFails);

	txGrant.checkConstraints(pConstraintFails);

	if (txReqPermission != NULL)
		txReqPermission->checkConstraints(pConstraintFails);

	if (encryption != NULL)
		encryption->checkConstraints(pConstraintFails);

	if (tpiRestriction != NULL)
		tpiRestriction->checkConstraints(pConstraintFails);

	return 0;
}


void MON_TxInterrupt::Clear()
{
  callPartySSI.Clear();
  transmittingParty.Clear();
  if(txReqPermission)
    delete txReqPermission;
  txReqPermission = NULL;
  if(encryption)
    delete encryption;
  encryption = NULL;
  if(tpiRestriction)
    delete tpiRestriction;
  tpiRestriction = NULL;
}

MON_TxInterrupt::MON_TxInterrupt(const MON_TxInterrupt &that)
{
   Init();
   *this = that;
}
AsnType *MON_TxInterrupt::Clone() const
{
  return new MON_TxInterrupt(*this);
}

MON_TxInterrupt &MON_TxInterrupt::operator = (const MON_TxInterrupt &that)
{
  if (this != &that)
  {
    Clear();
    monHandle = that.monHandle;
    monMessageID = that.monMessageID;
    callPartySSI = that.callPartySSI;
    transmittingParty = that.transmittingParty;
    callID = that.callID;
    txGrant = that.txGrant;
    if (that.txReqPermission)
    {
      if (!txReqPermission)
        txReqPermission = new AsnBool;
      *txReqPermission = *that.txReqPermission;
    }
    else
    {
      delete txReqPermission;
      txReqPermission = NULL;
    }
    if (that.encryption)
    {
      if (!encryption)
        encryption = new AsnBool;
      *encryption = *that.encryption;
    }
    else
    {
      delete encryption;
      encryption = NULL;
    }
    if (that.tpiRestriction)
    {
      if (!tpiRestriction)
        tpiRestriction = new CliType;
      *tpiRestriction = *that.tpiRestriction;
    }
    else
    {
      delete tpiRestriction;
      tpiRestriction = NULL;
    }
  }

  return *this;
}

AsnLen
MON_TxInterrupt::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (tpiRestriction))
  {
    l = tpiRestriction->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 8);
    totalLen += l;
  }

  if (NOT_NULL (encryption))
  {
    l = encryption->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 7);
    totalLen += l;
  }

  if (NOT_NULL (txReqPermission))
  {
    l = txReqPermission->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 6);
    totalLen += l;
  }

    l = txGrant.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 5);
    totalLen += l;

    l = callID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;

    l = transmittingParty.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;

    l = callPartySSI.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = monMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = monHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // MON_TxInterrupt::BEncContent


void MON_TxInterrupt::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" MON_TxInterrupt::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    monMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callPartySSI.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    transmittingParty.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    callID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 5)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    txGrant.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 6)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  txReqPermission = new AsnBool;
    txReqPermission->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 7)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  encryption = new AsnBool;
    encryption->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 8)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  tpiRestriction = new CliType;
    tpiRestriction->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // MON_TxInterrupt::BDecContent

AsnLen MON_TxInterrupt::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 96);
  return l;
}

void MON_TxInterrupt::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" MON_TxInterrupt::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 96))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void MON_TxInterrupt::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "monHandle ";
	monHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "monMessageID ";
	monMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callPartySSI ";
	callPartySSI.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "transmittingParty ";
	transmittingParty.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "callID ";
	callID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "txGrant ";
	txGrant.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (txReqPermission))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "txReqPermission ";
		txReqPermission->Print(os, indent);
	}

	if (NOT_NULL (encryption))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "encryption ";
		encryption->Print(os, indent);
	}

	if (NOT_NULL (tpiRestriction))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "tpiRestriction ";
		tpiRestriction->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of MON_TxInterrupt::Print()

void MON_TxInterrupt::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    monHandle.PrintXML(os, "monHandle");

    monMessageID.PrintXML(os, "monMessageID");

    callPartySSI.PrintXML(os, "callPartySSI");

    transmittingParty.PrintXML(os, "transmittingParty");

    callID.PrintXML(os, "callID");

    txGrant.PrintXML(os, "txGrant");

  if (NOT_NULL (txReqPermission))
  {
    txReqPermission->PrintXML(os, "txReqPermission");
  }

  if (NOT_NULL (encryption))
  {
    encryption->PrintXML(os, "encryption");
  }

  if (NOT_NULL (tpiRestriction))
  {
    tpiRestriction->PrintXML(os, "tpiRestriction");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // MON_TxInterrupt::PrintXML


void RSM_ResourceMonitoring_Req::Init(void)
{
  rsmHandle = NULL;
}


int RSM_ResourceMonitoring_Req::checkConstraints(ConstraintFailList* pConstraintFails) const{
	systemConnectionReq.checkConstraints(pConstraintFails);

	resourceLoadReq.checkConstraints(pConstraintFails);

	lineResourceStateReq.checkConstraints(pConstraintFails);

	stateChangeIndReq.checkConstraints(pConstraintFails);

	if (rsmHandle != NULL)
		rsmHandle->checkConstraints(pConstraintFails);

	return 0;
}


void RSM_ResourceMonitoring_Req::Clear()
{
  if(rsmHandle)
    delete rsmHandle;
  rsmHandle = NULL;
}

RSM_ResourceMonitoring_Req::RSM_ResourceMonitoring_Req(const RSM_ResourceMonitoring_Req &that)
{
   Init();
   *this = that;
}
AsnType *RSM_ResourceMonitoring_Req::Clone() const
{
  return new RSM_ResourceMonitoring_Req(*this);
}

RSM_ResourceMonitoring_Req &RSM_ResourceMonitoring_Req::operator = (const RSM_ResourceMonitoring_Req &that)
{
  if (this != &that)
  {
    Clear();
    systemConnectionReq = that.systemConnectionReq;
    resourceLoadReq = that.resourceLoadReq;
    lineResourceStateReq = that.lineResourceStateReq;
    stateChangeIndReq = that.stateChangeIndReq;
    if (that.rsmHandle)
    {
      if (!rsmHandle)
        rsmHandle = new AsnInt;
      *rsmHandle = *that.rsmHandle;
    }
    else
    {
      delete rsmHandle;
      rsmHandle = NULL;
    }
  }

  return *this;
}

AsnLen
RSM_ResourceMonitoring_Req::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (rsmHandle))
  {
    l = rsmHandle->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 4);
    totalLen += l;
  }

    l = stateChangeIndReq.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;

    l = lineResourceStateReq.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;

    l = resourceLoadReq.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = systemConnectionReq.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // RSM_ResourceMonitoring_Req::BEncContent


void RSM_ResourceMonitoring_Req::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" RSM_ResourceMonitoring_Req::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    systemConnectionReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    resourceLoadReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    lineResourceStateReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    stateChangeIndReq.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 4)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  rsmHandle = new AsnInt;
    rsmHandle->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // RSM_ResourceMonitoring_Req::BDecContent

AsnLen RSM_ResourceMonitoring_Req::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 100);
  return l;
}

void RSM_ResourceMonitoring_Req::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" RSM_ResourceMonitoring_Req::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 100))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void RSM_ResourceMonitoring_Req::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "systemConnectionReq ";
	systemConnectionReq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "resourceLoadReq ";
	resourceLoadReq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "lineResourceStateReq ";
	lineResourceStateReq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "stateChangeIndReq ";
	stateChangeIndReq.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (rsmHandle))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "rsmHandle ";
		rsmHandle->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of RSM_ResourceMonitoring_Req::Print()

void RSM_ResourceMonitoring_Req::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    systemConnectionReq.PrintXML(os, "systemConnectionReq");

    resourceLoadReq.PrintXML(os, "resourceLoadReq");

    lineResourceStateReq.PrintXML(os, "lineResourceStateReq");

    stateChangeIndReq.PrintXML(os, "stateChangeIndReq");

  if (NOT_NULL (rsmHandle))
  {
    rsmHandle->PrintXML(os, "rsmHandle");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // RSM_ResourceMonitoring_Req::PrintXML


void RSM_ResourceState_Ind::Init(void)
{
  connectionState = NULL;
  resourceLoad = NULL;
  lineResourceState = NULL;
}


int RSM_ResourceState_Ind::checkConstraints(ConstraintFailList* pConstraintFails) const{
	rsmHandle.checkConstraints(pConstraintFails);

	if (connectionState != NULL)
		connectionState->checkConstraints(pConstraintFails);

	if (resourceLoad != NULL)
		resourceLoad->checkConstraints(pConstraintFails);

	if (lineResourceState != NULL)
		lineResourceState->checkConstraints(pConstraintFails);

	return 0;
}


void RSM_ResourceState_Ind::Clear()
{
  if(connectionState)
    delete connectionState;
  connectionState = NULL;
  if(resourceLoad)
    delete resourceLoad;
  resourceLoad = NULL;
  if(lineResourceState)
    delete lineResourceState;
  lineResourceState = NULL;
}

RSM_ResourceState_Ind::RSM_ResourceState_Ind(const RSM_ResourceState_Ind &that)
{
   Init();
   *this = that;
}
AsnType *RSM_ResourceState_Ind::Clone() const
{
  return new RSM_ResourceState_Ind(*this);
}

RSM_ResourceState_Ind &RSM_ResourceState_Ind::operator = (const RSM_ResourceState_Ind &that)
{
  if (this != &that)
  {
    Clear();
    rsmHandle = that.rsmHandle;
    if (that.connectionState)
    {
      if (!connectionState)
        connectionState = new RSM_ResourceState_IndSeqOf;
      *connectionState = *that.connectionState;
    }
    else
    {
      delete connectionState;
      connectionState = NULL;
    }
    if (that.resourceLoad)
    {
      if (!resourceLoad)
        resourceLoad = new RSM_ResourceState_IndSeqOf1;
      *resourceLoad = *that.resourceLoad;
    }
    else
    {
      delete resourceLoad;
      resourceLoad = NULL;
    }
    if (that.lineResourceState)
    {
      if (!lineResourceState)
        lineResourceState = new RSM_ResourceState_IndSeqOf2;
      *lineResourceState = *that.lineResourceState;
    }
    else
    {
      delete lineResourceState;
      lineResourceState = NULL;
    }
  }

  return *this;
}

AsnLen
RSM_ResourceState_Ind::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if (NOT_NULL (lineResourceState))
  {
    l = lineResourceState->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;
  }

  if (NOT_NULL (resourceLoad))
  {
    l = resourceLoad->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

  if (NOT_NULL (connectionState))
  {
    l = connectionState->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;
  }

    l = rsmHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // RSM_ResourceState_Ind::BEncContent


void RSM_ResourceState_Ind::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" RSM_ResourceState_Ind::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    rsmHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  connectionState = new RSM_ResourceState_IndSeqOf;
    connectionState->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  resourceLoad = new RSM_ResourceState_IndSeqOf1;
    resourceLoad->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  lineResourceState = new RSM_ResourceState_IndSeqOf2;
    lineResourceState->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // RSM_ResourceState_Ind::BDecContent

AsnLen RSM_ResourceState_Ind::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag2 (_b, APPL, CONS, 101);
  return l;
}

void RSM_ResourceState_Ind::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" RSM_ResourceState_Ind::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 101))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void RSM_ResourceState_Ind::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "rsmHandle ";
	rsmHandle.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (connectionState))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "connectionState ";
		connectionState->Print(os, indent);
	}

	if (NOT_NULL (resourceLoad))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "resourceLoad ";
		resourceLoad->Print(os, indent);
	}

	if (NOT_NULL (lineResourceState))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "lineResourceState ";
		lineResourceState->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of RSM_ResourceState_Ind::Print()

void RSM_ResourceState_Ind::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    rsmHandle.PrintXML(os, "rsmHandle");

  if (NOT_NULL (connectionState))
  {
    connectionState->PrintXML(os, "connectionState");
  }

  if (NOT_NULL (resourceLoad))
  {
    resourceLoad->PrintXML(os, "resourceLoad");
  }

  if (NOT_NULL (lineResourceState))
  {
    lineResourceState->PrintXML(os, "lineResourceState");
  }

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // RSM_ResourceState_Ind::PrintXML


ACAPI_PDUChoice::ACAPI_PDUChoice(const ACAPI_PDUChoice &that)
{
   Init();
   *this = that;
}
void ACAPI_PDUChoice::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = name_ACAPI_OpenServiceCid;
  name_ACAPI_OpenService = NULL;
}


int ACAPI_PDUChoice::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (name_ACAPI_OpenService != NULL)
		name_ACAPI_OpenService->checkConstraints(pConstraintFails);

	if (name_ACAPI_OpenService_Ack != NULL)
		name_ACAPI_OpenService_Ack->checkConstraints(pConstraintFails);

	if (name_ACAPI_CloseService != NULL)
		name_ACAPI_CloseService->checkConstraints(pConstraintFails);

	if (name_ACAPI_CloseService_Ack != NULL)
		name_ACAPI_CloseService_Ack->checkConstraints(pConstraintFails);

	if (name_ACAPI_Authorization_Req != NULL)
		name_ACAPI_Authorization_Req->checkConstraints(pConstraintFails);

	if (name_ACAPI_Authorization != NULL)
		name_ACAPI_Authorization->checkConstraints(pConstraintFails);

	if (name_ACAPI_Message_Ack != NULL)
		name_ACAPI_Message_Ack->checkConstraints(pConstraintFails);

	if (name_ACAPI_Error_Info != NULL)
		name_ACAPI_Error_Info->checkConstraints(pConstraintFails);

	if (name_SDS_Data != NULL)
		name_SDS_Data->checkConstraints(pConstraintFails);

	if (name_SDS_Data_Ack != NULL)
		name_SDS_Data_Ack->checkConstraints(pConstraintFails);

	if (name_CC_Setup_Req != NULL)
		name_CC_Setup_Req->checkConstraints(pConstraintFails);

	if (name_CC_SetupInclude_Req != NULL)
		name_CC_SetupInclude_Req->checkConstraints(pConstraintFails);

	if (name_CC_Setup_Ind != NULL)
		name_CC_Setup_Ind->checkConstraints(pConstraintFails);

	if (name_CC_Setup_Ack != NULL)
		name_CC_Setup_Ack->checkConstraints(pConstraintFails);

	if (name_CC_Information != NULL)
		name_CC_Information->checkConstraints(pConstraintFails);

	if (name_CC_Connect_Req != NULL)
		name_CC_Connect_Req->checkConstraints(pConstraintFails);

	if (name_CC_Connect_Ind != NULL)
		name_CC_Connect_Ind->checkConstraints(pConstraintFails);

	if (name_CC_Connect_Ack != NULL)
		name_CC_Connect_Ack->checkConstraints(pConstraintFails);

	if (name_CC_TxDemand != NULL)
		name_CC_TxDemand->checkConstraints(pConstraintFails);

	if (name_CC_TxGrant != NULL)
		name_CC_TxGrant->checkConstraints(pConstraintFails);

	if (name_CC_TxCeased != NULL)
		name_CC_TxCeased->checkConstraints(pConstraintFails);

	if (name_CC_TxInterrupt != NULL)
		name_CC_TxInterrupt->checkConstraints(pConstraintFails);

	if (name_CC_TxWait_Ind != NULL)
		name_CC_TxWait_Ind->checkConstraints(pConstraintFails);

	if (name_CC_TxWait_Req != NULL)
		name_CC_TxWait_Req->checkConstraints(pConstraintFails);

	if (name_CC_TxWait_Ack != NULL)
		name_CC_TxWait_Ack->checkConstraints(pConstraintFails);

	if (name_CC_TxContinue_Ind != NULL)
		name_CC_TxContinue_Ind->checkConstraints(pConstraintFails);

	if (name_CC_TxContinue_Req != NULL)
		name_CC_TxContinue_Req->checkConstraints(pConstraintFails);

	if (name_CC_TxContinue_Ack != NULL)
		name_CC_TxContinue_Ack->checkConstraints(pConstraintFails);

	if (name_CC_Disconnect != NULL)
		name_CC_Disconnect->checkConstraints(pConstraintFails);

	if (name_CC_Disconnect_Ack != NULL)
		name_CC_Disconnect_Ack->checkConstraints(pConstraintFails);

	if (name_CC_DialupLine_Info != NULL)
		name_CC_DialupLine_Info->checkConstraints(pConstraintFails);

	if (name_CC_ForcedCallEnd != NULL)
		name_CC_ForcedCallEnd->checkConstraints(pConstraintFails);

	if (name_CC_ForcedCallEnd_Ack != NULL)
		name_CC_ForcedCallEnd_Ack->checkConstraints(pConstraintFails);

	if (name_CC_CancelInclude != NULL)
		name_CC_CancelInclude->checkConstraints(pConstraintFails);

	if (name_SS_GroupAttach != NULL)
		name_SS_GroupAttach->checkConstraints(pConstraintFails);

	if (name_SS_GroupAttach_Ack != NULL)
		name_SS_GroupAttach_Ack->checkConstraints(pConstraintFails);

	if (name_SS_GroupDetach != NULL)
		name_SS_GroupDetach->checkConstraints(pConstraintFails);

	if (name_SS_GroupDetach_Ack != NULL)
		name_SS_GroupDetach_Ack->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupAdd != NULL)
		name_SS_DynGroupAdd->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupDel != NULL)
		name_SS_DynGroupDel->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupAdd_Ack != NULL)
		name_SS_DynGroupAdd_Ack->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupDel_Ack != NULL)
		name_SS_DynGroupDel_Ack->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupInterrogate != NULL)
		name_SS_DynGroupInterrogate->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupInterrogate_Ack != NULL)
		name_SS_DynGroupInterrogate_Ack->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupAssign != NULL)
		name_SS_DynGroupAssign->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupAssign_Ack != NULL)
		name_SS_DynGroupAssign_Ack->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupDeassign != NULL)
		name_SS_DynGroupDeassign->checkConstraints(pConstraintFails);

	if (name_SS_DynGroupDeassign_Ack != NULL)
		name_SS_DynGroupDeassign_Ack->checkConstraints(pConstraintFails);

	if (name_SS_CallForwardActivate != NULL)
		name_SS_CallForwardActivate->checkConstraints(pConstraintFails);

	if (name_SS_CallForwardActivate_Ack != NULL)
		name_SS_CallForwardActivate_Ack->checkConstraints(pConstraintFails);

	if (name_SS_CallForwardDeactivate != NULL)
		name_SS_CallForwardDeactivate->checkConstraints(pConstraintFails);

	if (name_SS_CallForwardDeactivate_Ack != NULL)
		name_SS_CallForwardDeactivate_Ack->checkConstraints(pConstraintFails);

	if (name_SS_CallForwardCancelAll != NULL)
		name_SS_CallForwardCancelAll->checkConstraints(pConstraintFails);

	if (name_SS_CallForwardCancel_Ack != NULL)
		name_SS_CallForwardCancel_Ack->checkConstraints(pConstraintFails);

	if (name_SS_CallForwardInterrogate != NULL)
		name_SS_CallForwardInterrogate->checkConstraints(pConstraintFails);

	if (name_SS_CallForwardInterrogate_Ack != NULL)
		name_SS_CallForwardInterrogate_Ack->checkConstraints(pConstraintFails);

	if (name_SS_ObjectIdentityAssign != NULL)
		name_SS_ObjectIdentityAssign->checkConstraints(pConstraintFails);

	if (name_SS_ObjectIdentityAssign_Ack != NULL)
		name_SS_ObjectIdentityAssign_Ack->checkConstraints(pConstraintFails);

	if (name_SS_ObjectIdentityDeassign != NULL)
		name_SS_ObjectIdentityDeassign->checkConstraints(pConstraintFails);

	if (name_SS_ObjectIdentityDeassign_Ack != NULL)
		name_SS_ObjectIdentityDeassign_Ack->checkConstraints(pConstraintFails);

	if (name_SS_ObjectIdentityCancelGateway != NULL)
		name_SS_ObjectIdentityCancelGateway->checkConstraints(pConstraintFails);

	if (name_SS_ObjectIdentityCancelGateway_Ack != NULL)
		name_SS_ObjectIdentityCancelGateway_Ack->checkConstraints(pConstraintFails);

	if (name_SS_ObjectIdentityInterrogate != NULL)
		name_SS_ObjectIdentityInterrogate->checkConstraints(pConstraintFails);

	if (name_SS_ObjectIdentityInterrogate_Ack != NULL)
		name_SS_ObjectIdentityInterrogate_Ack->checkConstraints(pConstraintFails);

	if (name_MON_Monitoring_Req != NULL)
		name_MON_Monitoring_Req->checkConstraints(pConstraintFails);

	if (name_MON_Monitoring_Ack != NULL)
		name_MON_Monitoring_Ack->checkConstraints(pConstraintFails);

	if (name_MON_FleetMonitoring_Req != NULL)
		name_MON_FleetMonitoring_Req->checkConstraints(pConstraintFails);

	if (name_MON_FleetMonitoring_Ack != NULL)
		name_MON_FleetMonitoring_Ack->checkConstraints(pConstraintFails);

	if (name_MON_Data_Ack != NULL)
		name_MON_Data_Ack->checkConstraints(pConstraintFails);

	if (name_MON_Close != NULL)
		name_MON_Close->checkConstraints(pConstraintFails);

	if (name_MON_Close_Ack != NULL)
		name_MON_Close_Ack->checkConstraints(pConstraintFails);

	if (name_MON_LocationUpdate != NULL)
		name_MON_LocationUpdate->checkConstraints(pConstraintFails);

	if (name_MON_LocationDetach != NULL)
		name_MON_LocationDetach->checkConstraints(pConstraintFails);

	if (name_MON_SDS_Data != NULL)
		name_MON_SDS_Data->checkConstraints(pConstraintFails);

	if (name_MON_SDS_Ack != NULL)
		name_MON_SDS_Ack->checkConstraints(pConstraintFails);

	if (name_MON_CC_Information != NULL)
		name_MON_CC_Information->checkConstraints(pConstraintFails);

	if (name_MON_TxDemand != NULL)
		name_MON_TxDemand->checkConstraints(pConstraintFails);

	if (name_MON_TxCeased != NULL)
		name_MON_TxCeased->checkConstraints(pConstraintFails);

	if (name_MON_TxGrant != NULL)
		name_MON_TxGrant->checkConstraints(pConstraintFails);

	if (name_MON_Disconnect != NULL)
		name_MON_Disconnect->checkConstraints(pConstraintFails);

	if (name_MON_Intercept_Req != NULL)
		name_MON_Intercept_Req->checkConstraints(pConstraintFails);

	if (name_MON_Intercept_Ack != NULL)
		name_MON_Intercept_Ack->checkConstraints(pConstraintFails);

	if (name_MON_Intercept_Connect != NULL)
		name_MON_Intercept_Connect->checkConstraints(pConstraintFails);

	if (name_MON_Intercept_Disconnect != NULL)
		name_MON_Intercept_Disconnect->checkConstraints(pConstraintFails);

	if (name_MON_Intercept_Disconnect_Ack != NULL)
		name_MON_Intercept_Disconnect_Ack->checkConstraints(pConstraintFails);

	if (name_MON_ForcedCallEnd != NULL)
		name_MON_ForcedCallEnd->checkConstraints(pConstraintFails);

	if (name_MON_ForcedCallEnd_Ack != NULL)
		name_MON_ForcedCallEnd_Ack->checkConstraints(pConstraintFails);

	if (name_MON_Uplink_TxDemand != NULL)
		name_MON_Uplink_TxDemand->checkConstraints(pConstraintFails);

	if (name_MON_Uplink_TxCeased != NULL)
		name_MON_Uplink_TxCeased->checkConstraints(pConstraintFails);

	if (name_MON_TxInterrupt != NULL)
		name_MON_TxInterrupt->checkConstraints(pConstraintFails);

	if (name_RSM_ResourceMonitoring_Req != NULL)
		name_RSM_ResourceMonitoring_Req->checkConstraints(pConstraintFails);

	if (name_RSM_ResourceState_Ind != NULL)
		name_RSM_ResourceState_Ind->checkConstraints(pConstraintFails);

	if (name_RSM_ResourceMonitoring_Close != NULL)
		name_RSM_ResourceMonitoring_Close->checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_PDUChoice::Clear()
{
  switch (choiceId)
  {
    case name_ACAPI_OpenServiceCid:
      delete name_ACAPI_OpenService;
      name_ACAPI_OpenService = NULL;
      break;
    case name_ACAPI_OpenService_AckCid:
      delete name_ACAPI_OpenService_Ack;
      name_ACAPI_OpenService_Ack = NULL;
      break;
    case name_ACAPI_CloseServiceCid:
      delete name_ACAPI_CloseService;
      name_ACAPI_CloseService = NULL;
      break;
    case name_ACAPI_CloseService_AckCid:
      delete name_ACAPI_CloseService_Ack;
      name_ACAPI_CloseService_Ack = NULL;
      break;
    case name_ACAPI_Authorization_ReqCid:
      delete name_ACAPI_Authorization_Req;
      name_ACAPI_Authorization_Req = NULL;
      break;
    case name_ACAPI_AuthorizationCid:
      delete name_ACAPI_Authorization;
      name_ACAPI_Authorization = NULL;
      break;
    case name_ACAPI_Message_AckCid:
      delete name_ACAPI_Message_Ack;
      name_ACAPI_Message_Ack = NULL;
      break;
    case name_ACAPI_Error_InfoCid:
      delete name_ACAPI_Error_Info;
      name_ACAPI_Error_Info = NULL;
      break;
    case name_SDS_DataCid:
      delete name_SDS_Data;
      name_SDS_Data = NULL;
      break;
    case name_SDS_Data_AckCid:
      delete name_SDS_Data_Ack;
      name_SDS_Data_Ack = NULL;
      break;
    case name_CC_Setup_ReqCid:
      delete name_CC_Setup_Req;
      name_CC_Setup_Req = NULL;
      break;
    case name_CC_SetupInclude_ReqCid:
      delete name_CC_SetupInclude_Req;
      name_CC_SetupInclude_Req = NULL;
      break;
    case name_CC_Setup_IndCid:
      delete name_CC_Setup_Ind;
      name_CC_Setup_Ind = NULL;
      break;
    case name_CC_Setup_AckCid:
      delete name_CC_Setup_Ack;
      name_CC_Setup_Ack = NULL;
      break;
    case name_CC_InformationCid:
      delete name_CC_Information;
      name_CC_Information = NULL;
      break;
    case name_CC_Connect_ReqCid:
      delete name_CC_Connect_Req;
      name_CC_Connect_Req = NULL;
      break;
    case name_CC_Connect_IndCid:
      delete name_CC_Connect_Ind;
      name_CC_Connect_Ind = NULL;
      break;
    case name_CC_Connect_AckCid:
      delete name_CC_Connect_Ack;
      name_CC_Connect_Ack = NULL;
      break;
    case name_CC_TxDemandCid:
      delete name_CC_TxDemand;
      name_CC_TxDemand = NULL;
      break;
    case name_CC_TxGrantCid:
      delete name_CC_TxGrant;
      name_CC_TxGrant = NULL;
      break;
    case name_CC_TxCeasedCid:
      delete name_CC_TxCeased;
      name_CC_TxCeased = NULL;
      break;
    case name_CC_TxInterruptCid:
      delete name_CC_TxInterrupt;
      name_CC_TxInterrupt = NULL;
      break;
    case name_CC_TxWait_IndCid:
      delete name_CC_TxWait_Ind;
      name_CC_TxWait_Ind = NULL;
      break;
    case name_CC_TxWait_ReqCid:
      delete name_CC_TxWait_Req;
      name_CC_TxWait_Req = NULL;
      break;
    case name_CC_TxWait_AckCid:
      delete name_CC_TxWait_Ack;
      name_CC_TxWait_Ack = NULL;
      break;
    case name_CC_TxContinue_IndCid:
      delete name_CC_TxContinue_Ind;
      name_CC_TxContinue_Ind = NULL;
      break;
    case name_CC_TxContinue_ReqCid:
      delete name_CC_TxContinue_Req;
      name_CC_TxContinue_Req = NULL;
      break;
    case name_CC_TxContinue_AckCid:
      delete name_CC_TxContinue_Ack;
      name_CC_TxContinue_Ack = NULL;
      break;
    case name_CC_DisconnectCid:
      delete name_CC_Disconnect;
      name_CC_Disconnect = NULL;
      break;
    case name_CC_Disconnect_AckCid:
      delete name_CC_Disconnect_Ack;
      name_CC_Disconnect_Ack = NULL;
      break;
    case name_CC_DialupLine_InfoCid:
      delete name_CC_DialupLine_Info;
      name_CC_DialupLine_Info = NULL;
      break;
    case name_CC_ForcedCallEndCid:
      delete name_CC_ForcedCallEnd;
      name_CC_ForcedCallEnd = NULL;
      break;
    case name_CC_ForcedCallEnd_AckCid:
      delete name_CC_ForcedCallEnd_Ack;
      name_CC_ForcedCallEnd_Ack = NULL;
      break;
    case name_CC_CancelIncludeCid:
      delete name_CC_CancelInclude;
      name_CC_CancelInclude = NULL;
      break;
    case name_SS_GroupAttachCid:
      delete name_SS_GroupAttach;
      name_SS_GroupAttach = NULL;
      break;
    case name_SS_GroupAttach_AckCid:
      delete name_SS_GroupAttach_Ack;
      name_SS_GroupAttach_Ack = NULL;
      break;
    case name_SS_GroupDetachCid:
      delete name_SS_GroupDetach;
      name_SS_GroupDetach = NULL;
      break;
    case name_SS_GroupDetach_AckCid:
      delete name_SS_GroupDetach_Ack;
      name_SS_GroupDetach_Ack = NULL;
      break;
    case name_SS_DynGroupAddCid:
      delete name_SS_DynGroupAdd;
      name_SS_DynGroupAdd = NULL;
      break;
    case name_SS_DynGroupDelCid:
      delete name_SS_DynGroupDel;
      name_SS_DynGroupDel = NULL;
      break;
    case name_SS_DynGroupAdd_AckCid:
      delete name_SS_DynGroupAdd_Ack;
      name_SS_DynGroupAdd_Ack = NULL;
      break;
    case name_SS_DynGroupDel_AckCid:
      delete name_SS_DynGroupDel_Ack;
      name_SS_DynGroupDel_Ack = NULL;
      break;
    case name_SS_DynGroupInterrogateCid:
      delete name_SS_DynGroupInterrogate;
      name_SS_DynGroupInterrogate = NULL;
      break;
    case name_SS_DynGroupInterrogate_AckCid:
      delete name_SS_DynGroupInterrogate_Ack;
      name_SS_DynGroupInterrogate_Ack = NULL;
      break;
    case name_SS_DynGroupAssignCid:
      delete name_SS_DynGroupAssign;
      name_SS_DynGroupAssign = NULL;
      break;
    case name_SS_DynGroupAssign_AckCid:
      delete name_SS_DynGroupAssign_Ack;
      name_SS_DynGroupAssign_Ack = NULL;
      break;
    case name_SS_DynGroupDeassignCid:
      delete name_SS_DynGroupDeassign;
      name_SS_DynGroupDeassign = NULL;
      break;
    case name_SS_DynGroupDeassign_AckCid:
      delete name_SS_DynGroupDeassign_Ack;
      name_SS_DynGroupDeassign_Ack = NULL;
      break;
    case name_SS_CallForwardActivateCid:
      delete name_SS_CallForwardActivate;
      name_SS_CallForwardActivate = NULL;
      break;
    case name_SS_CallForwardActivate_AckCid:
      delete name_SS_CallForwardActivate_Ack;
      name_SS_CallForwardActivate_Ack = NULL;
      break;
    case name_SS_CallForwardDeactivateCid:
      delete name_SS_CallForwardDeactivate;
      name_SS_CallForwardDeactivate = NULL;
      break;
    case name_SS_CallForwardDeactivate_AckCid:
      delete name_SS_CallForwardDeactivate_Ack;
      name_SS_CallForwardDeactivate_Ack = NULL;
      break;
    case name_SS_CallForwardCancelAllCid:
      delete name_SS_CallForwardCancelAll;
      name_SS_CallForwardCancelAll = NULL;
      break;
    case name_SS_CallForwardCancel_AckCid:
      delete name_SS_CallForwardCancel_Ack;
      name_SS_CallForwardCancel_Ack = NULL;
      break;
    case name_SS_CallForwardInterrogateCid:
      delete name_SS_CallForwardInterrogate;
      name_SS_CallForwardInterrogate = NULL;
      break;
    case name_SS_CallForwardInterrogate_AckCid:
      delete name_SS_CallForwardInterrogate_Ack;
      name_SS_CallForwardInterrogate_Ack = NULL;
      break;
    case name_SS_ObjectIdentityAssignCid:
      delete name_SS_ObjectIdentityAssign;
      name_SS_ObjectIdentityAssign = NULL;
      break;
    case name_SS_ObjectIdentityAssign_AckCid:
      delete name_SS_ObjectIdentityAssign_Ack;
      name_SS_ObjectIdentityAssign_Ack = NULL;
      break;
    case name_SS_ObjectIdentityDeassignCid:
      delete name_SS_ObjectIdentityDeassign;
      name_SS_ObjectIdentityDeassign = NULL;
      break;
    case name_SS_ObjectIdentityDeassign_AckCid:
      delete name_SS_ObjectIdentityDeassign_Ack;
      name_SS_ObjectIdentityDeassign_Ack = NULL;
      break;
    case name_SS_ObjectIdentityCancelGatewayCid:
      delete name_SS_ObjectIdentityCancelGateway;
      name_SS_ObjectIdentityCancelGateway = NULL;
      break;
    case name_SS_ObjectIdentityCancelGateway_AckCid:
      delete name_SS_ObjectIdentityCancelGateway_Ack;
      name_SS_ObjectIdentityCancelGateway_Ack = NULL;
      break;
    case name_SS_ObjectIdentityInterrogateCid:
      delete name_SS_ObjectIdentityInterrogate;
      name_SS_ObjectIdentityInterrogate = NULL;
      break;
    case name_SS_ObjectIdentityInterrogate_AckCid:
      delete name_SS_ObjectIdentityInterrogate_Ack;
      name_SS_ObjectIdentityInterrogate_Ack = NULL;
      break;
    case name_MON_Monitoring_ReqCid:
      delete name_MON_Monitoring_Req;
      name_MON_Monitoring_Req = NULL;
      break;
    case name_MON_Monitoring_AckCid:
      delete name_MON_Monitoring_Ack;
      name_MON_Monitoring_Ack = NULL;
      break;
    case name_MON_FleetMonitoring_ReqCid:
      delete name_MON_FleetMonitoring_Req;
      name_MON_FleetMonitoring_Req = NULL;
      break;
    case name_MON_FleetMonitoring_AckCid:
      delete name_MON_FleetMonitoring_Ack;
      name_MON_FleetMonitoring_Ack = NULL;
      break;
    case name_MON_Data_AckCid:
      delete name_MON_Data_Ack;
      name_MON_Data_Ack = NULL;
      break;
    case name_MON_CloseCid:
      delete name_MON_Close;
      name_MON_Close = NULL;
      break;
    case name_MON_Close_AckCid:
      delete name_MON_Close_Ack;
      name_MON_Close_Ack = NULL;
      break;
    case name_MON_LocationUpdateCid:
      delete name_MON_LocationUpdate;
      name_MON_LocationUpdate = NULL;
      break;
    case name_MON_LocationDetachCid:
      delete name_MON_LocationDetach;
      name_MON_LocationDetach = NULL;
      break;
    case name_MON_SDS_DataCid:
      delete name_MON_SDS_Data;
      name_MON_SDS_Data = NULL;
      break;
    case name_MON_SDS_AckCid:
      delete name_MON_SDS_Ack;
      name_MON_SDS_Ack = NULL;
      break;
    case name_MON_CC_InformationCid:
      delete name_MON_CC_Information;
      name_MON_CC_Information = NULL;
      break;
    case name_MON_TxDemandCid:
      delete name_MON_TxDemand;
      name_MON_TxDemand = NULL;
      break;
    case name_MON_TxCeasedCid:
      delete name_MON_TxCeased;
      name_MON_TxCeased = NULL;
      break;
    case name_MON_TxGrantCid:
      delete name_MON_TxGrant;
      name_MON_TxGrant = NULL;
      break;
    case name_MON_DisconnectCid:
      delete name_MON_Disconnect;
      name_MON_Disconnect = NULL;
      break;
    case name_MON_Intercept_ReqCid:
      delete name_MON_Intercept_Req;
      name_MON_Intercept_Req = NULL;
      break;
    case name_MON_Intercept_AckCid:
      delete name_MON_Intercept_Ack;
      name_MON_Intercept_Ack = NULL;
      break;
    case name_MON_Intercept_ConnectCid:
      delete name_MON_Intercept_Connect;
      name_MON_Intercept_Connect = NULL;
      break;
    case name_MON_Intercept_DisconnectCid:
      delete name_MON_Intercept_Disconnect;
      name_MON_Intercept_Disconnect = NULL;
      break;
    case name_MON_Intercept_Disconnect_AckCid:
      delete name_MON_Intercept_Disconnect_Ack;
      name_MON_Intercept_Disconnect_Ack = NULL;
      break;
    case name_MON_ForcedCallEndCid:
      delete name_MON_ForcedCallEnd;
      name_MON_ForcedCallEnd = NULL;
      break;
    case name_MON_ForcedCallEnd_AckCid:
      delete name_MON_ForcedCallEnd_Ack;
      name_MON_ForcedCallEnd_Ack = NULL;
      break;
    case name_MON_Uplink_TxDemandCid:
      delete name_MON_Uplink_TxDemand;
      name_MON_Uplink_TxDemand = NULL;
      break;
    case name_MON_Uplink_TxCeasedCid:
      delete name_MON_Uplink_TxCeased;
      name_MON_Uplink_TxCeased = NULL;
      break;
    case name_MON_TxInterruptCid:
      delete name_MON_TxInterrupt;
      name_MON_TxInterrupt = NULL;
      break;
    case name_RSM_ResourceMonitoring_ReqCid:
      delete name_RSM_ResourceMonitoring_Req;
      name_RSM_ResourceMonitoring_Req = NULL;
      break;
    case name_RSM_ResourceState_IndCid:
      delete name_RSM_ResourceState_Ind;
      name_RSM_ResourceState_Ind = NULL;
      break;
    case name_RSM_ResourceMonitoring_CloseCid:
      delete name_RSM_ResourceMonitoring_Close;
      name_RSM_ResourceMonitoring_Close = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *ACAPI_PDUChoice::Clone() const
{
  return new ACAPI_PDUChoice(*this);
}

ACAPI_PDUChoice &ACAPI_PDUChoice::operator = (const ACAPI_PDUChoice &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.name_ACAPI_OpenService != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case name_ACAPI_OpenServiceCid:
           name_ACAPI_OpenService = new ACAPI_OpenService(*that.name_ACAPI_OpenService);
           break;
         case name_ACAPI_OpenService_AckCid:
           name_ACAPI_OpenService_Ack = new ACAPI_OpenService_Ack(*that.name_ACAPI_OpenService_Ack);
           break;
         case name_ACAPI_CloseServiceCid:
           name_ACAPI_CloseService = new ACAPI_CloseService(*that.name_ACAPI_CloseService);
           break;
         case name_ACAPI_CloseService_AckCid:
           name_ACAPI_CloseService_Ack = new ACAPI_CloseService_Ack(*that.name_ACAPI_CloseService_Ack);
           break;
         case name_ACAPI_Authorization_ReqCid:
           name_ACAPI_Authorization_Req = new ACAPI_Authorization_Req(*that.name_ACAPI_Authorization_Req);
           break;
         case name_ACAPI_AuthorizationCid:
           name_ACAPI_Authorization = new ACAPI_Authorization(*that.name_ACAPI_Authorization);
           break;
         case name_ACAPI_Message_AckCid:
           name_ACAPI_Message_Ack = new ACAPI_Message_Ack(*that.name_ACAPI_Message_Ack);
           break;
         case name_ACAPI_Error_InfoCid:
           name_ACAPI_Error_Info = new ACAPI_Error_Info(*that.name_ACAPI_Error_Info);
           break;
         case name_SDS_DataCid:
           name_SDS_Data = new SDS_Data(*that.name_SDS_Data);
           break;
         case name_SDS_Data_AckCid:
           name_SDS_Data_Ack = new SDS_Data_Ack(*that.name_SDS_Data_Ack);
           break;
         case name_CC_Setup_ReqCid:
           name_CC_Setup_Req = new CC_Setup_Req(*that.name_CC_Setup_Req);
           break;
         case name_CC_SetupInclude_ReqCid:
           name_CC_SetupInclude_Req = new CC_SetupInclude_Req(*that.name_CC_SetupInclude_Req);
           break;
         case name_CC_Setup_IndCid:
           name_CC_Setup_Ind = new CC_Setup_Ind(*that.name_CC_Setup_Ind);
           break;
         case name_CC_Setup_AckCid:
           name_CC_Setup_Ack = new CC_Setup_Ack(*that.name_CC_Setup_Ack);
           break;
         case name_CC_InformationCid:
           name_CC_Information = new CC_Information(*that.name_CC_Information);
           break;
         case name_CC_Connect_ReqCid:
           name_CC_Connect_Req = new CC_Connect_Req(*that.name_CC_Connect_Req);
           break;
         case name_CC_Connect_IndCid:
           name_CC_Connect_Ind = new CC_Connect_Ind(*that.name_CC_Connect_Ind);
           break;
         case name_CC_Connect_AckCid:
           name_CC_Connect_Ack = new CC_Connect_Ack(*that.name_CC_Connect_Ack);
           break;
         case name_CC_TxDemandCid:
           name_CC_TxDemand = new CC_TxDemand(*that.name_CC_TxDemand);
           break;
         case name_CC_TxGrantCid:
           name_CC_TxGrant = new CC_TxGrant(*that.name_CC_TxGrant);
           break;
         case name_CC_TxCeasedCid:
           name_CC_TxCeased = new CC_TxCeased(*that.name_CC_TxCeased);
           break;
         case name_CC_TxInterruptCid:
           name_CC_TxInterrupt = new CC_TxInterrupt(*that.name_CC_TxInterrupt);
           break;
         case name_CC_TxWait_IndCid:
           name_CC_TxWait_Ind = new CC_TxWait_Ind(*that.name_CC_TxWait_Ind);
           break;
         case name_CC_TxWait_ReqCid:
           name_CC_TxWait_Req = new CC_TxWait_Req(*that.name_CC_TxWait_Req);
           break;
         case name_CC_TxWait_AckCid:
           name_CC_TxWait_Ack = new CC_TxWait_Ack(*that.name_CC_TxWait_Ack);
           break;
         case name_CC_TxContinue_IndCid:
           name_CC_TxContinue_Ind = new CC_TxContinue_Ind(*that.name_CC_TxContinue_Ind);
           break;
         case name_CC_TxContinue_ReqCid:
           name_CC_TxContinue_Req = new CC_TxContinue_Req(*that.name_CC_TxContinue_Req);
           break;
         case name_CC_TxContinue_AckCid:
           name_CC_TxContinue_Ack = new CC_TxContinue_Ack(*that.name_CC_TxContinue_Ack);
           break;
         case name_CC_DisconnectCid:
           name_CC_Disconnect = new CC_Disconnect(*that.name_CC_Disconnect);
           break;
         case name_CC_Disconnect_AckCid:
           name_CC_Disconnect_Ack = new CC_Disconnect_Ack(*that.name_CC_Disconnect_Ack);
           break;
         case name_CC_DialupLine_InfoCid:
           name_CC_DialupLine_Info = new CC_DialupLine_Info(*that.name_CC_DialupLine_Info);
           break;
         case name_CC_ForcedCallEndCid:
           name_CC_ForcedCallEnd = new CC_ForcedCallEnd(*that.name_CC_ForcedCallEnd);
           break;
         case name_CC_ForcedCallEnd_AckCid:
           name_CC_ForcedCallEnd_Ack = new CC_ForcedCallEnd_Ack(*that.name_CC_ForcedCallEnd_Ack);
           break;
         case name_CC_CancelIncludeCid:
           name_CC_CancelInclude = new CC_CancelInclude(*that.name_CC_CancelInclude);
           break;
         case name_SS_GroupAttachCid:
           name_SS_GroupAttach = new SS_GroupAttach(*that.name_SS_GroupAttach);
           break;
         case name_SS_GroupAttach_AckCid:
           name_SS_GroupAttach_Ack = new SS_GroupAttach_Ack(*that.name_SS_GroupAttach_Ack);
           break;
         case name_SS_GroupDetachCid:
           name_SS_GroupDetach = new SS_GroupDetach(*that.name_SS_GroupDetach);
           break;
         case name_SS_GroupDetach_AckCid:
           name_SS_GroupDetach_Ack = new SS_GroupDetach_Ack(*that.name_SS_GroupDetach_Ack);
           break;
         case name_SS_DynGroupAddCid:
           name_SS_DynGroupAdd = new SS_DynGroupAdd(*that.name_SS_DynGroupAdd);
           break;
         case name_SS_DynGroupDelCid:
           name_SS_DynGroupDel = new SS_DynGroupDel(*that.name_SS_DynGroupDel);
           break;
         case name_SS_DynGroupAdd_AckCid:
           name_SS_DynGroupAdd_Ack = new SS_DynGroupAdd_Ack(*that.name_SS_DynGroupAdd_Ack);
           break;
         case name_SS_DynGroupDel_AckCid:
           name_SS_DynGroupDel_Ack = new SS_DynGroupDel_Ack(*that.name_SS_DynGroupDel_Ack);
           break;
         case name_SS_DynGroupInterrogateCid:
           name_SS_DynGroupInterrogate = new SS_DynGroupInterrogate(*that.name_SS_DynGroupInterrogate);
           break;
         case name_SS_DynGroupInterrogate_AckCid:
           name_SS_DynGroupInterrogate_Ack = new SS_DynGroupInterrogate_Ack(*that.name_SS_DynGroupInterrogate_Ack);
           break;
         case name_SS_DynGroupAssignCid:
           name_SS_DynGroupAssign = new SS_DynGroupAssign(*that.name_SS_DynGroupAssign);
           break;
         case name_SS_DynGroupAssign_AckCid:
           name_SS_DynGroupAssign_Ack = new SS_DynGroupAssign_Ack(*that.name_SS_DynGroupAssign_Ack);
           break;
         case name_SS_DynGroupDeassignCid:
           name_SS_DynGroupDeassign = new SS_DynGroupDeassign(*that.name_SS_DynGroupDeassign);
           break;
         case name_SS_DynGroupDeassign_AckCid:
           name_SS_DynGroupDeassign_Ack = new SS_DynGroupDeassign_Ack(*that.name_SS_DynGroupDeassign_Ack);
           break;
         case name_SS_CallForwardActivateCid:
           name_SS_CallForwardActivate = new SS_CallForwardActivate(*that.name_SS_CallForwardActivate);
           break;
         case name_SS_CallForwardActivate_AckCid:
           name_SS_CallForwardActivate_Ack = new SS_CallForwardActivate_Ack(*that.name_SS_CallForwardActivate_Ack);
           break;
         case name_SS_CallForwardDeactivateCid:
           name_SS_CallForwardDeactivate = new SS_CallForwardDeactivate(*that.name_SS_CallForwardDeactivate);
           break;
         case name_SS_CallForwardDeactivate_AckCid:
           name_SS_CallForwardDeactivate_Ack = new SS_CallForwardDeactivate_Ack(*that.name_SS_CallForwardDeactivate_Ack);
           break;
         case name_SS_CallForwardCancelAllCid:
           name_SS_CallForwardCancelAll = new SS_CallForwardCancelAll(*that.name_SS_CallForwardCancelAll);
           break;
         case name_SS_CallForwardCancel_AckCid:
           name_SS_CallForwardCancel_Ack = new SS_CallForwardCancel_Ack(*that.name_SS_CallForwardCancel_Ack);
           break;
         case name_SS_CallForwardInterrogateCid:
           name_SS_CallForwardInterrogate = new SS_CallForwardInterrogate(*that.name_SS_CallForwardInterrogate);
           break;
         case name_SS_CallForwardInterrogate_AckCid:
           name_SS_CallForwardInterrogate_Ack = new SS_CallForwardInterrogate_Ack(*that.name_SS_CallForwardInterrogate_Ack);
           break;
         case name_SS_ObjectIdentityAssignCid:
           name_SS_ObjectIdentityAssign = new SS_ObjectIdentityAssign(*that.name_SS_ObjectIdentityAssign);
           break;
         case name_SS_ObjectIdentityAssign_AckCid:
           name_SS_ObjectIdentityAssign_Ack = new SS_ObjectIdentityAssign_Ack(*that.name_SS_ObjectIdentityAssign_Ack);
           break;
         case name_SS_ObjectIdentityDeassignCid:
           name_SS_ObjectIdentityDeassign = new SS_ObjectIdentityDeassign(*that.name_SS_ObjectIdentityDeassign);
           break;
         case name_SS_ObjectIdentityDeassign_AckCid:
           name_SS_ObjectIdentityDeassign_Ack = new SS_ObjectIdentityDeassign_Ack(*that.name_SS_ObjectIdentityDeassign_Ack);
           break;
         case name_SS_ObjectIdentityCancelGatewayCid:
           name_SS_ObjectIdentityCancelGateway = new SS_ObjectIdentityCancelGateway(*that.name_SS_ObjectIdentityCancelGateway);
           break;
         case name_SS_ObjectIdentityCancelGateway_AckCid:
           name_SS_ObjectIdentityCancelGateway_Ack = new SS_ObjectIdentityCancelGateway_Ack(*that.name_SS_ObjectIdentityCancelGateway_Ack);
           break;
         case name_SS_ObjectIdentityInterrogateCid:
           name_SS_ObjectIdentityInterrogate = new SS_ObjectIdentityInterrogate(*that.name_SS_ObjectIdentityInterrogate);
           break;
         case name_SS_ObjectIdentityInterrogate_AckCid:
           name_SS_ObjectIdentityInterrogate_Ack = new SS_ObjectIdentityInterrogate_Ack(*that.name_SS_ObjectIdentityInterrogate_Ack);
           break;
         case name_MON_Monitoring_ReqCid:
           name_MON_Monitoring_Req = new MON_Monitoring_Req(*that.name_MON_Monitoring_Req);
           break;
         case name_MON_Monitoring_AckCid:
           name_MON_Monitoring_Ack = new MON_Monitoring_Ack(*that.name_MON_Monitoring_Ack);
           break;
         case name_MON_FleetMonitoring_ReqCid:
           name_MON_FleetMonitoring_Req = new MON_FleetMonitoring_Req(*that.name_MON_FleetMonitoring_Req);
           break;
         case name_MON_FleetMonitoring_AckCid:
           name_MON_FleetMonitoring_Ack = new MON_FleetMonitoring_Ack(*that.name_MON_FleetMonitoring_Ack);
           break;
         case name_MON_Data_AckCid:
           name_MON_Data_Ack = new MON_Data_Ack(*that.name_MON_Data_Ack);
           break;
         case name_MON_CloseCid:
           name_MON_Close = new MON_Close(*that.name_MON_Close);
           break;
         case name_MON_Close_AckCid:
           name_MON_Close_Ack = new MON_Close_Ack(*that.name_MON_Close_Ack);
           break;
         case name_MON_LocationUpdateCid:
           name_MON_LocationUpdate = new MON_LocationUpdate(*that.name_MON_LocationUpdate);
           break;
         case name_MON_LocationDetachCid:
           name_MON_LocationDetach = new MON_LocationDetach(*that.name_MON_LocationDetach);
           break;
         case name_MON_SDS_DataCid:
           name_MON_SDS_Data = new MON_SDS_Data(*that.name_MON_SDS_Data);
           break;
         case name_MON_SDS_AckCid:
           name_MON_SDS_Ack = new MON_SDS_Ack(*that.name_MON_SDS_Ack);
           break;
         case name_MON_CC_InformationCid:
           name_MON_CC_Information = new MON_CC_Information(*that.name_MON_CC_Information);
           break;
         case name_MON_TxDemandCid:
           name_MON_TxDemand = new MON_TxDemand(*that.name_MON_TxDemand);
           break;
         case name_MON_TxCeasedCid:
           name_MON_TxCeased = new MON_TxCeased(*that.name_MON_TxCeased);
           break;
         case name_MON_TxGrantCid:
           name_MON_TxGrant = new MON_TxGrant(*that.name_MON_TxGrant);
           break;
         case name_MON_DisconnectCid:
           name_MON_Disconnect = new MON_Disconnect(*that.name_MON_Disconnect);
           break;
         case name_MON_Intercept_ReqCid:
           name_MON_Intercept_Req = new MON_Intercept_Req(*that.name_MON_Intercept_Req);
           break;
         case name_MON_Intercept_AckCid:
           name_MON_Intercept_Ack = new MON_Intercept_Ack(*that.name_MON_Intercept_Ack);
           break;
         case name_MON_Intercept_ConnectCid:
           name_MON_Intercept_Connect = new MON_Intercept_Connect(*that.name_MON_Intercept_Connect);
           break;
         case name_MON_Intercept_DisconnectCid:
           name_MON_Intercept_Disconnect = new MON_Intercept_Disconnect(*that.name_MON_Intercept_Disconnect);
           break;
         case name_MON_Intercept_Disconnect_AckCid:
           name_MON_Intercept_Disconnect_Ack = new MON_Intercept_Disconnect_Ack(*that.name_MON_Intercept_Disconnect_Ack);
           break;
         case name_MON_ForcedCallEndCid:
           name_MON_ForcedCallEnd = new MON_ForcedCallEnd(*that.name_MON_ForcedCallEnd);
           break;
         case name_MON_ForcedCallEnd_AckCid:
           name_MON_ForcedCallEnd_Ack = new MON_ForcedCallEnd_Ack(*that.name_MON_ForcedCallEnd_Ack);
           break;
         case name_MON_Uplink_TxDemandCid:
           name_MON_Uplink_TxDemand = new MON_Uplink_TxDemand(*that.name_MON_Uplink_TxDemand);
           break;
         case name_MON_Uplink_TxCeasedCid:
           name_MON_Uplink_TxCeased = new MON_Uplink_TxCeased(*that.name_MON_Uplink_TxCeased);
           break;
         case name_MON_TxInterruptCid:
           name_MON_TxInterrupt = new MON_TxInterrupt(*that.name_MON_TxInterrupt);
           break;
         case name_RSM_ResourceMonitoring_ReqCid:
           name_RSM_ResourceMonitoring_Req = new RSM_ResourceMonitoring_Req(*that.name_RSM_ResourceMonitoring_Req);
           break;
         case name_RSM_ResourceState_IndCid:
           name_RSM_ResourceState_Ind = new RSM_ResourceState_Ind(*that.name_RSM_ResourceState_Ind);
           break;
         case name_RSM_ResourceMonitoring_CloseCid:
           name_RSM_ResourceMonitoring_Close = new RSM_ResourceMonitoring_Close(*that.name_RSM_ResourceMonitoring_Close);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
ACAPI_PDUChoice::BEncContent (AsnBuf &_b) const
{
    FUNC("ACAPI_PDUChoice::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case name_ACAPI_OpenServiceCid:
      l = name_ACAPI_OpenService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 10);
      break;

    case name_ACAPI_OpenService_AckCid:
      l = name_ACAPI_OpenService_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 11);
      break;

    case name_ACAPI_CloseServiceCid:
      l = name_ACAPI_CloseService->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 12);
      break;

    case name_ACAPI_CloseService_AckCid:
      l = name_ACAPI_CloseService_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 13);
      break;

    case name_ACAPI_Authorization_ReqCid:
      l = name_ACAPI_Authorization_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 14);
      break;

    case name_ACAPI_AuthorizationCid:
      l = name_ACAPI_Authorization->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 15);
      break;

    case name_ACAPI_Message_AckCid:
      l = name_ACAPI_Message_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 16);
      break;

    case name_ACAPI_Error_InfoCid:
      l = name_ACAPI_Error_Info->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 17);
      break;

    case name_SDS_DataCid:
      l = name_SDS_Data->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 20);
      break;

    case name_SDS_Data_AckCid:
      l = name_SDS_Data_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 21);
      break;

    case name_CC_Setup_ReqCid:
      l = name_CC_Setup_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 30);
      break;

    case name_CC_SetupInclude_ReqCid:
      l = name_CC_SetupInclude_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 120);
      break;

    case name_CC_Setup_IndCid:
      l = name_CC_Setup_Ind->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 31);
      break;

    case name_CC_Setup_AckCid:
      l = name_CC_Setup_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 32);
      break;

    case name_CC_InformationCid:
      l = name_CC_Information->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 33);
      break;

    case name_CC_Connect_ReqCid:
      l = name_CC_Connect_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 34);
      break;

    case name_CC_Connect_IndCid:
      l = name_CC_Connect_Ind->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 35);
      break;

    case name_CC_Connect_AckCid:
      l = name_CC_Connect_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 36);
      break;

    case name_CC_TxDemandCid:
      l = name_CC_TxDemand->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 37);
      break;

    case name_CC_TxGrantCid:
      l = name_CC_TxGrant->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 38);
      break;

    case name_CC_TxCeasedCid:
      l = name_CC_TxCeased->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 39);
      break;

    case name_CC_TxInterruptCid:
      l = name_CC_TxInterrupt->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 40);
      break;

    case name_CC_TxWait_IndCid:
      l = name_CC_TxWait_Ind->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 45);
      break;

    case name_CC_TxWait_ReqCid:
      l = name_CC_TxWait_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 46);
      break;

    case name_CC_TxWait_AckCid:
      l = name_CC_TxWait_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 47);
      break;

    case name_CC_TxContinue_IndCid:
      l = name_CC_TxContinue_Ind->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 122);
      break;

    case name_CC_TxContinue_ReqCid:
      l = name_CC_TxContinue_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 48);
      break;

    case name_CC_TxContinue_AckCid:
      l = name_CC_TxContinue_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 49);
      break;

    case name_CC_DisconnectCid:
      l = name_CC_Disconnect->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 41);
      break;

    case name_CC_Disconnect_AckCid:
      l = name_CC_Disconnect_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 42);
      break;

    case name_CC_DialupLine_InfoCid:
      l = name_CC_DialupLine_Info->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 43);
      break;

    case name_CC_ForcedCallEndCid:
      l = name_CC_ForcedCallEnd->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 44);
      break;

    case name_CC_ForcedCallEnd_AckCid:
      l = name_CC_ForcedCallEnd_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 123);
      break;

    case name_CC_CancelIncludeCid:
      l = name_CC_CancelInclude->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 121);
      break;

    case name_SS_GroupAttachCid:
      l = name_SS_GroupAttach->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 50);
      break;

    case name_SS_GroupAttach_AckCid:
      l = name_SS_GroupAttach_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 51);
      break;

    case name_SS_GroupDetachCid:
      l = name_SS_GroupDetach->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 52);
      break;

    case name_SS_GroupDetach_AckCid:
      l = name_SS_GroupDetach_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 53);
      break;

    case name_SS_DynGroupAddCid:
      l = name_SS_DynGroupAdd->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 54);
      break;

    case name_SS_DynGroupDelCid:
      l = name_SS_DynGroupDel->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 55);
      break;

    case name_SS_DynGroupAdd_AckCid:
      l = name_SS_DynGroupAdd_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 56);
      break;

    case name_SS_DynGroupDel_AckCid:
      l = name_SS_DynGroupDel_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 57);
      break;

    case name_SS_DynGroupInterrogateCid:
      l = name_SS_DynGroupInterrogate->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 58);
      break;

    case name_SS_DynGroupInterrogate_AckCid:
      l = name_SS_DynGroupInterrogate_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 59);
      break;

    case name_SS_DynGroupAssignCid:
      l = name_SS_DynGroupAssign->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 60);
      break;

    case name_SS_DynGroupAssign_AckCid:
      l = name_SS_DynGroupAssign_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 61);
      break;

    case name_SS_DynGroupDeassignCid:
      l = name_SS_DynGroupDeassign->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 62);
      break;

    case name_SS_DynGroupDeassign_AckCid:
      l = name_SS_DynGroupDeassign_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 63);
      break;

    case name_SS_CallForwardActivateCid:
      l = name_SS_CallForwardActivate->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 64);
      break;

    case name_SS_CallForwardActivate_AckCid:
      l = name_SS_CallForwardActivate_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 65);
      break;

    case name_SS_CallForwardDeactivateCid:
      l = name_SS_CallForwardDeactivate->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 66);
      break;

    case name_SS_CallForwardDeactivate_AckCid:
      l = name_SS_CallForwardDeactivate_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 67);
      break;

    case name_SS_CallForwardCancelAllCid:
      l = name_SS_CallForwardCancelAll->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 68);
      break;

    case name_SS_CallForwardCancel_AckCid:
      l = name_SS_CallForwardCancel_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 69);
      break;

    case name_SS_CallForwardInterrogateCid:
      l = name_SS_CallForwardInterrogate->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag3 (_b, APPL, CONS, 130);
      break;

    case name_SS_CallForwardInterrogate_AckCid:
      l = name_SS_CallForwardInterrogate_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag3 (_b, APPL, CONS, 131);
      break;

    case name_SS_ObjectIdentityAssignCid:
      l = name_SS_ObjectIdentityAssign->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 110);
      break;

    case name_SS_ObjectIdentityAssign_AckCid:
      l = name_SS_ObjectIdentityAssign_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 111);
      break;

    case name_SS_ObjectIdentityDeassignCid:
      l = name_SS_ObjectIdentityDeassign->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 112);
      break;

    case name_SS_ObjectIdentityDeassign_AckCid:
      l = name_SS_ObjectIdentityDeassign_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 113);
      break;

    case name_SS_ObjectIdentityCancelGatewayCid:
      l = name_SS_ObjectIdentityCancelGateway->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 114);
      break;

    case name_SS_ObjectIdentityCancelGateway_AckCid:
      l = name_SS_ObjectIdentityCancelGateway_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 115);
      break;

    case name_SS_ObjectIdentityInterrogateCid:
      l = name_SS_ObjectIdentityInterrogate->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 116);
      break;

    case name_SS_ObjectIdentityInterrogate_AckCid:
      l = name_SS_ObjectIdentityInterrogate_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 117);
      break;

    case name_MON_Monitoring_ReqCid:
      l = name_MON_Monitoring_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 70);
      break;

    case name_MON_Monitoring_AckCid:
      l = name_MON_Monitoring_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 71);
      break;

    case name_MON_FleetMonitoring_ReqCid:
      l = name_MON_FleetMonitoring_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 72);
      break;

    case name_MON_FleetMonitoring_AckCid:
      l = name_MON_FleetMonitoring_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 73);
      break;

    case name_MON_Data_AckCid:
      l = name_MON_Data_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 74);
      break;

    case name_MON_CloseCid:
      l = name_MON_Close->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 75);
      break;

    case name_MON_Close_AckCid:
      l = name_MON_Close_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 76);
      break;

    case name_MON_LocationUpdateCid:
      l = name_MON_LocationUpdate->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 77);
      break;

    case name_MON_LocationDetachCid:
      l = name_MON_LocationDetach->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 78);
      break;

    case name_MON_SDS_DataCid:
      l = name_MON_SDS_Data->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 79);
      break;

    case name_MON_SDS_AckCid:
      l = name_MON_SDS_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 80);
      break;

    case name_MON_CC_InformationCid:
      l = name_MON_CC_Information->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 81);
      break;

    case name_MON_TxDemandCid:
      l = name_MON_TxDemand->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 82);
      break;

    case name_MON_TxCeasedCid:
      l = name_MON_TxCeased->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 83);
      break;

    case name_MON_TxGrantCid:
      l = name_MON_TxGrant->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 84);
      break;

    case name_MON_DisconnectCid:
      l = name_MON_Disconnect->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 85);
      break;

    case name_MON_Intercept_ReqCid:
      l = name_MON_Intercept_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 86);
      break;

    case name_MON_Intercept_AckCid:
      l = name_MON_Intercept_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 87);
      break;

    case name_MON_Intercept_ConnectCid:
      l = name_MON_Intercept_Connect->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 88);
      break;

    case name_MON_Intercept_DisconnectCid:
      l = name_MON_Intercept_Disconnect->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 89);
      break;

    case name_MON_Intercept_Disconnect_AckCid:
      l = name_MON_Intercept_Disconnect_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 90);
      break;

    case name_MON_ForcedCallEndCid:
      l = name_MON_ForcedCallEnd->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 91);
      break;

    case name_MON_ForcedCallEnd_AckCid:
      l = name_MON_ForcedCallEnd_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 92);
      break;

    case name_MON_Uplink_TxDemandCid:
      l = name_MON_Uplink_TxDemand->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 93);
      break;

    case name_MON_Uplink_TxCeasedCid:
      l = name_MON_Uplink_TxCeased->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 95);
      break;

    case name_MON_TxInterruptCid:
      l = name_MON_TxInterrupt->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 96);
      break;

    case name_RSM_ResourceMonitoring_ReqCid:
      l = name_RSM_ResourceMonitoring_Req->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 100);
      break;

    case name_RSM_ResourceState_IndCid:
      l = name_RSM_ResourceState_Ind->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 101);
      break;

    case name_RSM_ResourceMonitoring_CloseCid:
      l = name_RSM_ResourceMonitoring_Close->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag2 (_b, APPL, CONS, 102);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // ACAPI_PDUChoice::BEncContent


void ACAPI_PDUChoice::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("ACAPI_PDUChoice::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (APPL, CONS, 10):
      choiceId = name_ACAPI_OpenServiceCid;
        name_ACAPI_OpenService = new ACAPI_OpenService;
        name_ACAPI_OpenService->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 11):
      choiceId = name_ACAPI_OpenService_AckCid;
        name_ACAPI_OpenService_Ack = new ACAPI_OpenService_Ack;
        name_ACAPI_OpenService_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 12):
      choiceId = name_ACAPI_CloseServiceCid;
        name_ACAPI_CloseService = new ACAPI_CloseService;
        name_ACAPI_CloseService->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 13):
      choiceId = name_ACAPI_CloseService_AckCid;
        name_ACAPI_CloseService_Ack = new ACAPI_CloseService_Ack;
        name_ACAPI_CloseService_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 14):
      choiceId = name_ACAPI_Authorization_ReqCid;
        name_ACAPI_Authorization_Req = new ACAPI_Authorization_Req;
        name_ACAPI_Authorization_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 15):
      choiceId = name_ACAPI_AuthorizationCid;
        name_ACAPI_Authorization = new ACAPI_Authorization;
        name_ACAPI_Authorization->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 16):
      choiceId = name_ACAPI_Message_AckCid;
        name_ACAPI_Message_Ack = new ACAPI_Message_Ack;
        name_ACAPI_Message_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 17):
      choiceId = name_ACAPI_Error_InfoCid;
        name_ACAPI_Error_Info = new ACAPI_Error_Info;
        name_ACAPI_Error_Info->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 20):
      choiceId = name_SDS_DataCid;
        name_SDS_Data = new SDS_Data;
        name_SDS_Data->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 21):
      choiceId = name_SDS_Data_AckCid;
        name_SDS_Data_Ack = new SDS_Data_Ack;
        name_SDS_Data_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 30):
      choiceId = name_CC_Setup_ReqCid;
        name_CC_Setup_Req = new CC_Setup_Req;
        name_CC_Setup_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 120):
      choiceId = name_CC_SetupInclude_ReqCid;
        name_CC_SetupInclude_Req = new CC_SetupInclude_Req;
        name_CC_SetupInclude_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 31):
      choiceId = name_CC_Setup_IndCid;
        name_CC_Setup_Ind = new CC_Setup_Ind;
        name_CC_Setup_Ind->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 32):
      choiceId = name_CC_Setup_AckCid;
        name_CC_Setup_Ack = new CC_Setup_Ack;
        name_CC_Setup_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 33):
      choiceId = name_CC_InformationCid;
        name_CC_Information = new CC_Information;
        name_CC_Information->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 34):
      choiceId = name_CC_Connect_ReqCid;
        name_CC_Connect_Req = new CC_Connect_Req;
        name_CC_Connect_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 35):
      choiceId = name_CC_Connect_IndCid;
        name_CC_Connect_Ind = new CC_Connect_Ind;
        name_CC_Connect_Ind->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 36):
      choiceId = name_CC_Connect_AckCid;
        name_CC_Connect_Ack = new CC_Connect_Ack;
        name_CC_Connect_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 37):
      choiceId = name_CC_TxDemandCid;
        name_CC_TxDemand = new CC_TxDemand;
        name_CC_TxDemand->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 38):
      choiceId = name_CC_TxGrantCid;
        name_CC_TxGrant = new CC_TxGrant;
        name_CC_TxGrant->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 39):
      choiceId = name_CC_TxCeasedCid;
        name_CC_TxCeased = new CC_TxCeased;
        name_CC_TxCeased->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 40):
      choiceId = name_CC_TxInterruptCid;
        name_CC_TxInterrupt = new CC_TxInterrupt;
        name_CC_TxInterrupt->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 45):
      choiceId = name_CC_TxWait_IndCid;
        name_CC_TxWait_Ind = new CC_TxWait_Ind;
        name_CC_TxWait_Ind->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 46):
      choiceId = name_CC_TxWait_ReqCid;
        name_CC_TxWait_Req = new CC_TxWait_Req;
        name_CC_TxWait_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 47):
      choiceId = name_CC_TxWait_AckCid;
        name_CC_TxWait_Ack = new CC_TxWait_Ack;
        name_CC_TxWait_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 122):
      choiceId = name_CC_TxContinue_IndCid;
        name_CC_TxContinue_Ind = new CC_TxContinue_Ind;
        name_CC_TxContinue_Ind->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 48):
      choiceId = name_CC_TxContinue_ReqCid;
        name_CC_TxContinue_Req = new CC_TxContinue_Req;
        name_CC_TxContinue_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 49):
      choiceId = name_CC_TxContinue_AckCid;
        name_CC_TxContinue_Ack = new CC_TxContinue_Ack;
        name_CC_TxContinue_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 41):
      choiceId = name_CC_DisconnectCid;
        name_CC_Disconnect = new CC_Disconnect;
        name_CC_Disconnect->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 42):
      choiceId = name_CC_Disconnect_AckCid;
        name_CC_Disconnect_Ack = new CC_Disconnect_Ack;
        name_CC_Disconnect_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 43):
      choiceId = name_CC_DialupLine_InfoCid;
        name_CC_DialupLine_Info = new CC_DialupLine_Info;
        name_CC_DialupLine_Info->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 44):
      choiceId = name_CC_ForcedCallEndCid;
        name_CC_ForcedCallEnd = new CC_ForcedCallEnd;
        name_CC_ForcedCallEnd->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 123):
      choiceId = name_CC_ForcedCallEnd_AckCid;
        name_CC_ForcedCallEnd_Ack = new CC_ForcedCallEnd_Ack;
        name_CC_ForcedCallEnd_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 121):
      choiceId = name_CC_CancelIncludeCid;
        name_CC_CancelInclude = new CC_CancelInclude;
        name_CC_CancelInclude->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 50):
      choiceId = name_SS_GroupAttachCid;
        name_SS_GroupAttach = new SS_GroupAttach;
        name_SS_GroupAttach->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 51):
      choiceId = name_SS_GroupAttach_AckCid;
        name_SS_GroupAttach_Ack = new SS_GroupAttach_Ack;
        name_SS_GroupAttach_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 52):
      choiceId = name_SS_GroupDetachCid;
        name_SS_GroupDetach = new SS_GroupDetach;
        name_SS_GroupDetach->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 53):
      choiceId = name_SS_GroupDetach_AckCid;
        name_SS_GroupDetach_Ack = new SS_GroupDetach_Ack;
        name_SS_GroupDetach_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 54):
      choiceId = name_SS_DynGroupAddCid;
        name_SS_DynGroupAdd = new SS_DynGroupAdd;
        name_SS_DynGroupAdd->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 55):
      choiceId = name_SS_DynGroupDelCid;
        name_SS_DynGroupDel = new SS_DynGroupDel;
        name_SS_DynGroupDel->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 56):
      choiceId = name_SS_DynGroupAdd_AckCid;
        name_SS_DynGroupAdd_Ack = new SS_DynGroupAdd_Ack;
        name_SS_DynGroupAdd_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 57):
      choiceId = name_SS_DynGroupDel_AckCid;
        name_SS_DynGroupDel_Ack = new SS_DynGroupDel_Ack;
        name_SS_DynGroupDel_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 58):
      choiceId = name_SS_DynGroupInterrogateCid;
        name_SS_DynGroupInterrogate = new SS_DynGroupInterrogate;
        name_SS_DynGroupInterrogate->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 59):
      choiceId = name_SS_DynGroupInterrogate_AckCid;
        name_SS_DynGroupInterrogate_Ack = new SS_DynGroupInterrogate_Ack;
        name_SS_DynGroupInterrogate_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 60):
      choiceId = name_SS_DynGroupAssignCid;
        name_SS_DynGroupAssign = new SS_DynGroupAssign;
        name_SS_DynGroupAssign->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 61):
      choiceId = name_SS_DynGroupAssign_AckCid;
        name_SS_DynGroupAssign_Ack = new SS_DynGroupAssign_Ack;
        name_SS_DynGroupAssign_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 62):
      choiceId = name_SS_DynGroupDeassignCid;
        name_SS_DynGroupDeassign = new SS_DynGroupDeassign;
        name_SS_DynGroupDeassign->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 63):
      choiceId = name_SS_DynGroupDeassign_AckCid;
        name_SS_DynGroupDeassign_Ack = new SS_DynGroupDeassign_Ack;
        name_SS_DynGroupDeassign_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 64):
      choiceId = name_SS_CallForwardActivateCid;
        name_SS_CallForwardActivate = new SS_CallForwardActivate;
        name_SS_CallForwardActivate->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 65):
      choiceId = name_SS_CallForwardActivate_AckCid;
        name_SS_CallForwardActivate_Ack = new SS_CallForwardActivate_Ack;
        name_SS_CallForwardActivate_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 66):
      choiceId = name_SS_CallForwardDeactivateCid;
        name_SS_CallForwardDeactivate = new SS_CallForwardDeactivate;
        name_SS_CallForwardDeactivate->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 67):
      choiceId = name_SS_CallForwardDeactivate_AckCid;
        name_SS_CallForwardDeactivate_Ack = new SS_CallForwardDeactivate_Ack;
        name_SS_CallForwardDeactivate_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 68):
      choiceId = name_SS_CallForwardCancelAllCid;
        name_SS_CallForwardCancelAll = new SS_CallForwardCancelAll;
        name_SS_CallForwardCancelAll->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 69):
      choiceId = name_SS_CallForwardCancel_AckCid;
        name_SS_CallForwardCancel_Ack = new SS_CallForwardCancel_Ack;
        name_SS_CallForwardCancel_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 130):
      choiceId = name_SS_CallForwardInterrogateCid;
        name_SS_CallForwardInterrogate = new SS_CallForwardInterrogate;
        name_SS_CallForwardInterrogate->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 131):
      choiceId = name_SS_CallForwardInterrogate_AckCid;
        name_SS_CallForwardInterrogate_Ack = new SS_CallForwardInterrogate_Ack;
        name_SS_CallForwardInterrogate_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 110):
      choiceId = name_SS_ObjectIdentityAssignCid;
        name_SS_ObjectIdentityAssign = new SS_ObjectIdentityAssign;
        name_SS_ObjectIdentityAssign->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 111):
      choiceId = name_SS_ObjectIdentityAssign_AckCid;
        name_SS_ObjectIdentityAssign_Ack = new SS_ObjectIdentityAssign_Ack;
        name_SS_ObjectIdentityAssign_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 112):
      choiceId = name_SS_ObjectIdentityDeassignCid;
        name_SS_ObjectIdentityDeassign = new SS_ObjectIdentityDeassign;
        name_SS_ObjectIdentityDeassign->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 113):
      choiceId = name_SS_ObjectIdentityDeassign_AckCid;
        name_SS_ObjectIdentityDeassign_Ack = new SS_ObjectIdentityDeassign_Ack;
        name_SS_ObjectIdentityDeassign_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 114):
      choiceId = name_SS_ObjectIdentityCancelGatewayCid;
        name_SS_ObjectIdentityCancelGateway = new SS_ObjectIdentityCancelGateway;
        name_SS_ObjectIdentityCancelGateway->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 115):
      choiceId = name_SS_ObjectIdentityCancelGateway_AckCid;
        name_SS_ObjectIdentityCancelGateway_Ack = new SS_ObjectIdentityCancelGateway_Ack;
        name_SS_ObjectIdentityCancelGateway_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 116):
      choiceId = name_SS_ObjectIdentityInterrogateCid;
        name_SS_ObjectIdentityInterrogate = new SS_ObjectIdentityInterrogate;
        name_SS_ObjectIdentityInterrogate->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 117):
      choiceId = name_SS_ObjectIdentityInterrogate_AckCid;
        name_SS_ObjectIdentityInterrogate_Ack = new SS_ObjectIdentityInterrogate_Ack;
        name_SS_ObjectIdentityInterrogate_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 70):
      choiceId = name_MON_Monitoring_ReqCid;
        name_MON_Monitoring_Req = new MON_Monitoring_Req;
        name_MON_Monitoring_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 71):
      choiceId = name_MON_Monitoring_AckCid;
        name_MON_Monitoring_Ack = new MON_Monitoring_Ack;
        name_MON_Monitoring_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 72):
      choiceId = name_MON_FleetMonitoring_ReqCid;
        name_MON_FleetMonitoring_Req = new MON_FleetMonitoring_Req;
        name_MON_FleetMonitoring_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 73):
      choiceId = name_MON_FleetMonitoring_AckCid;
        name_MON_FleetMonitoring_Ack = new MON_FleetMonitoring_Ack;
        name_MON_FleetMonitoring_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 74):
      choiceId = name_MON_Data_AckCid;
        name_MON_Data_Ack = new MON_Data_Ack;
        name_MON_Data_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 75):
      choiceId = name_MON_CloseCid;
        name_MON_Close = new MON_Close;
        name_MON_Close->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 76):
      choiceId = name_MON_Close_AckCid;
        name_MON_Close_Ack = new MON_Close_Ack;
        name_MON_Close_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 77):
      choiceId = name_MON_LocationUpdateCid;
        name_MON_LocationUpdate = new MON_LocationUpdate;
        name_MON_LocationUpdate->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 78):
      choiceId = name_MON_LocationDetachCid;
        name_MON_LocationDetach = new MON_LocationDetach;
        name_MON_LocationDetach->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 79):
      choiceId = name_MON_SDS_DataCid;
        name_MON_SDS_Data = new MON_SDS_Data;
        name_MON_SDS_Data->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 80):
      choiceId = name_MON_SDS_AckCid;
        name_MON_SDS_Ack = new MON_SDS_Ack;
        name_MON_SDS_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 81):
      choiceId = name_MON_CC_InformationCid;
        name_MON_CC_Information = new MON_CC_Information;
        name_MON_CC_Information->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 82):
      choiceId = name_MON_TxDemandCid;
        name_MON_TxDemand = new MON_TxDemand;
        name_MON_TxDemand->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 83):
      choiceId = name_MON_TxCeasedCid;
        name_MON_TxCeased = new MON_TxCeased;
        name_MON_TxCeased->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 84):
      choiceId = name_MON_TxGrantCid;
        name_MON_TxGrant = new MON_TxGrant;
        name_MON_TxGrant->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 85):
      choiceId = name_MON_DisconnectCid;
        name_MON_Disconnect = new MON_Disconnect;
        name_MON_Disconnect->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 86):
      choiceId = name_MON_Intercept_ReqCid;
        name_MON_Intercept_Req = new MON_Intercept_Req;
        name_MON_Intercept_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 87):
      choiceId = name_MON_Intercept_AckCid;
        name_MON_Intercept_Ack = new MON_Intercept_Ack;
        name_MON_Intercept_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 88):
      choiceId = name_MON_Intercept_ConnectCid;
        name_MON_Intercept_Connect = new MON_Intercept_Connect;
        name_MON_Intercept_Connect->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 89):
      choiceId = name_MON_Intercept_DisconnectCid;
        name_MON_Intercept_Disconnect = new MON_Intercept_Disconnect;
        name_MON_Intercept_Disconnect->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 90):
      choiceId = name_MON_Intercept_Disconnect_AckCid;
        name_MON_Intercept_Disconnect_Ack = new MON_Intercept_Disconnect_Ack;
        name_MON_Intercept_Disconnect_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 91):
      choiceId = name_MON_ForcedCallEndCid;
        name_MON_ForcedCallEnd = new MON_ForcedCallEnd;
        name_MON_ForcedCallEnd->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 92):
      choiceId = name_MON_ForcedCallEnd_AckCid;
        name_MON_ForcedCallEnd_Ack = new MON_ForcedCallEnd_Ack;
        name_MON_ForcedCallEnd_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 93):
      choiceId = name_MON_Uplink_TxDemandCid;
        name_MON_Uplink_TxDemand = new MON_Uplink_TxDemand;
        name_MON_Uplink_TxDemand->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 95):
      choiceId = name_MON_Uplink_TxCeasedCid;
        name_MON_Uplink_TxCeased = new MON_Uplink_TxCeased;
        name_MON_Uplink_TxCeased->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 96):
      choiceId = name_MON_TxInterruptCid;
        name_MON_TxInterrupt = new MON_TxInterrupt;
        name_MON_TxInterrupt->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 100):
      choiceId = name_RSM_ResourceMonitoring_ReqCid;
        name_RSM_ResourceMonitoring_Req = new RSM_ResourceMonitoring_Req;
        name_RSM_ResourceMonitoring_Req->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 101):
      choiceId = name_RSM_ResourceState_IndCid;
        name_RSM_ResourceState_Ind = new RSM_ResourceState_Ind;
        name_RSM_ResourceState_Ind->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 102):
      choiceId = name_RSM_ResourceMonitoring_CloseCid;
        name_RSM_ResourceMonitoring_Close = new RSM_ResourceMonitoring_Close;
        name_RSM_ResourceMonitoring_Close->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // ACAPI_PDUChoice::BDecContent


AsnLen ACAPI_PDUChoice::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void ACAPI_PDUChoice::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void ACAPI_PDUChoice::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case name_ACAPI_OpenServiceCid:
		os << "name-ACAPI-OpenService ";
		if (name_ACAPI_OpenService)
			name_ACAPI_OpenService->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_ACAPI_OpenService_AckCid:
		os << "name-ACAPI-OpenService-Ack ";
		if (name_ACAPI_OpenService_Ack)
			name_ACAPI_OpenService_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_ACAPI_CloseServiceCid:
		os << "name-ACAPI-CloseService ";
		if (name_ACAPI_CloseService)
			name_ACAPI_CloseService->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_ACAPI_CloseService_AckCid:
		os << "name-ACAPI-CloseService-Ack ";
		if (name_ACAPI_CloseService_Ack)
			name_ACAPI_CloseService_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_ACAPI_Authorization_ReqCid:
		os << "name-ACAPI-Authorization-Req ";
		if (name_ACAPI_Authorization_Req)
			name_ACAPI_Authorization_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_ACAPI_AuthorizationCid:
		os << "name-ACAPI-Authorization ";
		if (name_ACAPI_Authorization)
			name_ACAPI_Authorization->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_ACAPI_Message_AckCid:
		os << "name-ACAPI-Message-Ack ";
		if (name_ACAPI_Message_Ack)
			name_ACAPI_Message_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_ACAPI_Error_InfoCid:
		os << "name-ACAPI-Error-Info ";
		if (name_ACAPI_Error_Info)
			name_ACAPI_Error_Info->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SDS_DataCid:
		os << "name-SDS-Data ";
		if (name_SDS_Data)
			name_SDS_Data->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SDS_Data_AckCid:
		os << "name-SDS-Data-Ack ";
		if (name_SDS_Data_Ack)
			name_SDS_Data_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_Setup_ReqCid:
		os << "name-CC-Setup-Req ";
		if (name_CC_Setup_Req)
			name_CC_Setup_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_SetupInclude_ReqCid:
		os << "name-CC-SetupInclude-Req ";
		if (name_CC_SetupInclude_Req)
			name_CC_SetupInclude_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_Setup_IndCid:
		os << "name-CC-Setup-Ind ";
		if (name_CC_Setup_Ind)
			name_CC_Setup_Ind->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_Setup_AckCid:
		os << "name-CC-Setup-Ack ";
		if (name_CC_Setup_Ack)
			name_CC_Setup_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_InformationCid:
		os << "name-CC-Information ";
		if (name_CC_Information)
			name_CC_Information->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_Connect_ReqCid:
		os << "name-CC-Connect-Req ";
		if (name_CC_Connect_Req)
			name_CC_Connect_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_Connect_IndCid:
		os << "name-CC-Connect-Ind ";
		if (name_CC_Connect_Ind)
			name_CC_Connect_Ind->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_Connect_AckCid:
		os << "name-CC-Connect-Ack ";
		if (name_CC_Connect_Ack)
			name_CC_Connect_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxDemandCid:
		os << "name-CC-TxDemand ";
		if (name_CC_TxDemand)
			name_CC_TxDemand->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxGrantCid:
		os << "name-CC-TxGrant ";
		if (name_CC_TxGrant)
			name_CC_TxGrant->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxCeasedCid:
		os << "name-CC-TxCeased ";
		if (name_CC_TxCeased)
			name_CC_TxCeased->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxInterruptCid:
		os << "name-CC-TxInterrupt ";
		if (name_CC_TxInterrupt)
			name_CC_TxInterrupt->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxWait_IndCid:
		os << "name-CC-TxWait-Ind ";
		if (name_CC_TxWait_Ind)
			name_CC_TxWait_Ind->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxWait_ReqCid:
		os << "name-CC-TxWait-Req ";
		if (name_CC_TxWait_Req)
			name_CC_TxWait_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxWait_AckCid:
		os << "name-CC-TxWait-Ack ";
		if (name_CC_TxWait_Ack)
			name_CC_TxWait_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxContinue_IndCid:
		os << "name-CC-TxContinue-Ind ";
		if (name_CC_TxContinue_Ind)
			name_CC_TxContinue_Ind->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxContinue_ReqCid:
		os << "name-CC-TxContinue-Req ";
		if (name_CC_TxContinue_Req)
			name_CC_TxContinue_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_TxContinue_AckCid:
		os << "name-CC-TxContinue-Ack ";
		if (name_CC_TxContinue_Ack)
			name_CC_TxContinue_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_DisconnectCid:
		os << "name-CC-Disconnect ";
		if (name_CC_Disconnect)
			name_CC_Disconnect->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_Disconnect_AckCid:
		os << "name-CC-Disconnect-Ack ";
		if (name_CC_Disconnect_Ack)
			name_CC_Disconnect_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_DialupLine_InfoCid:
		os << "name-CC-DialupLine-Info ";
		if (name_CC_DialupLine_Info)
			name_CC_DialupLine_Info->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_ForcedCallEndCid:
		os << "name-CC-ForcedCallEnd ";
		if (name_CC_ForcedCallEnd)
			name_CC_ForcedCallEnd->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_ForcedCallEnd_AckCid:
		os << "name-CC-ForcedCallEnd-Ack ";
		if (name_CC_ForcedCallEnd_Ack)
			name_CC_ForcedCallEnd_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_CC_CancelIncludeCid:
		os << "name-CC-CancelInclude ";
		if (name_CC_CancelInclude)
			name_CC_CancelInclude->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_GroupAttachCid:
		os << "name-SS-GroupAttach ";
		if (name_SS_GroupAttach)
			name_SS_GroupAttach->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_GroupAttach_AckCid:
		os << "name-SS-GroupAttach-Ack ";
		if (name_SS_GroupAttach_Ack)
			name_SS_GroupAttach_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_GroupDetachCid:
		os << "name-SS-GroupDetach ";
		if (name_SS_GroupDetach)
			name_SS_GroupDetach->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_GroupDetach_AckCid:
		os << "name-SS-GroupDetach-Ack ";
		if (name_SS_GroupDetach_Ack)
			name_SS_GroupDetach_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupAddCid:
		os << "name-SS-DynGroupAdd ";
		if (name_SS_DynGroupAdd)
			name_SS_DynGroupAdd->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupDelCid:
		os << "name-SS-DynGroupDel ";
		if (name_SS_DynGroupDel)
			name_SS_DynGroupDel->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupAdd_AckCid:
		os << "name-SS-DynGroupAdd-Ack ";
		if (name_SS_DynGroupAdd_Ack)
			name_SS_DynGroupAdd_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupDel_AckCid:
		os << "name-SS-DynGroupDel-Ack ";
		if (name_SS_DynGroupDel_Ack)
			name_SS_DynGroupDel_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupInterrogateCid:
		os << "name-SS-DynGroupInterrogate ";
		if (name_SS_DynGroupInterrogate)
			name_SS_DynGroupInterrogate->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupInterrogate_AckCid:
		os << "name-SS-DynGroupInterrogate-Ack ";
		if (name_SS_DynGroupInterrogate_Ack)
			name_SS_DynGroupInterrogate_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupAssignCid:
		os << "name-SS-DynGroupAssign ";
		if (name_SS_DynGroupAssign)
			name_SS_DynGroupAssign->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupAssign_AckCid:
		os << "name-SS-DynGroupAssign-Ack ";
		if (name_SS_DynGroupAssign_Ack)
			name_SS_DynGroupAssign_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupDeassignCid:
		os << "name-SS-DynGroupDeassign ";
		if (name_SS_DynGroupDeassign)
			name_SS_DynGroupDeassign->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_DynGroupDeassign_AckCid:
		os << "name-SS-DynGroupDeassign-Ack ";
		if (name_SS_DynGroupDeassign_Ack)
			name_SS_DynGroupDeassign_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_CallForwardActivateCid:
		os << "name-SS-CallForwardActivate ";
		if (name_SS_CallForwardActivate)
			name_SS_CallForwardActivate->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_CallForwardActivate_AckCid:
		os << "name-SS-CallForwardActivate-Ack ";
		if (name_SS_CallForwardActivate_Ack)
			name_SS_CallForwardActivate_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_CallForwardDeactivateCid:
		os << "name-SS-CallForwardDeactivate ";
		if (name_SS_CallForwardDeactivate)
			name_SS_CallForwardDeactivate->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_CallForwardDeactivate_AckCid:
		os << "name-SS-CallForwardDeactivate-Ack ";
		if (name_SS_CallForwardDeactivate_Ack)
			name_SS_CallForwardDeactivate_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_CallForwardCancelAllCid:
		os << "name-SS-CallForwardCancelAll ";
		if (name_SS_CallForwardCancelAll)
			name_SS_CallForwardCancelAll->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_CallForwardCancel_AckCid:
		os << "name-SS-CallForwardCancel-Ack ";
		if (name_SS_CallForwardCancel_Ack)
			name_SS_CallForwardCancel_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_CallForwardInterrogateCid:
		os << "name-SS-CallForwardInterrogate ";
		if (name_SS_CallForwardInterrogate)
			name_SS_CallForwardInterrogate->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_CallForwardInterrogate_AckCid:
		os << "name-SS-CallForwardInterrogate-Ack ";
		if (name_SS_CallForwardInterrogate_Ack)
			name_SS_CallForwardInterrogate_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_ObjectIdentityAssignCid:
		os << "name-SS-ObjectIdentityAssign ";
		if (name_SS_ObjectIdentityAssign)
			name_SS_ObjectIdentityAssign->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_ObjectIdentityAssign_AckCid:
		os << "name-SS-ObjectIdentityAssign-Ack ";
		if (name_SS_ObjectIdentityAssign_Ack)
			name_SS_ObjectIdentityAssign_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_ObjectIdentityDeassignCid:
		os << "name-SS-ObjectIdentityDeassign ";
		if (name_SS_ObjectIdentityDeassign)
			name_SS_ObjectIdentityDeassign->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_ObjectIdentityDeassign_AckCid:
		os << "name-SS-ObjectIdentityDeassign-Ack ";
		if (name_SS_ObjectIdentityDeassign_Ack)
			name_SS_ObjectIdentityDeassign_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_ObjectIdentityCancelGatewayCid:
		os << "name-SS-ObjectIdentityCancelGateway ";
		if (name_SS_ObjectIdentityCancelGateway)
			name_SS_ObjectIdentityCancelGateway->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_ObjectIdentityCancelGateway_AckCid:
		os << "name-SS-ObjectIdentityCancelGateway-Ack ";
		if (name_SS_ObjectIdentityCancelGateway_Ack)
			name_SS_ObjectIdentityCancelGateway_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_ObjectIdentityInterrogateCid:
		os << "name-SS-ObjectIdentityInterrogate ";
		if (name_SS_ObjectIdentityInterrogate)
			name_SS_ObjectIdentityInterrogate->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_SS_ObjectIdentityInterrogate_AckCid:
		os << "name-SS-ObjectIdentityInterrogate-Ack ";
		if (name_SS_ObjectIdentityInterrogate_Ack)
			name_SS_ObjectIdentityInterrogate_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Monitoring_ReqCid:
		os << "name-MON-Monitoring-Req ";
		if (name_MON_Monitoring_Req)
			name_MON_Monitoring_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Monitoring_AckCid:
		os << "name-MON-Monitoring-Ack ";
		if (name_MON_Monitoring_Ack)
			name_MON_Monitoring_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_FleetMonitoring_ReqCid:
		os << "name-MON-FleetMonitoring-Req ";
		if (name_MON_FleetMonitoring_Req)
			name_MON_FleetMonitoring_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_FleetMonitoring_AckCid:
		os << "name-MON-FleetMonitoring-Ack ";
		if (name_MON_FleetMonitoring_Ack)
			name_MON_FleetMonitoring_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Data_AckCid:
		os << "name-MON-Data-Ack ";
		if (name_MON_Data_Ack)
			name_MON_Data_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_CloseCid:
		os << "name-MON-Close ";
		if (name_MON_Close)
			name_MON_Close->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Close_AckCid:
		os << "name-MON-Close-Ack ";
		if (name_MON_Close_Ack)
			name_MON_Close_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_LocationUpdateCid:
		os << "name-MON-LocationUpdate ";
		if (name_MON_LocationUpdate)
			name_MON_LocationUpdate->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_LocationDetachCid:
		os << "name-MON-LocationDetach ";
		if (name_MON_LocationDetach)
			name_MON_LocationDetach->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_SDS_DataCid:
		os << "name-MON-SDS-Data ";
		if (name_MON_SDS_Data)
			name_MON_SDS_Data->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_SDS_AckCid:
		os << "name-MON-SDS-Ack ";
		if (name_MON_SDS_Ack)
			name_MON_SDS_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_CC_InformationCid:
		os << "name-MON-CC-Information ";
		if (name_MON_CC_Information)
			name_MON_CC_Information->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_TxDemandCid:
		os << "name-MON-TxDemand ";
		if (name_MON_TxDemand)
			name_MON_TxDemand->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_TxCeasedCid:
		os << "name-MON-TxCeased ";
		if (name_MON_TxCeased)
			name_MON_TxCeased->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_TxGrantCid:
		os << "name-MON-TxGrant ";
		if (name_MON_TxGrant)
			name_MON_TxGrant->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_DisconnectCid:
		os << "name-MON-Disconnect ";
		if (name_MON_Disconnect)
			name_MON_Disconnect->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Intercept_ReqCid:
		os << "name-MON-Intercept-Req ";
		if (name_MON_Intercept_Req)
			name_MON_Intercept_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Intercept_AckCid:
		os << "name-MON-Intercept-Ack ";
		if (name_MON_Intercept_Ack)
			name_MON_Intercept_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Intercept_ConnectCid:
		os << "name-MON-Intercept-Connect ";
		if (name_MON_Intercept_Connect)
			name_MON_Intercept_Connect->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Intercept_DisconnectCid:
		os << "name-MON-Intercept-Disconnect ";
		if (name_MON_Intercept_Disconnect)
			name_MON_Intercept_Disconnect->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Intercept_Disconnect_AckCid:
		os << "name-MON-Intercept-Disconnect-Ack ";
		if (name_MON_Intercept_Disconnect_Ack)
			name_MON_Intercept_Disconnect_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_ForcedCallEndCid:
		os << "name-MON-ForcedCallEnd ";
		if (name_MON_ForcedCallEnd)
			name_MON_ForcedCallEnd->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_ForcedCallEnd_AckCid:
		os << "name-MON-ForcedCallEnd-Ack ";
		if (name_MON_ForcedCallEnd_Ack)
			name_MON_ForcedCallEnd_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Uplink_TxDemandCid:
		os << "name-MON-Uplink-TxDemand ";
		if (name_MON_Uplink_TxDemand)
			name_MON_Uplink_TxDemand->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_Uplink_TxCeasedCid:
		os << "name-MON-Uplink-TxCeased ";
		if (name_MON_Uplink_TxCeased)
			name_MON_Uplink_TxCeased->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_MON_TxInterruptCid:
		os << "name-MON-TxInterrupt ";
		if (name_MON_TxInterrupt)
			name_MON_TxInterrupt->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_RSM_ResourceMonitoring_ReqCid:
		os << "name-RSM-ResourceMonitoring-Req ";
		if (name_RSM_ResourceMonitoring_Req)
			name_RSM_ResourceMonitoring_Req->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_RSM_ResourceState_IndCid:
		os << "name-RSM-ResourceState-Ind ";
		if (name_RSM_ResourceState_Ind)
			name_RSM_ResourceState_Ind->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_RSM_ResourceMonitoring_CloseCid:
		os << "name-RSM-ResourceMonitoring-Close ";
		if (name_RSM_ResourceMonitoring_Close)
			name_RSM_ResourceMonitoring_Close->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of ACAPI_PDUChoice::Print()

void ACAPI_PDUChoice::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"ACAPI_PDUChoice\" type=\"CHOICE\">";
  }
  else
        os << "<ACAPI_PDUChoice type=\"CHOICE\">";
  switch (choiceId)
  {
    case name_ACAPI_OpenServiceCid:
      if (name_ACAPI_OpenService)
        name_ACAPI_OpenService->PrintXML(os,"name-ACAPI-OpenService");
      else
      {
        os << "<name-ACAPI-OpenService -- void3 -- /name-ACAPI-OpenService>" << std::endl;
      }
      break;

    case name_ACAPI_OpenService_AckCid:
      if (name_ACAPI_OpenService_Ack)
        name_ACAPI_OpenService_Ack->PrintXML(os,"name-ACAPI-OpenService-Ack");
      else
      {
        os << "<name-ACAPI-OpenService-Ack -- void3 -- /name-ACAPI-OpenService-Ack>" << std::endl;
      }
      break;

    case name_ACAPI_CloseServiceCid:
      if (name_ACAPI_CloseService)
        name_ACAPI_CloseService->PrintXML(os,"name-ACAPI-CloseService");
      else
      {
        os << "<name-ACAPI-CloseService -- void3 -- /name-ACAPI-CloseService>" << std::endl;
      }
      break;

    case name_ACAPI_CloseService_AckCid:
      if (name_ACAPI_CloseService_Ack)
        name_ACAPI_CloseService_Ack->PrintXML(os,"name-ACAPI-CloseService-Ack");
      else
      {
        os << "<name-ACAPI-CloseService-Ack -- void3 -- /name-ACAPI-CloseService-Ack>" << std::endl;
      }
      break;

    case name_ACAPI_Authorization_ReqCid:
      if (name_ACAPI_Authorization_Req)
        name_ACAPI_Authorization_Req->PrintXML(os,"name-ACAPI-Authorization-Req");
      else
      {
        os << "<name-ACAPI-Authorization-Req -- void3 -- /name-ACAPI-Authorization-Req>" << std::endl;
      }
      break;

    case name_ACAPI_AuthorizationCid:
      if (name_ACAPI_Authorization)
        name_ACAPI_Authorization->PrintXML(os,"name-ACAPI-Authorization");
      else
      {
        os << "<name-ACAPI-Authorization -- void3 -- /name-ACAPI-Authorization>" << std::endl;
      }
      break;

    case name_ACAPI_Message_AckCid:
      if (name_ACAPI_Message_Ack)
        name_ACAPI_Message_Ack->PrintXML(os,"name-ACAPI-Message-Ack");
      else
      {
        os << "<name-ACAPI-Message-Ack -- void3 -- /name-ACAPI-Message-Ack>" << std::endl;
      }
      break;

    case name_ACAPI_Error_InfoCid:
      if (name_ACAPI_Error_Info)
        name_ACAPI_Error_Info->PrintXML(os,"name-ACAPI-Error-Info");
      else
      {
        os << "<name-ACAPI-Error-Info -- void3 -- /name-ACAPI-Error-Info>" << std::endl;
      }
      break;

    case name_SDS_DataCid:
      if (name_SDS_Data)
        name_SDS_Data->PrintXML(os,"name-SDS-Data");
      else
      {
        os << "<name-SDS-Data -- void3 -- /name-SDS-Data>" << std::endl;
      }
      break;

    case name_SDS_Data_AckCid:
      if (name_SDS_Data_Ack)
        name_SDS_Data_Ack->PrintXML(os,"name-SDS-Data-Ack");
      else
      {
        os << "<name-SDS-Data-Ack -- void3 -- /name-SDS-Data-Ack>" << std::endl;
      }
      break;

    case name_CC_Setup_ReqCid:
      if (name_CC_Setup_Req)
        name_CC_Setup_Req->PrintXML(os,"name-CC-Setup-Req");
      else
      {
        os << "<name-CC-Setup-Req -- void3 -- /name-CC-Setup-Req>" << std::endl;
      }
      break;

    case name_CC_SetupInclude_ReqCid:
      if (name_CC_SetupInclude_Req)
        name_CC_SetupInclude_Req->PrintXML(os,"name-CC-SetupInclude-Req");
      else
      {
        os << "<name-CC-SetupInclude-Req -- void3 -- /name-CC-SetupInclude-Req>" << std::endl;
      }
      break;

    case name_CC_Setup_IndCid:
      if (name_CC_Setup_Ind)
        name_CC_Setup_Ind->PrintXML(os,"name-CC-Setup-Ind");
      else
      {
        os << "<name-CC-Setup-Ind -- void3 -- /name-CC-Setup-Ind>" << std::endl;
      }
      break;

    case name_CC_Setup_AckCid:
      if (name_CC_Setup_Ack)
        name_CC_Setup_Ack->PrintXML(os,"name-CC-Setup-Ack");
      else
      {
        os << "<name-CC-Setup-Ack -- void3 -- /name-CC-Setup-Ack>" << std::endl;
      }
      break;

    case name_CC_InformationCid:
      if (name_CC_Information)
        name_CC_Information->PrintXML(os,"name-CC-Information");
      else
      {
        os << "<name-CC-Information -- void3 -- /name-CC-Information>" << std::endl;
      }
      break;

    case name_CC_Connect_ReqCid:
      if (name_CC_Connect_Req)
        name_CC_Connect_Req->PrintXML(os,"name-CC-Connect-Req");
      else
      {
        os << "<name-CC-Connect-Req -- void3 -- /name-CC-Connect-Req>" << std::endl;
      }
      break;

    case name_CC_Connect_IndCid:
      if (name_CC_Connect_Ind)
        name_CC_Connect_Ind->PrintXML(os,"name-CC-Connect-Ind");
      else
      {
        os << "<name-CC-Connect-Ind -- void3 -- /name-CC-Connect-Ind>" << std::endl;
      }
      break;

    case name_CC_Connect_AckCid:
      if (name_CC_Connect_Ack)
        name_CC_Connect_Ack->PrintXML(os,"name-CC-Connect-Ack");
      else
      {
        os << "<name-CC-Connect-Ack -- void3 -- /name-CC-Connect-Ack>" << std::endl;
      }
      break;

    case name_CC_TxDemandCid:
      if (name_CC_TxDemand)
        name_CC_TxDemand->PrintXML(os,"name-CC-TxDemand");
      else
      {
        os << "<name-CC-TxDemand -- void3 -- /name-CC-TxDemand>" << std::endl;
      }
      break;

    case name_CC_TxGrantCid:
      if (name_CC_TxGrant)
        name_CC_TxGrant->PrintXML(os,"name-CC-TxGrant");
      else
      {
        os << "<name-CC-TxGrant -- void3 -- /name-CC-TxGrant>" << std::endl;
      }
      break;

    case name_CC_TxCeasedCid:
      if (name_CC_TxCeased)
        name_CC_TxCeased->PrintXML(os,"name-CC-TxCeased");
      else
      {
        os << "<name-CC-TxCeased -- void3 -- /name-CC-TxCeased>" << std::endl;
      }
      break;

    case name_CC_TxInterruptCid:
      if (name_CC_TxInterrupt)
        name_CC_TxInterrupt->PrintXML(os,"name-CC-TxInterrupt");
      else
      {
        os << "<name-CC-TxInterrupt -- void3 -- /name-CC-TxInterrupt>" << std::endl;
      }
      break;

    case name_CC_TxWait_IndCid:
      if (name_CC_TxWait_Ind)
        name_CC_TxWait_Ind->PrintXML(os,"name-CC-TxWait-Ind");
      else
      {
        os << "<name-CC-TxWait-Ind -- void3 -- /name-CC-TxWait-Ind>" << std::endl;
      }
      break;

    case name_CC_TxWait_ReqCid:
      if (name_CC_TxWait_Req)
        name_CC_TxWait_Req->PrintXML(os,"name-CC-TxWait-Req");
      else
      {
        os << "<name-CC-TxWait-Req -- void3 -- /name-CC-TxWait-Req>" << std::endl;
      }
      break;

    case name_CC_TxWait_AckCid:
      if (name_CC_TxWait_Ack)
        name_CC_TxWait_Ack->PrintXML(os,"name-CC-TxWait-Ack");
      else
      {
        os << "<name-CC-TxWait-Ack -- void3 -- /name-CC-TxWait-Ack>" << std::endl;
      }
      break;

    case name_CC_TxContinue_IndCid:
      if (name_CC_TxContinue_Ind)
        name_CC_TxContinue_Ind->PrintXML(os,"name-CC-TxContinue-Ind");
      else
      {
        os << "<name-CC-TxContinue-Ind -- void3 -- /name-CC-TxContinue-Ind>" << std::endl;
      }
      break;

    case name_CC_TxContinue_ReqCid:
      if (name_CC_TxContinue_Req)
        name_CC_TxContinue_Req->PrintXML(os,"name-CC-TxContinue-Req");
      else
      {
        os << "<name-CC-TxContinue-Req -- void3 -- /name-CC-TxContinue-Req>" << std::endl;
      }
      break;

    case name_CC_TxContinue_AckCid:
      if (name_CC_TxContinue_Ack)
        name_CC_TxContinue_Ack->PrintXML(os,"name-CC-TxContinue-Ack");
      else
      {
        os << "<name-CC-TxContinue-Ack -- void3 -- /name-CC-TxContinue-Ack>" << std::endl;
      }
      break;

    case name_CC_DisconnectCid:
      if (name_CC_Disconnect)
        name_CC_Disconnect->PrintXML(os,"name-CC-Disconnect");
      else
      {
        os << "<name-CC-Disconnect -- void3 -- /name-CC-Disconnect>" << std::endl;
      }
      break;

    case name_CC_Disconnect_AckCid:
      if (name_CC_Disconnect_Ack)
        name_CC_Disconnect_Ack->PrintXML(os,"name-CC-Disconnect-Ack");
      else
      {
        os << "<name-CC-Disconnect-Ack -- void3 -- /name-CC-Disconnect-Ack>" << std::endl;
      }
      break;

    case name_CC_DialupLine_InfoCid:
      if (name_CC_DialupLine_Info)
        name_CC_DialupLine_Info->PrintXML(os,"name-CC-DialupLine-Info");
      else
      {
        os << "<name-CC-DialupLine-Info -- void3 -- /name-CC-DialupLine-Info>" << std::endl;
      }
      break;

    case name_CC_ForcedCallEndCid:
      if (name_CC_ForcedCallEnd)
        name_CC_ForcedCallEnd->PrintXML(os,"name-CC-ForcedCallEnd");
      else
      {
        os << "<name-CC-ForcedCallEnd -- void3 -- /name-CC-ForcedCallEnd>" << std::endl;
      }
      break;

    case name_CC_ForcedCallEnd_AckCid:
      if (name_CC_ForcedCallEnd_Ack)
        name_CC_ForcedCallEnd_Ack->PrintXML(os,"name-CC-ForcedCallEnd-Ack");
      else
      {
        os << "<name-CC-ForcedCallEnd-Ack -- void3 -- /name-CC-ForcedCallEnd-Ack>" << std::endl;
      }
      break;

    case name_CC_CancelIncludeCid:
      if (name_CC_CancelInclude)
        name_CC_CancelInclude->PrintXML(os,"name-CC-CancelInclude");
      else
      {
        os << "<name-CC-CancelInclude -- void3 -- /name-CC-CancelInclude>" << std::endl;
      }
      break;

    case name_SS_GroupAttachCid:
      if (name_SS_GroupAttach)
        name_SS_GroupAttach->PrintXML(os,"name-SS-GroupAttach");
      else
      {
        os << "<name-SS-GroupAttach -- void3 -- /name-SS-GroupAttach>" << std::endl;
      }
      break;

    case name_SS_GroupAttach_AckCid:
      if (name_SS_GroupAttach_Ack)
        name_SS_GroupAttach_Ack->PrintXML(os,"name-SS-GroupAttach-Ack");
      else
      {
        os << "<name-SS-GroupAttach-Ack -- void3 -- /name-SS-GroupAttach-Ack>" << std::endl;
      }
      break;

    case name_SS_GroupDetachCid:
      if (name_SS_GroupDetach)
        name_SS_GroupDetach->PrintXML(os,"name-SS-GroupDetach");
      else
      {
        os << "<name-SS-GroupDetach -- void3 -- /name-SS-GroupDetach>" << std::endl;
      }
      break;

    case name_SS_GroupDetach_AckCid:
      if (name_SS_GroupDetach_Ack)
        name_SS_GroupDetach_Ack->PrintXML(os,"name-SS-GroupDetach-Ack");
      else
      {
        os << "<name-SS-GroupDetach-Ack -- void3 -- /name-SS-GroupDetach-Ack>" << std::endl;
      }
      break;

    case name_SS_DynGroupAddCid:
      if (name_SS_DynGroupAdd)
        name_SS_DynGroupAdd->PrintXML(os,"name-SS-DynGroupAdd");
      else
      {
        os << "<name-SS-DynGroupAdd -- void3 -- /name-SS-DynGroupAdd>" << std::endl;
      }
      break;

    case name_SS_DynGroupDelCid:
      if (name_SS_DynGroupDel)
        name_SS_DynGroupDel->PrintXML(os,"name-SS-DynGroupDel");
      else
      {
        os << "<name-SS-DynGroupDel -- void3 -- /name-SS-DynGroupDel>" << std::endl;
      }
      break;

    case name_SS_DynGroupAdd_AckCid:
      if (name_SS_DynGroupAdd_Ack)
        name_SS_DynGroupAdd_Ack->PrintXML(os,"name-SS-DynGroupAdd-Ack");
      else
      {
        os << "<name-SS-DynGroupAdd-Ack -- void3 -- /name-SS-DynGroupAdd-Ack>" << std::endl;
      }
      break;

    case name_SS_DynGroupDel_AckCid:
      if (name_SS_DynGroupDel_Ack)
        name_SS_DynGroupDel_Ack->PrintXML(os,"name-SS-DynGroupDel-Ack");
      else
      {
        os << "<name-SS-DynGroupDel-Ack -- void3 -- /name-SS-DynGroupDel-Ack>" << std::endl;
      }
      break;

    case name_SS_DynGroupInterrogateCid:
      if (name_SS_DynGroupInterrogate)
        name_SS_DynGroupInterrogate->PrintXML(os,"name-SS-DynGroupInterrogate");
      else
      {
        os << "<name-SS-DynGroupInterrogate -- void3 -- /name-SS-DynGroupInterrogate>" << std::endl;
      }
      break;

    case name_SS_DynGroupInterrogate_AckCid:
      if (name_SS_DynGroupInterrogate_Ack)
        name_SS_DynGroupInterrogate_Ack->PrintXML(os,"name-SS-DynGroupInterrogate-Ack");
      else
      {
        os << "<name-SS-DynGroupInterrogate-Ack -- void3 -- /name-SS-DynGroupInterrogate-Ack>" << std::endl;
      }
      break;

    case name_SS_DynGroupAssignCid:
      if (name_SS_DynGroupAssign)
        name_SS_DynGroupAssign->PrintXML(os,"name-SS-DynGroupAssign");
      else
      {
        os << "<name-SS-DynGroupAssign -- void3 -- /name-SS-DynGroupAssign>" << std::endl;
      }
      break;

    case name_SS_DynGroupAssign_AckCid:
      if (name_SS_DynGroupAssign_Ack)
        name_SS_DynGroupAssign_Ack->PrintXML(os,"name-SS-DynGroupAssign-Ack");
      else
      {
        os << "<name-SS-DynGroupAssign-Ack -- void3 -- /name-SS-DynGroupAssign-Ack>" << std::endl;
      }
      break;

    case name_SS_DynGroupDeassignCid:
      if (name_SS_DynGroupDeassign)
        name_SS_DynGroupDeassign->PrintXML(os,"name-SS-DynGroupDeassign");
      else
      {
        os << "<name-SS-DynGroupDeassign -- void3 -- /name-SS-DynGroupDeassign>" << std::endl;
      }
      break;

    case name_SS_DynGroupDeassign_AckCid:
      if (name_SS_DynGroupDeassign_Ack)
        name_SS_DynGroupDeassign_Ack->PrintXML(os,"name-SS-DynGroupDeassign-Ack");
      else
      {
        os << "<name-SS-DynGroupDeassign-Ack -- void3 -- /name-SS-DynGroupDeassign-Ack>" << std::endl;
      }
      break;

    case name_SS_CallForwardActivateCid:
      if (name_SS_CallForwardActivate)
        name_SS_CallForwardActivate->PrintXML(os,"name-SS-CallForwardActivate");
      else
      {
        os << "<name-SS-CallForwardActivate -- void3 -- /name-SS-CallForwardActivate>" << std::endl;
      }
      break;

    case name_SS_CallForwardActivate_AckCid:
      if (name_SS_CallForwardActivate_Ack)
        name_SS_CallForwardActivate_Ack->PrintXML(os,"name-SS-CallForwardActivate-Ack");
      else
      {
        os << "<name-SS-CallForwardActivate-Ack -- void3 -- /name-SS-CallForwardActivate-Ack>" << std::endl;
      }
      break;

    case name_SS_CallForwardDeactivateCid:
      if (name_SS_CallForwardDeactivate)
        name_SS_CallForwardDeactivate->PrintXML(os,"name-SS-CallForwardDeactivate");
      else
      {
        os << "<name-SS-CallForwardDeactivate -- void3 -- /name-SS-CallForwardDeactivate>" << std::endl;
      }
      break;

    case name_SS_CallForwardDeactivate_AckCid:
      if (name_SS_CallForwardDeactivate_Ack)
        name_SS_CallForwardDeactivate_Ack->PrintXML(os,"name-SS-CallForwardDeactivate-Ack");
      else
      {
        os << "<name-SS-CallForwardDeactivate-Ack -- void3 -- /name-SS-CallForwardDeactivate-Ack>" << std::endl;
      }
      break;

    case name_SS_CallForwardCancelAllCid:
      if (name_SS_CallForwardCancelAll)
        name_SS_CallForwardCancelAll->PrintXML(os,"name-SS-CallForwardCancelAll");
      else
      {
        os << "<name-SS-CallForwardCancelAll -- void3 -- /name-SS-CallForwardCancelAll>" << std::endl;
      }
      break;

    case name_SS_CallForwardCancel_AckCid:
      if (name_SS_CallForwardCancel_Ack)
        name_SS_CallForwardCancel_Ack->PrintXML(os,"name-SS-CallForwardCancel-Ack");
      else
      {
        os << "<name-SS-CallForwardCancel-Ack -- void3 -- /name-SS-CallForwardCancel-Ack>" << std::endl;
      }
      break;

    case name_SS_CallForwardInterrogateCid:
      if (name_SS_CallForwardInterrogate)
        name_SS_CallForwardInterrogate->PrintXML(os,"name-SS-CallForwardInterrogate");
      else
      {
        os << "<name-SS-CallForwardInterrogate -- void3 -- /name-SS-CallForwardInterrogate>" << std::endl;
      }
      break;

    case name_SS_CallForwardInterrogate_AckCid:
      if (name_SS_CallForwardInterrogate_Ack)
        name_SS_CallForwardInterrogate_Ack->PrintXML(os,"name-SS-CallForwardInterrogate-Ack");
      else
      {
        os << "<name-SS-CallForwardInterrogate-Ack -- void3 -- /name-SS-CallForwardInterrogate-Ack>" << std::endl;
      }
      break;

    case name_SS_ObjectIdentityAssignCid:
      if (name_SS_ObjectIdentityAssign)
        name_SS_ObjectIdentityAssign->PrintXML(os,"name-SS-ObjectIdentityAssign");
      else
      {
        os << "<name-SS-ObjectIdentityAssign -- void3 -- /name-SS-ObjectIdentityAssign>" << std::endl;
      }
      break;

    case name_SS_ObjectIdentityAssign_AckCid:
      if (name_SS_ObjectIdentityAssign_Ack)
        name_SS_ObjectIdentityAssign_Ack->PrintXML(os,"name-SS-ObjectIdentityAssign-Ack");
      else
      {
        os << "<name-SS-ObjectIdentityAssign-Ack -- void3 -- /name-SS-ObjectIdentityAssign-Ack>" << std::endl;
      }
      break;

    case name_SS_ObjectIdentityDeassignCid:
      if (name_SS_ObjectIdentityDeassign)
        name_SS_ObjectIdentityDeassign->PrintXML(os,"name-SS-ObjectIdentityDeassign");
      else
      {
        os << "<name-SS-ObjectIdentityDeassign -- void3 -- /name-SS-ObjectIdentityDeassign>" << std::endl;
      }
      break;

    case name_SS_ObjectIdentityDeassign_AckCid:
      if (name_SS_ObjectIdentityDeassign_Ack)
        name_SS_ObjectIdentityDeassign_Ack->PrintXML(os,"name-SS-ObjectIdentityDeassign-Ack");
      else
      {
        os << "<name-SS-ObjectIdentityDeassign-Ack -- void3 -- /name-SS-ObjectIdentityDeassign-Ack>" << std::endl;
      }
      break;

    case name_SS_ObjectIdentityCancelGatewayCid:
      if (name_SS_ObjectIdentityCancelGateway)
        name_SS_ObjectIdentityCancelGateway->PrintXML(os,"name-SS-ObjectIdentityCancelGateway");
      else
      {
        os << "<name-SS-ObjectIdentityCancelGateway -- void3 -- /name-SS-ObjectIdentityCancelGateway>" << std::endl;
      }
      break;

    case name_SS_ObjectIdentityCancelGateway_AckCid:
      if (name_SS_ObjectIdentityCancelGateway_Ack)
        name_SS_ObjectIdentityCancelGateway_Ack->PrintXML(os,"name-SS-ObjectIdentityCancelGateway-Ack");
      else
      {
        os << "<name-SS-ObjectIdentityCancelGateway-Ack -- void3 -- /name-SS-ObjectIdentityCancelGateway-Ack>" << std::endl;
      }
      break;

    case name_SS_ObjectIdentityInterrogateCid:
      if (name_SS_ObjectIdentityInterrogate)
        name_SS_ObjectIdentityInterrogate->PrintXML(os,"name-SS-ObjectIdentityInterrogate");
      else
      {
        os << "<name-SS-ObjectIdentityInterrogate -- void3 -- /name-SS-ObjectIdentityInterrogate>" << std::endl;
      }
      break;

    case name_SS_ObjectIdentityInterrogate_AckCid:
      if (name_SS_ObjectIdentityInterrogate_Ack)
        name_SS_ObjectIdentityInterrogate_Ack->PrintXML(os,"name-SS-ObjectIdentityInterrogate-Ack");
      else
      {
        os << "<name-SS-ObjectIdentityInterrogate-Ack -- void3 -- /name-SS-ObjectIdentityInterrogate-Ack>" << std::endl;
      }
      break;

    case name_MON_Monitoring_ReqCid:
      if (name_MON_Monitoring_Req)
        name_MON_Monitoring_Req->PrintXML(os,"name-MON-Monitoring-Req");
      else
      {
        os << "<name-MON-Monitoring-Req -- void3 -- /name-MON-Monitoring-Req>" << std::endl;
      }
      break;

    case name_MON_Monitoring_AckCid:
      if (name_MON_Monitoring_Ack)
        name_MON_Monitoring_Ack->PrintXML(os,"name-MON-Monitoring-Ack");
      else
      {
        os << "<name-MON-Monitoring-Ack -- void3 -- /name-MON-Monitoring-Ack>" << std::endl;
      }
      break;

    case name_MON_FleetMonitoring_ReqCid:
      if (name_MON_FleetMonitoring_Req)
        name_MON_FleetMonitoring_Req->PrintXML(os,"name-MON-FleetMonitoring-Req");
      else
      {
        os << "<name-MON-FleetMonitoring-Req -- void3 -- /name-MON-FleetMonitoring-Req>" << std::endl;
      }
      break;

    case name_MON_FleetMonitoring_AckCid:
      if (name_MON_FleetMonitoring_Ack)
        name_MON_FleetMonitoring_Ack->PrintXML(os,"name-MON-FleetMonitoring-Ack");
      else
      {
        os << "<name-MON-FleetMonitoring-Ack -- void3 -- /name-MON-FleetMonitoring-Ack>" << std::endl;
      }
      break;

    case name_MON_Data_AckCid:
      if (name_MON_Data_Ack)
        name_MON_Data_Ack->PrintXML(os,"name-MON-Data-Ack");
      else
      {
        os << "<name-MON-Data-Ack -- void3 -- /name-MON-Data-Ack>" << std::endl;
      }
      break;

    case name_MON_CloseCid:
      if (name_MON_Close)
        name_MON_Close->PrintXML(os,"name-MON-Close");
      else
      {
        os << "<name-MON-Close -- void3 -- /name-MON-Close>" << std::endl;
      }
      break;

    case name_MON_Close_AckCid:
      if (name_MON_Close_Ack)
        name_MON_Close_Ack->PrintXML(os,"name-MON-Close-Ack");
      else
      {
        os << "<name-MON-Close-Ack -- void3 -- /name-MON-Close-Ack>" << std::endl;
      }
      break;

    case name_MON_LocationUpdateCid:
      if (name_MON_LocationUpdate)
        name_MON_LocationUpdate->PrintXML(os,"name-MON-LocationUpdate");
      else
      {
        os << "<name-MON-LocationUpdate -- void3 -- /name-MON-LocationUpdate>" << std::endl;
      }
      break;

    case name_MON_LocationDetachCid:
      if (name_MON_LocationDetach)
        name_MON_LocationDetach->PrintXML(os,"name-MON-LocationDetach");
      else
      {
        os << "<name-MON-LocationDetach -- void3 -- /name-MON-LocationDetach>" << std::endl;
      }
      break;

    case name_MON_SDS_DataCid:
      if (name_MON_SDS_Data)
        name_MON_SDS_Data->PrintXML(os,"name-MON-SDS-Data");
      else
      {
        os << "<name-MON-SDS-Data -- void3 -- /name-MON-SDS-Data>" << std::endl;
      }
      break;

    case name_MON_SDS_AckCid:
      if (name_MON_SDS_Ack)
        name_MON_SDS_Ack->PrintXML(os,"name-MON-SDS-Ack");
      else
      {
        os << "<name-MON-SDS-Ack -- void3 -- /name-MON-SDS-Ack>" << std::endl;
      }
      break;

    case name_MON_CC_InformationCid:
      if (name_MON_CC_Information)
        name_MON_CC_Information->PrintXML(os,"name-MON-CC-Information");
      else
      {
        os << "<name-MON-CC-Information -- void3 -- /name-MON-CC-Information>" << std::endl;
      }
      break;

    case name_MON_TxDemandCid:
      if (name_MON_TxDemand)
        name_MON_TxDemand->PrintXML(os,"name-MON-TxDemand");
      else
      {
        os << "<name-MON-TxDemand -- void3 -- /name-MON-TxDemand>" << std::endl;
      }
      break;

    case name_MON_TxCeasedCid:
      if (name_MON_TxCeased)
        name_MON_TxCeased->PrintXML(os,"name-MON-TxCeased");
      else
      {
        os << "<name-MON-TxCeased -- void3 -- /name-MON-TxCeased>" << std::endl;
      }
      break;

    case name_MON_TxGrantCid:
      if (name_MON_TxGrant)
        name_MON_TxGrant->PrintXML(os,"name-MON-TxGrant");
      else
      {
        os << "<name-MON-TxGrant -- void3 -- /name-MON-TxGrant>" << std::endl;
      }
      break;

    case name_MON_DisconnectCid:
      if (name_MON_Disconnect)
        name_MON_Disconnect->PrintXML(os,"name-MON-Disconnect");
      else
      {
        os << "<name-MON-Disconnect -- void3 -- /name-MON-Disconnect>" << std::endl;
      }
      break;

    case name_MON_Intercept_ReqCid:
      if (name_MON_Intercept_Req)
        name_MON_Intercept_Req->PrintXML(os,"name-MON-Intercept-Req");
      else
      {
        os << "<name-MON-Intercept-Req -- void3 -- /name-MON-Intercept-Req>" << std::endl;
      }
      break;

    case name_MON_Intercept_AckCid:
      if (name_MON_Intercept_Ack)
        name_MON_Intercept_Ack->PrintXML(os,"name-MON-Intercept-Ack");
      else
      {
        os << "<name-MON-Intercept-Ack -- void3 -- /name-MON-Intercept-Ack>" << std::endl;
      }
      break;

    case name_MON_Intercept_ConnectCid:
      if (name_MON_Intercept_Connect)
        name_MON_Intercept_Connect->PrintXML(os,"name-MON-Intercept-Connect");
      else
      {
        os << "<name-MON-Intercept-Connect -- void3 -- /name-MON-Intercept-Connect>" << std::endl;
      }
      break;

    case name_MON_Intercept_DisconnectCid:
      if (name_MON_Intercept_Disconnect)
        name_MON_Intercept_Disconnect->PrintXML(os,"name-MON-Intercept-Disconnect");
      else
      {
        os << "<name-MON-Intercept-Disconnect -- void3 -- /name-MON-Intercept-Disconnect>" << std::endl;
      }
      break;

    case name_MON_Intercept_Disconnect_AckCid:
      if (name_MON_Intercept_Disconnect_Ack)
        name_MON_Intercept_Disconnect_Ack->PrintXML(os,"name-MON-Intercept-Disconnect-Ack");
      else
      {
        os << "<name-MON-Intercept-Disconnect-Ack -- void3 -- /name-MON-Intercept-Disconnect-Ack>" << std::endl;
      }
      break;

    case name_MON_ForcedCallEndCid:
      if (name_MON_ForcedCallEnd)
        name_MON_ForcedCallEnd->PrintXML(os,"name-MON-ForcedCallEnd");
      else
      {
        os << "<name-MON-ForcedCallEnd -- void3 -- /name-MON-ForcedCallEnd>" << std::endl;
      }
      break;

    case name_MON_ForcedCallEnd_AckCid:
      if (name_MON_ForcedCallEnd_Ack)
        name_MON_ForcedCallEnd_Ack->PrintXML(os,"name-MON-ForcedCallEnd-Ack");
      else
      {
        os << "<name-MON-ForcedCallEnd-Ack -- void3 -- /name-MON-ForcedCallEnd-Ack>" << std::endl;
      }
      break;

    case name_MON_Uplink_TxDemandCid:
      if (name_MON_Uplink_TxDemand)
        name_MON_Uplink_TxDemand->PrintXML(os,"name-MON-Uplink-TxDemand");
      else
      {
        os << "<name-MON-Uplink-TxDemand -- void3 -- /name-MON-Uplink-TxDemand>" << std::endl;
      }
      break;

    case name_MON_Uplink_TxCeasedCid:
      if (name_MON_Uplink_TxCeased)
        name_MON_Uplink_TxCeased->PrintXML(os,"name-MON-Uplink-TxCeased");
      else
      {
        os << "<name-MON-Uplink-TxCeased -- void3 -- /name-MON-Uplink-TxCeased>" << std::endl;
      }
      break;

    case name_MON_TxInterruptCid:
      if (name_MON_TxInterrupt)
        name_MON_TxInterrupt->PrintXML(os,"name-MON-TxInterrupt");
      else
      {
        os << "<name-MON-TxInterrupt -- void3 -- /name-MON-TxInterrupt>" << std::endl;
      }
      break;

    case name_RSM_ResourceMonitoring_ReqCid:
      if (name_RSM_ResourceMonitoring_Req)
        name_RSM_ResourceMonitoring_Req->PrintXML(os,"name-RSM-ResourceMonitoring-Req");
      else
      {
        os << "<name-RSM-ResourceMonitoring-Req -- void3 -- /name-RSM-ResourceMonitoring-Req>" << std::endl;
      }
      break;

    case name_RSM_ResourceState_IndCid:
      if (name_RSM_ResourceState_Ind)
        name_RSM_ResourceState_Ind->PrintXML(os,"name-RSM-ResourceState-Ind");
      else
      {
        os << "<name-RSM-ResourceState-Ind -- void3 -- /name-RSM-ResourceState-Ind>" << std::endl;
      }
      break;

    case name_RSM_ResourceMonitoring_CloseCid:
      if (name_RSM_ResourceMonitoring_Close)
        name_RSM_ResourceMonitoring_Close->PrintXML(os,"name-RSM-ResourceMonitoring-Close");
      else
      {
        os << "<name-RSM-ResourceMonitoring-Close -- void3 -- /name-RSM-ResourceMonitoring-Close>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</ACAPI_PDUChoice>";
} // ACAPI_PDUChoice::PrintXML

void ACAPI_PDU::Init(void)
{
  priorityFlag = NULL;
}


int ACAPI_PDU::checkConstraints(ConstraintFailList* pConstraintFails) const{
	serviceHandle.checkConstraints(pConstraintFails);

	serviceTxMessageID.checkConstraints(pConstraintFails);

	serviceRxMessageID.checkConstraints(pConstraintFails);

	if (priorityFlag != NULL)
		priorityFlag->checkConstraints(pConstraintFails);

	choice.checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_PDU::Clear()
{
  if(priorityFlag)
    delete priorityFlag;
  priorityFlag = NULL;
  choice.Clear();
}

ACAPI_PDU::ACAPI_PDU(const ACAPI_PDU &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_PDU::Clone() const
{
  return new ACAPI_PDU(*this);
}

ACAPI_PDU &ACAPI_PDU::operator = (const ACAPI_PDU &that)
{
  if (this != &that)
  {
    Clear();
    serviceHandle = that.serviceHandle;
    serviceTxMessageID = that.serviceTxMessageID;
    serviceRxMessageID = that.serviceRxMessageID;
    if (that.priorityFlag)
    {
      if (!priorityFlag)
        priorityFlag = new AsnBool;
      *priorityFlag = *that.priorityFlag;
    }
    else
    {
      delete priorityFlag;
      priorityFlag = NULL;
    }
    choice = that.choice;
  }

  return *this;
}

AsnLen
ACAPI_PDU::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = choice.BEncContent (_b);
    totalLen += l;

  if (NOT_NULL (priorityFlag))
  {
    l = priorityFlag->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 3);
    totalLen += l;
  }

    l = serviceRxMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    l = serviceTxMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = serviceHandle.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_PDU::BEncContent


void ACAPI_PDU::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_PDU::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceHandle.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceTxMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    serviceRxMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  priorityFlag = new AsnBool;
    priorityFlag->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if ((tag1 == MAKE_TAG_ID (APPL, CONS, 10))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 11))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 12))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 13))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 14))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 15))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 16))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 17))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 20))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 21))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 30))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 120))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 31))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 32))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 33))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 34))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 35))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 36))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 37))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 38))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 39))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 40))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 45))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 46))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 47))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 122))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 48))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 49))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 41))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 42))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 43))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 44))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 123))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 121))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 50))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 51))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 52))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 53))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 54))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 55))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 56))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 57))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 58))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 59))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 60))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 61))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 62))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 63))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 64))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 65))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 66))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 67))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 68))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 69))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 130))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 131))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 110))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 111))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 112))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 113))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 114))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 115))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 116))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 117))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 70))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 71))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 72))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 73))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 74))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 75))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 76))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 77))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 78))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 79))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 80))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 81))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 82))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 83))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 84))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 85))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 86))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 87))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 88))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 89))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 90))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 91))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 92))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 93))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 95))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 96))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 100))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 101))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 102)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    choice.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_PDU::BDecContent

AsnLen ACAPI_PDU::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 1);
  return l;
}

void ACAPI_PDU::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_PDU::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 1))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_PDU::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "serviceHandle ";
	serviceHandle.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceTxMessageID ";
	serviceTxMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "serviceRxMessageID ";
	serviceRxMessageID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (priorityFlag))
	{
		Indent(os, indent);
		os << "priorityFlag ";
		priorityFlag->Print(os, indent);
	}

	Indent(os, indent);
	os << "choice ";
	choice.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_PDU::Print()

void ACAPI_PDU::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    serviceHandle.PrintXML(os, "serviceHandle");

    serviceTxMessageID.PrintXML(os, "serviceTxMessageID");

    serviceRxMessageID.PrintXML(os, "serviceRxMessageID");

  if (NOT_NULL (priorityFlag))
  {
    priorityFlag->PrintXML(os, "priorityFlag");
  }

    choice.PrintXML(os, "choice");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_PDU::PrintXML


ACAPI_TransportChoice::ACAPI_TransportChoice(const ACAPI_TransportChoice &that)
{
   Init();
   *this = that;
}
void ACAPI_TransportChoice::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = name_ACAPI_PDUCid;
  name_ACAPI_PDU = NULL;
}


int ACAPI_TransportChoice::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (name_ACAPI_PDU != NULL)
		name_ACAPI_PDU->checkConstraints(pConstraintFails);

	if (name_ACAPI_Transport_Ack != NULL)
		name_ACAPI_Transport_Ack->checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_TransportChoice::Clear()
{
  switch (choiceId)
  {
    case name_ACAPI_PDUCid:
      delete name_ACAPI_PDU;
      name_ACAPI_PDU = NULL;
      break;
    case name_ACAPI_Transport_AckCid:
      delete name_ACAPI_Transport_Ack;
      name_ACAPI_Transport_Ack = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *ACAPI_TransportChoice::Clone() const
{
  return new ACAPI_TransportChoice(*this);
}

ACAPI_TransportChoice &ACAPI_TransportChoice::operator = (const ACAPI_TransportChoice &that)
{
  if (this != &that)
  {
    Clear();
    // Check first type in choice to determine if choice is empty
    if (that.name_ACAPI_PDU != NULL)
    {
       switch (choiceId = that.choiceId)
       {
         case name_ACAPI_PDUCid:
           name_ACAPI_PDU = new ACAPI_PDU(*that.name_ACAPI_PDU);
           break;
         case name_ACAPI_Transport_AckCid:
           name_ACAPI_Transport_Ack = new ACAPI_Transport_Ack(*that.name_ACAPI_Transport_Ack);
           break;
       }// end of switch
     }// end of if
  }

  return *this;
}

AsnLen
ACAPI_TransportChoice::BEncContent (AsnBuf &_b) const
{
    FUNC("ACAPI_TransportChoice::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case name_ACAPI_PDUCid:
      l = name_ACAPI_PDU->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 1);
      break;

    case name_ACAPI_Transport_AckCid:
      l = name_ACAPI_Transport_Ack->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, APPL, CONS, 2);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // ACAPI_TransportChoice::BEncContent


void ACAPI_TransportChoice::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("ACAPI_TransportChoice::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (APPL, CONS, 1):
      choiceId = name_ACAPI_PDUCid;
        name_ACAPI_PDU = new ACAPI_PDU;
        name_ACAPI_PDU->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (APPL, CONS, 2):
      choiceId = name_ACAPI_Transport_AckCid;
        name_ACAPI_Transport_Ack = new ACAPI_Transport_Ack;
        name_ACAPI_Transport_Ack->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // ACAPI_TransportChoice::BDecContent


AsnLen ACAPI_TransportChoice::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void ACAPI_TransportChoice::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void ACAPI_TransportChoice::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case name_ACAPI_PDUCid:
		os << "name-ACAPI-PDU ";
		if (name_ACAPI_PDU)
			name_ACAPI_PDU->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case name_ACAPI_Transport_AckCid:
		os << "name-ACAPI-Transport-Ack ";
		if (name_ACAPI_Transport_Ack)
			name_ACAPI_Transport_Ack->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of ACAPI_TransportChoice::Print()

void ACAPI_TransportChoice::PrintXML (std::ostream &os, const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
        os << " typeName=\"ACAPI_TransportChoice\" type=\"CHOICE\">";
  }
  else
        os << "<ACAPI_TransportChoice type=\"CHOICE\">";
  switch (choiceId)
  {
    case name_ACAPI_PDUCid:
      if (name_ACAPI_PDU)
        name_ACAPI_PDU->PrintXML(os,"name-ACAPI-PDU");
      else
      {
        os << "<name-ACAPI-PDU -- void3 -- /name-ACAPI-PDU>" << std::endl;
      }
      break;

    case name_ACAPI_Transport_AckCid:
      if (name_ACAPI_Transport_Ack)
        name_ACAPI_Transport_Ack->PrintXML(os,"name-ACAPI-Transport-Ack");
      else
      {
        os << "<name-ACAPI-Transport-Ack -- void3 -- /name-ACAPI-Transport-Ack>" << std::endl;
      }
      break;

  } // end of switch
  if (lpszTitle)
     os << "</" << lpszTitle << ">";
  else
        os << "</ACAPI_TransportChoice>";
} // ACAPI_TransportChoice::PrintXML

void ACAPI_Transport::Init(void)
{
  priorityFlag = NULL;
}


int ACAPI_Transport::checkConstraints(ConstraintFailList* pConstraintFails) const{
	applTxMessageID.checkConstraints(pConstraintFails);

	applRxMessageID.checkConstraints(pConstraintFails);

	if (priorityFlag != NULL)
		priorityFlag->checkConstraints(pConstraintFails);

	choice.checkConstraints(pConstraintFails);

	return 0;
}


void ACAPI_Transport::Clear()
{
  if(priorityFlag)
    delete priorityFlag;
  priorityFlag = NULL;
  choice.Clear();
}

ACAPI_Transport::ACAPI_Transport(const ACAPI_Transport &that)
{
   Init();
   *this = that;
}
AsnType *ACAPI_Transport::Clone() const
{
  return new ACAPI_Transport(*this);
}

ACAPI_Transport &ACAPI_Transport::operator = (const ACAPI_Transport &that)
{
  if (this != &that)
  {
    Clear();
    applTxMessageID = that.applTxMessageID;
    applRxMessageID = that.applRxMessageID;
    if (that.priorityFlag)
    {
      if (!priorityFlag)
        priorityFlag = new AsnBool;
      *priorityFlag = *that.priorityFlag;
    }
    else
    {
      delete priorityFlag;
      priorityFlag = NULL;
    }
    choice = that.choice;
  }

  return *this;
}

AsnLen
ACAPI_Transport::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = choice.BEncContent (_b);
    totalLen += l;

  if (NOT_NULL (priorityFlag))
  {
    l = priorityFlag->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;
  }

    l = applRxMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 1);
    totalLen += l;

    l = applTxMessageID.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // ACAPI_Transport::BEncContent


void ACAPI_Transport::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Transport::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    applTxMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    applRxMessageID.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  priorityFlag = new AsnBool;
    priorityFlag->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if ((tag1 == MAKE_TAG_ID (APPL, CONS, 1))
    || (tag1 == MAKE_TAG_ID (APPL, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    choice.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ACAPI_Transport::BDecContent

AsnLen ACAPI_Transport::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, APPL, CONS, 0);
  return l;
}

void ACAPI_Transport::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ACAPI_Transport::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (APPL, CONS, 0))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ACAPI_Transport::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "applTxMessageID ";
	applTxMessageID.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "applRxMessageID ";
	applRxMessageID.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (priorityFlag))
	{
		Indent(os, indent);
		os << "priorityFlag ";
		priorityFlag->Print(os, indent);
	}

	Indent(os, indent);
	os << "choice ";
	choice.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ACAPI_Transport::Print()

void ACAPI_Transport::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    applTxMessageID.PrintXML(os, "applTxMessageID");

    applRxMessageID.PrintXML(os, "applRxMessageID");

  if (NOT_NULL (priorityFlag))
  {
    priorityFlag->PrintXML(os, "priorityFlag");
  }

    choice.PrintXML(os, "choice");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // ACAPI_Transport::PrintXML


#ifndef NO_NAMESPACE
} // namespace close
#endif
