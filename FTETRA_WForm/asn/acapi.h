//   NOTE: this is a machine generated file--editing not recommended
//
// acapi.h - class definitions for ASN.1 module ACAPI
//
//   This file was generated by snacc on Tue Apr 25 09:49:14 2006
//   UBC snacc by Mike Sample

#ifndef _acapi_h_
#define _acapi_h_


#include "asn-incl.h"
#include "asn-listset.h"

#ifndef NO_NAMESPACE
namespace SNACC {
#endif
//------------------------------------------------------------------------------
// class declarations:

class SS_AbortCauseTypeInt1;
class SS_AbortCauseTypeInt;
class DynGroupMemberStateInt;
class ResourceLoadInfoInt;
class SystemConnectionStateInt;
class LineInfoAckTypeInt;
class RSM_ResourceMonitoring_CloseInt;
class MON_ForcedCallEnd_AckInt;
class MON_SDS_AckInt;
class MON_Close_AckInt;
class MON_CloseInt;
class SS_ObjectIdentityDeassignInt;
class SS_DynGroupDeassign_AckInt;
class SS_DynGroupAssign_AckInt1;
class SS_DynGroupAssign_AckInt;
class SS_DynGroupAssignInt1;
class SS_DynGroupAssignInt;
class SS_DynGroupDel_AckInt;
class SS_DynGroupAdd_AckInt1;
class SS_DynGroupAdd_AckInt;
class SS_DynGroupAddInt1;
class SS_DynGroupAddInt;
class SS_GroupDetach_AckInt;
class SS_GroupAttach_AckInt;
class CC_ForcedCallEnd_AckInt;
class CC_DialupLine_InfoInt;
class CC_TxContinue_AckInt;
class CC_TxWait_AckInt;
class CC_InformationInt;
class SDS_Data_AckInt;
class ACAPI_CloseService_AckInt;
class ACAPI_CloseServiceInt;
class ServiceIDType;
class AreaType;
class PriorityType;
class TxPriorityType;
class TxGrantType;
class CallOwnerType;
class CallPriorityType;
class CommType;
class CircuitModeType;
class SS_NotificationType;
class AirEncryptionType;
class CliType;
class CallStateType;
class DisconnectType;
class MonitoringService;
class MonCallStateType;
class LocUpdateType;
class AuthorizationMethodType;
class TetraCallTime;
class CallSetupTime;
class CallForwardingType;
class ForwardingServiceType;
class CallForwardingResultType;
class UseOociAsCliType;
class OociResultType;
class CallForwardingReasonType;
class SDSDataTypeSeq;
class ACAPI_Transport_Ack;
class ACAPI_Message_Ack;
class SS_CallForwardCancelAll;
class SS_CallForwardInterrogate;
class MON_Data_Ack;
class LeasedLineType;
class ChannelMask_64k;
class ChannelMask_8k;
class FragmentationInfoType;
class ACAPI_CloseService_Ack;
class CC_ForcedCallEnd;
class CC_ForcedCallEnd_Ack;
class SS_CallForwardCancel_Ack;
class SS_ObjectIdentityCancelGateway;
class SS_ObjectIdentityCancelGateway_Ack;
class SS_ObjectIdentityInterrogate;
class MON_FleetMonitoring_Req;
class MON_FleetMonitoring_Ack;
class MON_Close_Ack;
class MON_ForcedCallEnd;
class MON_ForcedCallEnd_Ack;
class RSM_ResourceMonitoring_Close;
class TETRA_Address;
class ISDN_Address;
class AddressType;
class SDSDataType;
class BasicServiceType;
class LocationAreaType;
class DialupLineType;
class LineInformationType;
class LineResourceInfo;
class LineInfoAckType;
class DialupLineMask;
class LineInformationMask;
class SystemConnectionState;
class ResourceLoadInfo;
class MacFacilityType;
class DynGroupMemberState;
class CallTransferType;
class CallForwardingEntryType;
class OociEntryType;
class SS_AbortCauseType;
class RSM_ResourceState_IndSeqOf2;
class RSM_ResourceState_IndSeqOf1;
class RSM_ResourceState_IndSeqOf;
class RSM_ResourceMonitoring_ReqSeqOf;
class SS_ObjectIdentityInterrogate_AckSeqOf;
class SS_CallForwardInterrogate_AckSeqOf;
class SS_DynGroupInterrogate_AckSeqOf;
class SS_DynGroupDelSeqOf;
class SS_DynGroupAddSeqOf;
class CC_InformationSeqOf;
class ACAPI_OpenServiceSeqOf;
class ACAPI_OpenService;
class ACAPI_OpenService_Ack;
class ACAPI_CloseService;
class ACAPI_Authorization_Req;
class ACAPI_Authorization;
class ACAPI_Error_Info;
class SDS_Data;
class SDS_Data_Ack;
class CC_Setup_Req;
class CC_SetupInclude_Req;
class CC_Setup_Ind;
class CC_Setup_Ack;
class CC_Information;
class CC_Connect_Req;
class CC_Connect_Ind;
class CC_Connect_Ack;
class CC_TxDemand;
class CC_TxGrant;
class CC_TxCeased;
class CC_TxInterrupt;
class CC_TxWait_Ind;
class CC_TxWait_Req;
class CC_TxWait_Ack;
class CC_TxContinue_Ind;
class CC_TxContinue_Req;
class CC_TxContinue_Ack;
class CC_CancelInclude;
class CC_Disconnect;
class CC_Disconnect_Ack;
class CC_DialupLine_Info;
class SS_GroupAttach;
class SS_GroupAttach_Ack;
class SS_GroupDetach;
class SS_GroupDetach_Ack;
class SS_DynGroupAdd;
class SS_DynGroupDel;
class SS_DynGroupAdd_Ack;
class SS_DynGroupDel_Ack;
class SS_DynGroupInterrogate;
class SS_DynGroupInterrogate_Ack;
class SS_DynGroupAssign;
class SS_DynGroupAssign_Ack;
class SS_DynGroupDeassign;
class SS_DynGroupDeassign_Ack;
class SS_CallForwardActivate;
class SS_CallForwardActivate_Ack;
class SS_CallForwardDeactivate;
class SS_CallForwardDeactivate_Ack;
class SS_CallForwardInterrogate_Ack;
class SS_ObjectIdentityAssign;
class SS_ObjectIdentityAssign_Ack;
class SS_ObjectIdentityDeassign;
class SS_ObjectIdentityDeassign_Ack;
class SS_ObjectIdentityInterrogate_Ack;
class MON_Monitoring_Req;
class MON_Monitoring_Ack;
class MON_Close;
class MON_LocationUpdate;
class MON_LocationDetach;
class MON_SDS_Data;
class MON_SDS_Ack;
class MON_CC_Information;
class MON_TxDemand;
class MON_Uplink_TxDemand;
class MON_TxCeased;
class MON_Uplink_TxCeased;
class MON_TxGrant;
class MON_Disconnect;
class MON_Intercept_Req;
class MON_Intercept_Ack;
class MON_Intercept_Connect;
class MON_Intercept_Disconnect;
class MON_Intercept_Disconnect_Ack;
class MON_TxInterrupt;
class RSM_ResourceMonitoring_Req;
class RSM_ResourceState_Ind;
class ACAPI_PDUChoice;
class ACAPI_PDU;
class ACAPI_TransportChoice;
class ACAPI_Transport;

//------------------------------------------------------------------------------
// externs for value defs

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// class definitions:

/* INTEGER { reserved (0), serviceNotSupported (1), userNotAuthorized (2), affectedUserBusy (3), secondListeningPartyNotIncluded (4), unknownTETRAIdentity (5), parametersNotValid (6), insufficientInformation (7), rejectedForUndefinedReason (8) }  */
class  SS_AbortCauseTypeInt1: public AsnInt
{
public:
			SS_AbortCauseTypeInt1(): AsnInt() {}
			SS_AbortCauseTypeInt1 (int i): AsnInt (i) {}

	enum
	{
		reserved = 0,
		serviceNotSupported = 1,
		userNotAuthorized = 2,
		affectedUserBusy = 3,
		secondListeningPartyNotIncluded = 4,
		unknownTETRAIdentity = 5,
		parametersNotValid = 6,
		insufficientInformation = 7,
		rejectedForUndefinedReason = 8
	};
};


/* INTEGER { restrictedGeneralOrUndefined (0), restrictedBasicService (1), restrictedDestinationAddress (2), restrictedSourceAddress (3), restrictedArea (4) }  */
class  SS_AbortCauseTypeInt: public AsnInt
{
public:
			SS_AbortCauseTypeInt(): AsnInt() {}
			SS_AbortCauseTypeInt (int i): AsnInt (i) {}

	enum
	{
		restrictedGeneralOrUndefined = 0,
		restrictedBasicService = 1,
		restrictedDestinationAddress = 2,
		restrictedSourceAddress = 3,
		restrictedArea = 4
	};
};


/* INTEGER { attachmentFailedUnknownState (0), permanentlyAttached (1), noAttachmentUnknownState (2) }  */
class  DynGroupMemberStateInt: public AsnInt
{
public:
			DynGroupMemberStateInt(): AsnInt() {}
			DynGroupMemberStateInt (int i): AsnInt (i) {}

	enum
	{
		attachmentFailedUnknownState = 0,
		permanentlyAttached = 1,
		noAttachmentUnknownState = 2
	};
};


/* INTEGER { normalLoad (0), highLoad (1), overLoad (2) }  */
class  ResourceLoadInfoInt: public AsnInt
{
public:
			ResourceLoadInfoInt(): AsnInt() {}
			ResourceLoadInfoInt (int i): AsnInt (i) {}

	enum
	{
		normalLoad = 0,
		highLoad = 1,
		overLoad = 2
	};
};


/* INTEGER { connected (0), disconnected (1), timedOut (2) }  */
class  SystemConnectionStateInt: public AsnInt
{
public:
			SystemConnectionStateInt(): AsnInt() {}
			SystemConnectionStateInt (int i): AsnInt (i) {}

	enum
	{
		connected = 0,
		disconnected = 1,
		timedOut = 2
	};
};


/* INTEGER { lineConnected (0), lineNotConnected (1), parameterError (2), unknownLineResource (3), inactiveLineResource (4), lineResourceUsedInOtherCall (5) }  */
class  LineInfoAckTypeInt: public AsnInt
{
public:
			LineInfoAckTypeInt(): AsnInt() {}
			LineInfoAckTypeInt (int i): AsnInt (i) {}

	enum
	{
		lineConnected = 0,
		lineNotConnected = 1,
		parameterError = 2,
		unknownLineResource = 3,
		inactiveLineResource = 4,
		lineResourceUsedInOtherCall = 5
	};
};


/* INTEGER { closeRequest (0), noPermission (1), lineResourceError (2), connectionError (3), handleUnknown (4) }  */
class  RSM_ResourceMonitoring_CloseInt: public AsnInt
{
public:
			RSM_ResourceMonitoring_CloseInt(): AsnInt() {}
			RSM_ResourceMonitoring_CloseInt (int i): AsnInt (i) {}

	enum
	{
		closeRequest = 0,
		noPermission = 1,
		lineResourceError = 2,
		connectionError = 3,
		handleUnknown = 4
	};
};


/* INTEGER { forcedCallEndOK (0), failedUnspecified (1), deniedNoPermission (2), deniedWrongCallID (3) }  */
class  MON_ForcedCallEnd_AckInt: public AsnInt
{
public:
			MON_ForcedCallEnd_AckInt(): AsnInt() {}
			MON_ForcedCallEnd_AckInt (int i): AsnInt (i) {}

	enum
	{
		forcedCallEndOK = 0,
		failedUnspecified = 1,
		deniedNoPermission = 2,
		deniedWrongCallID = 3
	};
};


/* INTEGER { sdsTransferOK (0), sdsTransferFailed (1), subscriberError (2), subscriberOffline (3) }  */
class  MON_SDS_AckInt: public AsnInt
{
public:
			MON_SDS_AckInt(): AsnInt() {}
			MON_SDS_AckInt (int i): AsnInt (i) {}

	enum
	{
		sdsTransferOK = 0,
		sdsTransferFailed = 1,
		subscriberError = 2,
		subscriberOffline = 3
	};
};


/* INTEGER { closeAccepted (0), parameterError (1) }  */
class  MON_Close_AckInt: public AsnInt
{
public:
			MON_Close_AckInt(): AsnInt() {}
			MON_Close_AckInt (int i): AsnInt (i) {}

	enum
	{
		closeAccepted = 0,
		parameterError = 1
	};
};


/* INTEGER { closeRequest (0), noPermission (1), subscriberError (2), serviceNotAvail (3), fleetUnknown (4), endTimeExpired (5), alreadyMonByOtherGW (6), unknownVirtDest (7) }  */
class  MON_CloseInt: public AsnInt
{
public:
			MON_CloseInt(): AsnInt() {}
			MON_CloseInt (int i): AsnInt (i) {}

	enum
	{
		closeRequest = 0,
		noPermission = 1,
		subscriberError = 2,
		serviceNotAvail = 3,
		fleetUnknown = 4,
		endTimeExpired = 5,
		alreadyMonByOtherGW = 6,
		unknownVirtDest = 7
	};
};


/* INTEGER { suspend (0), delete1 (1) }  */
class  SS_ObjectIdentityDeassignInt: public AsnInt
{
public:
			SS_ObjectIdentityDeassignInt(): AsnInt() {}
			SS_ObjectIdentityDeassignInt (int i): AsnInt (i) {}

	enum
	{
		suspend = 0,
		delete1 = 1
	};
};


/* INTEGER { detached (0), detachedAndDeassigned (1) }  */
class  SS_DynGroupDeassign_AckInt: public AsnInt
{
public:
			SS_DynGroupDeassign_AckInt(): AsnInt() {}
			SS_DynGroupDeassign_AckInt (int i): AsnInt (i) {}

	enum
	{
		detached = 0,
		detachedAndDeassigned = 1
	};
};


/* INTEGER { notAttached (0), attached (1) }  */
class  SS_DynGroupAssign_AckInt1: public AsnInt
{
public:
			SS_DynGroupAssign_AckInt1(): AsnInt() {}
			SS_DynGroupAssign_AckInt1 (int i): AsnInt (i) {}

	enum
	{
		notAttached = 0,
		attached = 1
	};
};


/* INTEGER { assignmentRejectedForAnyReason (0), assignmentAccepted (1), assignmentNotAcceptedForSecurityReasons (2), assignmentRejectedForCapacityReasons (3) }  */
class  SS_DynGroupAssign_AckInt: public AsnInt
{
public:
			SS_DynGroupAssign_AckInt(): AsnInt() {}
			SS_DynGroupAssign_AckInt (int i): AsnInt (i) {}

	enum
	{
		assignmentRejectedForAnyReason = 0,
		assignmentAccepted = 1,
		assignmentNotAcceptedForSecurityReasons = 2,
		assignmentRejectedForCapacityReasons = 3
	};
};


/* INTEGER { classOfUsage1 (1), classOfUsage2 (2), classOfUsage3 (3), classOfUsage4 (4), classOfUsage5 (5), classOfUsage6 (6), classOfUsage7 (7), classOfUsage8 (8) }  */
class  SS_DynGroupAssignInt1: public AsnInt
{
public:
			SS_DynGroupAssignInt1(): AsnInt() {}
			SS_DynGroupAssignInt1 (int i): AsnInt (i) {}

	enum
	{
		classOfUsage1 = 1,
		classOfUsage2 = 2,
		classOfUsage3 = 3,
		classOfUsage4 = 4,
		classOfUsage5 = 5,
		classOfUsage6 = 6,
		classOfUsage7 = 7,
		classOfUsage8 = 8
	};
};


/* INTEGER { noAttachmentRequired (0), attachmentRequired (1) }  */
class  SS_DynGroupAssignInt: public AsnInt
{
public:
			SS_DynGroupAssignInt(): AsnInt() {}
			SS_DynGroupAssignInt (int i): AsnInt (i) {}

	enum
	{
		noAttachmentRequired = 0,
		attachmentRequired = 1
	};
};


/* INTEGER { groupDetached (0), groupDetachedAndDeassigned (1), deassignmentRejectedSSNotSupportedByMS (4), deassignmentRejectedDgnaActionNotSupportedByMS (5), deassignmentRejectedNoAnswerFromMS (6), deassignmentRejectedMSBusy (7), deassignmentRejectedMSNotAllowedToRecvAssignments (8), deassignmentRejectedGroupNotAllowedToBeDeassigned (9), deassignmentProceeding (10), deassignmentRejectedGeneralError (11), deassignmentRejectedUnknownSSITSI (12), deassignmentRejectedMSLSIsNotRegistered (13), deassignmentRejectedRoutingProblemInInfrastructure (14), deassignmentRejectedMessageConsistencyError (15) }  */
class  SS_DynGroupDel_AckInt: public AsnInt
{
public:
			SS_DynGroupDel_AckInt(): AsnInt() {}
			SS_DynGroupDel_AckInt (int i): AsnInt (i) {}

	enum
	{
		groupDetached = 0,
		groupDetachedAndDeassigned = 1,
		deassignmentRejectedSSNotSupportedByMS = 4,
		deassignmentRejectedDgnaActionNotSupportedByMS = 5,
		deassignmentRejectedNoAnswerFromMS = 6,
		deassignmentRejectedMSBusy = 7,
		deassignmentRejectedMSNotAllowedToRecvAssignments = 8,
		deassignmentRejectedGroupNotAllowedToBeDeassigned = 9,
		deassignmentProceeding = 10,
		deassignmentRejectedGeneralError = 11,
		deassignmentRejectedUnknownSSITSI = 12,
		deassignmentRejectedMSLSIsNotRegistered = 13,
		deassignmentRejectedRoutingProblemInInfrastructure = 14,
		deassignmentRejectedMessageConsistencyError = 15
	};
};


/* INTEGER { notAttached (0), attached (1) }  */
class  SS_DynGroupAdd_AckInt1: public AsnInt
{
public:
			SS_DynGroupAdd_AckInt1(): AsnInt() {}
			SS_DynGroupAdd_AckInt1 (int i): AsnInt (i) {}

	enum
	{
		notAttached = 0,
		attached = 1
	};
};


/* INTEGER { assignmentRejectedForAnyReason (0), assignmentAccepted (1), assignmentNotAcceptedForSecurityReasons (2), assignmentRejectedForCapacityExceededReasons (3), assignmentRejectedSSNotSupportedByMS (4), assignmentRejectedDgnaActionNotSupportedByMS (5), assignmentRejectedNoAnswerFromMS (6), assignmentRejectedMSIsBusy (7), assignmentRejectedMSNotAllowedToRecvAssignments (8), assignmentRejectedGroupNotAllowedToBeAssigned (9), assignmentProceeding (10), assignmentRejectedGeneralError (11), assignmentRejectedUnknownSSITSI (12), assignmentRejectedMSLSIsNotRegistered (13), assignmentRejectedRoutingProblemInInfrastructure (14), assignmentRejectedMessageConsistencyError (15) }  */
class  SS_DynGroupAdd_AckInt: public AsnInt
{
public:
			SS_DynGroupAdd_AckInt(): AsnInt() {}
			SS_DynGroupAdd_AckInt (int i): AsnInt (i) {}

	enum
	{
		assignmentRejectedForAnyReason = 0,
		assignmentAccepted = 1,
		assignmentNotAcceptedForSecurityReasons = 2,
		assignmentRejectedForCapacityExceededReasons = 3,
		assignmentRejectedSSNotSupportedByMS = 4,
		assignmentRejectedDgnaActionNotSupportedByMS = 5,
		assignmentRejectedNoAnswerFromMS = 6,
		assignmentRejectedMSIsBusy = 7,
		assignmentRejectedMSNotAllowedToRecvAssignments = 8,
		assignmentRejectedGroupNotAllowedToBeAssigned = 9,
		assignmentProceeding = 10,
		assignmentRejectedGeneralError = 11,
		assignmentRejectedUnknownSSITSI = 12,
		assignmentRejectedMSLSIsNotRegistered = 13,
		assignmentRejectedRoutingProblemInInfrastructure = 14,
		assignmentRejectedMessageConsistencyError = 15
	};
};


/* INTEGER { classOfUsage1 (1), classOfUsage2 (2), classOfUsage3 (3), classOfUsage4 (4), classOfUsage5 (5), classOfUsage6 (6), classOfUsage7 (7), classOfUsage8 (8) }  */
class  SS_DynGroupAddInt1: public AsnInt
{
public:
			SS_DynGroupAddInt1(): AsnInt() {}
			SS_DynGroupAddInt1 (int i): AsnInt (i) {}

	enum
	{
		classOfUsage1 = 1,
		classOfUsage2 = 2,
		classOfUsage3 = 3,
		classOfUsage4 = 4,
		classOfUsage5 = 5,
		classOfUsage6 = 6,
		classOfUsage7 = 7,
		classOfUsage8 = 8
	};
};


/* INTEGER { notAttached (0), attached (1) }  */
class  SS_DynGroupAddInt: public AsnInt
{
public:
			SS_DynGroupAddInt(): AsnInt() {}
			SS_DynGroupAddInt (int i): AsnInt (i) {}

	enum
	{
		notAttached = 0,
		attached = 1
	};
};


/* INTEGER { groupDetachOK (0), subscriberError (1) }  */
class  SS_GroupDetach_AckInt: public AsnInt
{
public:
			SS_GroupDetach_AckInt(): AsnInt() {}
			SS_GroupDetach_AckInt (int i): AsnInt (i) {}

	enum
	{
		groupDetachOK = 0,
		subscriberError = 1
	};
};


/* INTEGER { groupAttachOK (0), groupAttachDenied (1), subscriberError (2), alreadyAttached (3) }  */
class  SS_GroupAttach_AckInt: public AsnInt
{
public:
			SS_GroupAttach_AckInt(): AsnInt() {}
			SS_GroupAttach_AckInt (int i): AsnInt (i) {}

	enum
	{
		groupAttachOK = 0,
		groupAttachDenied = 1,
		subscriberError = 2,
		alreadyAttached = 3
	};
};


/* INTEGER { forcedCallEndOK (0), failedUnspecified (1), deniedNoPermission (2), deniedWrongCallID (3) }  */
class  CC_ForcedCallEnd_AckInt: public AsnInt
{
public:
			CC_ForcedCallEnd_AckInt(): AsnInt() {}
			CC_ForcedCallEnd_AckInt (int i): AsnInt (i) {}

	enum
	{
		forcedCallEndOK = 0,
		failedUnspecified = 1,
		deniedNoPermission = 2,
		deniedWrongCallID = 3
	};
};


/* INTEGER { lineEstablished (0), lineReleased (1), lineInfoInvalid (2), parameterError (3) }  */
class  CC_DialupLine_InfoInt: public AsnInt
{
public:
			CC_DialupLine_InfoInt(): AsnInt() {}
			CC_DialupLine_InfoInt (int i): AsnInt (i) {}

	enum
	{
		lineEstablished = 0,
		lineReleased = 1,
		lineInfoInvalid = 2,
		parameterError = 3
	};
};


/* INTEGER { txContinueOK (0), txContinueFailed (1), invalidCallID (2), subcriberError (3) }  */
class  CC_TxContinue_AckInt: public AsnInt
{
public:
			CC_TxContinue_AckInt(): AsnInt() {}
			CC_TxContinue_AckInt (int i): AsnInt (i) {}

	enum
	{
		txContinueOK = 0,
		txContinueFailed = 1,
		invalidCallID = 2,
		subcriberError = 3
	};
};


/* INTEGER { txWaitOK (0), txWaitFailed (1), invalidCallID (2), subcriberError (3) }  */
class  CC_TxWait_AckInt: public AsnInt
{
public:
			CC_TxWait_AckInt(): AsnInt() {}
			CC_TxWait_AckInt (int i): AsnInt (i) {}

	enum
	{
		txWaitOK = 0,
		txWaitFailed = 1,
		invalidCallID = 2,
		subcriberError = 3
	};
};


/* INTEGER { dtmfNotSupported (0), dtmfNotSubscribed (1), dtmfInvalidCharacter (2) }  */
class  CC_InformationInt: public AsnInt
{
public:
			CC_InformationInt(): AsnInt() {}
			CC_InformationInt (int i): AsnInt (i) {}

	enum
	{
		dtmfNotSupported = 0,
		dtmfNotSubscribed = 1,
		dtmfInvalidCharacter = 2
	};
};


/* INTEGER { sdsTransferOK (0), sdsTransferFailed (1), subscriberError (2), subscriberOffline (3), subscriberQueueOverload (4) }  */
class  SDS_Data_AckInt: public AsnInt
{
public:
			SDS_Data_AckInt(): AsnInt() {}
			SDS_Data_AckInt (int i): AsnInt (i) {}

	enum
	{
		sdsTransferOK = 0,
		sdsTransferFailed = 1,
		subscriberError = 2,
		subscriberOffline = 3,
		subscriberQueueOverload = 4
	};
};


/* INTEGER { logoutAccepted (0), parameterError (1) }  */
class  ACAPI_CloseService_AckInt: public AsnInt
{
public:
			ACAPI_CloseService_AckInt(): AsnInt() {}
			ACAPI_CloseService_AckInt (int i): AsnInt (i) {}

	enum
	{
		logoutAccepted = 0,
		parameterError = 1
	};
};


/* INTEGER { closeRequest (0), serviceUnknown (1), serviceDenied (2), subscriberUnknown (3), subscriberError (4), accessDenied (5), versionMissmatch (6), timedOut (7), overLoad (8), serviceBreakdown (9), parameterError (10), noConnectionToSwMI (11), asn1Error (12), applTxMessageIDInvalid (13), serviceTxMessageIDInvalid (14), lineResourceInvalid (15), lineResourceNotAvail (16), duplicateOpenService (17), applicationConnectionLoss (18), mismatchPduAndService (19) }  */
class  ACAPI_CloseServiceInt: public AsnInt
{
public:
			ACAPI_CloseServiceInt(): AsnInt() {}
			ACAPI_CloseServiceInt (int i): AsnInt (i) {}

	enum
	{
		closeRequest = 0,
		serviceUnknown = 1,
		serviceDenied = 2,
		subscriberUnknown = 3,
		subscriberError = 4,
		accessDenied = 5,
		versionMissmatch = 6,
		timedOut = 7,
		overLoad = 8,
		serviceBreakdown = 9,
		parameterError = 10,
		noConnectionToSwMI = 11,
		asn1Error = 12,
		applTxMessageIDInvalid = 13,
		serviceTxMessageIDInvalid = 14,
		lineResourceInvalid = 15,
		lineResourceNotAvail = 16,
		duplicateOpenService = 17,
		applicationConnectionLoss = 18,
		mismatchPduAndService = 19
	};
};


/* INTEGER 0..65535 */
class  Integer16: public AsnInt  {
    public:
        Integer16(AsnIntType val=0):AsnInt(val){ }
        Integer16(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        Integer16(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        Integer16(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        Integer16(const Integer16 &that):AsnInt(that){ }

		Integer16 & operator =(const Integer16 &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
/* INTEGER 0..16777215 */
class  SSIType: public AsnInt  {
    public:
        SSIType(AsnIntType val=0):AsnInt(val){ }
        SSIType(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        SSIType(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        SSIType(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        SSIType(const SSIType &that):AsnInt(that){ }

		SSIType & operator =(const SSIType &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
/* INTEGER 0..1023 */
class  MCCType: public AsnInt  {
    public:
        MCCType(AsnIntType val=0):AsnInt(val){ }
        MCCType(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        MCCType(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        MCCType(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        MCCType(const MCCType &that):AsnInt(that){ }

		MCCType & operator =(const MCCType &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
/* INTEGER 0..16383 */
class  MNCType: public AsnInt  {
    public:
        MNCType(AsnIntType val=0):AsnInt(val){ }
        MNCType(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        MNCType(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        MNCType(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        MNCType(const MNCType &that):AsnInt(that){ }

		MNCType & operator =(const MNCType &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
/* IA5String (SIZE 1..24)(FROM "0123456789*#,") */
class  DialingString: public IA5String  {
     public:
        DialingString():IA5String(){ }

		const SizeConstraint* SizeConstraints(int &sizeList)const;

		const char* PermittedAlphabet(int &sizePermittedAlpha)const;

		DialingString& operator=(const char* str)
			  { IA5String::operator=(str); return *this;}
		DialingString& operator=(const std::string& str)
			  { IA5String::operator=(str); return *this;}
  };

/* IA5String (SIZE 1..255)(FROM "0123456789*#ABCD") */
class  DTMFString: public IA5String  {
     public:
        DTMFString():IA5String(){ }

		const SizeConstraint* SizeConstraints(int &sizeList)const;

		const char* PermittedAlphabet(int &sizePermittedAlpha)const;

		DTMFString& operator=(const char* str)
			  { IA5String::operator=(str); return *this;}
		DTMFString& operator=(const std::string& str)
			  { IA5String::operator=(str); return *this;}
  };

/* INTEGER { callControl (0), shortData (1), monitoring (2), subscriberManagement (3), stateMonTerminalService (4), stateMonMonitoringService (5), maintenance (6), supplementaryService (7) }  */
class  ServiceIDType: public AsnInt
{
public:
			ServiceIDType(): AsnInt() {}
			ServiceIDType (int i): AsnInt (i) {}

	enum
	{
		callControl = 0,
		shortData = 1,
		monitoring = 2,
		subscriberManagement = 3,
		stateMonTerminalService = 4,
		stateMonMonitoringService = 5,
		maintenance = 6,
		supplementaryService = 7
	};
};


/* ENUMERATED { areaNotDefined (0), area1 (1), area2 (2), area3 (3), area4 (4), area5 (5), area6 (6), area7 (7), area8 (8), area9 (9), area10 (10), area11 (11), area12 (12), area13 (13), area14 (14), allAreas (15) }  */
class  AreaType: public AsnEnum
{
public:
			AreaType(): AsnEnum() {}
			AreaType (int i): AsnEnum (i) {}

	enum
	{
		areaNotDefined = 0,
		area1 = 1,
		area2 = 2,
		area3 = 3,
		area4 = 4,
		area5 = 5,
		area6 = 6,
		area7 = 7,
		area8 = 8,
		area9 = 9,
		area10 = 10,
		area11 = 11,
		area12 = 12,
		area13 = 13,
		area14 = 14,
		allAreas = 15
	};
  AsnLen PEnc(AsnBufBits &_b)const{
     long enumList[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
       AsnInt index = IndexedVal(enumList, 16);
       AsnLen len = index.PEncFullyConstrained(_b, 0, 15);
       return len;}
  void PDec(AsnBufBits &_b, AsnLen &bitsDecoded){
     long enumList[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
     AsnInt index;
     index.PDecFullyConstrained(_b, 0, 15, bitsDecoded);
     SetIndex(enumList, 16, index);}
};


/* ENUMERATED { priorityNotDefined (0), lowPriority (1), highPriority (2), emergencyPriority (3) }  */
class  PriorityType: public AsnEnum
{
public:
			PriorityType(): AsnEnum() {}
			PriorityType (int i): AsnEnum (i) {}

	enum
	{
		priorityNotDefined = 0,
		lowPriority = 1,
		highPriority = 2,
		emergencyPriority = 3
	};
  AsnLen PEnc(AsnBufBits &_b)const{
     long enumList[] = {0, 1, 2, 3 };
       AsnInt index = IndexedVal(enumList, 4);
       AsnLen len = index.PEncFullyConstrained(_b, 0, 3);
       return len;}
  void PDec(AsnBufBits &_b, AsnLen &bitsDecoded){
     long enumList[] = {0, 1, 2, 3 };
     AsnInt index;
     index.PDecFullyConstrained(_b, 0, 3, bitsDecoded);
     SetIndex(enumList, 4, index);}
};


/* ENUMERATED { lowLevel (0), highLevel (1), preEmptiveLevel (2), emergencyLevel (3), extraEmergencyLevel1 (4), extraEmergencyLevel2 (5) }  */
class  TxPriorityType: public AsnEnum
{
public:
			TxPriorityType(): AsnEnum() {}
			TxPriorityType (int i): AsnEnum (i) {}

	enum
	{
		lowLevel = 0,
		highLevel = 1,
		preEmptiveLevel = 2,
		emergencyLevel = 3,
		extraEmergencyLevel1 = 4,
		extraEmergencyLevel2 = 5
	};
  AsnLen PEnc(AsnBufBits &_b)const{
     long enumList[] = {0, 1, 2, 3, 4, 5 };
       AsnInt index = IndexedVal(enumList, 6);
       AsnLen len = index.PEncFullyConstrained(_b, 0, 5);
       return len;}
  void PDec(AsnBufBits &_b, AsnLen &bitsDecoded){
     long enumList[] = {0, 1, 2, 3, 4, 5 };
     AsnInt index;
     index.PDecFullyConstrained(_b, 0, 5, bitsDecoded);
     SetIndex(enumList, 6, index);}
};


/* ENUMERATED { txGranted (0), txNotGranted (1), txRequestQueued (2), txGrantedToAnotherUser (3) }  */
class  TxGrantType: public AsnEnum
{
public:
			TxGrantType(): AsnEnum() {}
			TxGrantType (int i): AsnEnum (i) {}

	enum
	{
		txGranted = 0,
		txNotGranted = 1,
		txRequestQueued = 2,
		txGrantedToAnotherUser = 3
	};
  AsnLen PEnc(AsnBufBits &_b)const{
     long enumList[] = {0, 1, 2, 3 };
       AsnInt index = IndexedVal(enumList, 4);
       AsnLen len = index.PEncFullyConstrained(_b, 0, 3);
       return len;}
  void PDec(AsnBufBits &_b, AsnLen &bitsDecoded){
     long enumList[] = {0, 1, 2, 3 };
     AsnInt index;
     index.PDecFullyConstrained(_b, 0, 3, bitsDecoded);
     SetIndex(enumList, 4, index);}
};


/* ENUMERATED { notCallOwner (0), normalCallSetup (1), callOwner (2), amalgamatedCall (3) }  */
class  CallOwnerType: public AsnEnum
{
public:
			CallOwnerType(): AsnEnum() {}
			CallOwnerType (int i): AsnEnum (i) {}

	enum
	{
		notCallOwner = 0,
		normalCallSetup = 1,
		callOwner = 2,
		amalgamatedCall = 3
	};
  AsnLen PEnc(AsnBufBits &_b)const{
     long enumList[] = {0, 1, 2, 3 };
       AsnInt index = IndexedVal(enumList, 4);
       AsnLen len = index.PEncFullyConstrained(_b, 0, 3);
       return len;}
  void PDec(AsnBufBits &_b, AsnLen &bitsDecoded){
     long enumList[] = {0, 1, 2, 3 };
     AsnInt index;
     index.PDecFullyConstrained(_b, 0, 3, bitsDecoded);
     SetIndex(enumList, 4, index);}
};


/* ENUMERATED { priorityNotDefined (0), priority1 (1), priority2 (2), priority3 (3), priority4 (4), priority5 (5), priority6 (6), priority7 (7), priority8 (8), priority9 (9), priority10 (10), priority11 (11), preEmptivePrio1 (12), preEmptivePrio2 (13), preEmptivePrio3 (14), preEmptivePrio4 (15) }  */
class  CallPriorityType: public AsnEnum
{
public:
			CallPriorityType(): AsnEnum() {}
			CallPriorityType (int i): AsnEnum (i) {}

	enum
	{
		priorityNotDefined = 0,
		priority1 = 1,
		priority2 = 2,
		priority3 = 3,
		priority4 = 4,
		priority5 = 5,
		priority6 = 6,
		priority7 = 7,
		priority8 = 8,
		priority9 = 9,
		priority10 = 10,
		priority11 = 11,
		preEmptivePrio1 = 12,
		preEmptivePrio2 = 13,
		preEmptivePrio3 = 14,
		preEmptivePrio4 = 15
	};
  AsnLen PEnc(AsnBufBits &_b)const{
     long enumList[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
       AsnInt index = IndexedVal(enumList, 16);
       AsnLen len = index.PEncFullyConstrained(_b, 0, 15);
       return len;}
  void PDec(AsnBufBits &_b, AsnLen &bitsDecoded){
     long enumList[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
     AsnInt index;
     index.PDecFullyConstrained(_b, 0, 15, bitsDecoded);
     SetIndex(enumList, 16, index);}
};


/* ENUMERATED { pointToPoint (0), pointToMultipoint (1), pointToMultipointAck (2), broadcast (3) }  */
class  CommType: public AsnEnum
{
public:
			CommType(): AsnEnum() {}
			CommType (int i): AsnEnum (i) {}

	enum
	{
		pointToPoint = 0,
		pointToMultipoint = 1,
		pointToMultipointAck = 2,
		broadcast = 3
	};
  AsnLen PEnc(AsnBufBits &_b)const{
     long enumList[] = {0, 1, 2, 3 };
       AsnInt index = IndexedVal(enumList, 4);
       AsnLen len = index.PEncFullyConstrained(_b, 0, 3);
       return len;}
  void PDec(AsnBufBits &_b, AsnLen &bitsDecoded){
     long enumList[] = {0, 1, 2, 3 };
     AsnInt index;
     index.PDecFullyConstrained(_b, 0, 3, bitsDecoded);
     SetIndex(enumList, 4, index);}
};


/* INTEGER { speechTETRA (0), speechProprietary (1), dataUnprotected_7k2 (2), dataUnprotected_14k4 (3), dataUnprotected_21k6 (4), dataUnprotected_28k8 (5), dataLowProtection_4k8 (6), dataLowProtection_9k6 (7), dataLowProtection_14k4 (8), dataLowProtection_19k2 (9), dataHighProtection_2k4 (10), dataHighProtection_4k8 (11), dataHighProtection_7k2 (12), dataHighProtection_9k6 (13) }  */
class  CircuitModeType: public AsnInt
{
public:
			CircuitModeType(): AsnInt() {}
			CircuitModeType (int i): AsnInt (i) {}

	enum
	{
		speechTETRA = 0,
		speechProprietary = 1,
		dataUnprotected_7k2 = 2,
		dataUnprotected_14k4 = 3,
		dataUnprotected_21k6 = 4,
		dataUnprotected_28k8 = 5,
		dataLowProtection_4k8 = 6,
		dataLowProtection_9k6 = 7,
		dataLowProtection_14k4 = 8,
		dataLowProtection_19k2 = 9,
		dataHighProtection_2k4 = 10,
		dataHighProtection_4k8 = 11,
		dataHighProtection_7k2 = 12,
		dataHighProtection_9k6 = 13
	};
};


/* INTEGER { leBroadcast (0), leAcknowledgement (1), lePaging (2), alOperation (3), callBarredBySS_BIC (4), callBarredBySS_BOC (5), callIsForwarded (6), forwardingActivated (7), identityPresentationRestricted (8), presentationRestrictionOverridden (9), callWaitingInvoked (10), callPutOnHold (11), callOnHoldRetrieved (12), includeCall (13), multipartyCall (14), lscInvoked (15), callRejectedDueToSS_AS (16), ss_AS_NotInvoked (17), icCalledUserAlerted (18), icCalledUserConnected (19), icCalledUserIncluded (20), icInvocationFailed (21), callProceeding (22), ssCFUInvoked (23), ssCFBInvoked (24), ssCFNRyInvoked (25), ssCFNRcInvoked (26), alCallOrSpeechItem (27), callAuthorizationByDispatcher (28) }  */
class  SS_NotificationType: public AsnInt
{
public:
			SS_NotificationType(): AsnInt() {}
			SS_NotificationType (int i): AsnInt (i) {}

	enum
	{
		leBroadcast = 0,
		leAcknowledgement = 1,
		lePaging = 2,
		alOperation = 3,
		callBarredBySS_BIC = 4,
		callBarredBySS_BOC = 5,
		callIsForwarded = 6,
		forwardingActivated = 7,
		identityPresentationRestricted = 8,
		presentationRestrictionOverridden = 9,
		callWaitingInvoked = 10,
		callPutOnHold = 11,
		callOnHoldRetrieved = 12,
		includeCall = 13,
		multipartyCall = 14,
		lscInvoked = 15,
		callRejectedDueToSS_AS = 16,
		ss_AS_NotInvoked = 17,
		icCalledUserAlerted = 18,
		icCalledUserConnected = 19,
		icCalledUserIncluded = 20,
		icInvocationFailed = 21,
		callProceeding = 22,
		ssCFUInvoked = 23,
		ssCFBInvoked = 24,
		ssCFNRyInvoked = 25,
		ssCFNRcInvoked = 26,
		alCallOrSpeechItem = 27,
		callAuthorizationByDispatcher = 28
	};
};


/* INTEGER { clearMode (0), encrypeted_ClearAllowed (1), encrypeted_ClearNotAllowed (2) }  */
class  AirEncryptionType: public AsnInt
{
public:
			AirEncryptionType(): AsnInt() {}
			AirEncryptionType (int i): AsnInt (i) {}

	enum
	{
		clearMode = 0,
		encrypeted_ClearAllowed = 1,
		encrypeted_ClearNotAllowed = 2
	};
};


/* INTEGER { default1 (0), presentationNotRestricted (1), presentationRestricted (2) }  */
class  CliType: public AsnInt
{
public:
			CliType(): AsnInt() {}
			CliType (int i): AsnInt (i) {}

	enum
	{
		default1 = 0,
		presentationNotRestricted = 1,
		presentationRestricted = 2
	};
};


/* INTEGER { progressing (0), callQueued (1), subscriberPaged (2), ringing (3), callContinue (4), hangTimeExpired (5) }  */
class  CallStateType: public AsnInt
{
public:
			CallStateType(): AsnInt() {}
			CallStateType (int i): AsnInt (i) {}

	enum
	{
		progressing = 0,
		callQueued = 1,
		subscriberPaged = 2,
		ringing = 3,
		callContinue = 4,
		hangTimeExpired = 5
	};
};


class  DisconnectType: public AsnInt
{
public:
			DisconnectType(): AsnInt() {}
			DisconnectType (int i): AsnInt (i) {}

	enum
	{
		causeUnknown = 0,
		userRequestedDisconnect = 1,
		calledPartyBusy = 2,
		calledPartyNotReachable = 3,
		calledPartyDoesNotSupportEncryption = 4,
		congestionInInfrastructure = 5,
		notAllowedTrafficCase = 6,
		incompatibleTrafficCase = 7,
		requestedServiceNotAvailable = 8,
		preEmptiveUseOfResource = 9,
		invalidCallIdentifier = 10,
		callRejectedByCalledParty = 11,
		noIdleCcEntity = 12,
		expiryOfTimer = 13,
		dmxRequestedDisconnect = 14,
		acknowledgedServiceNotCompleted = 15,
		resourceFailed = 16,
		unknownResource = 17,
		inactiveResource = 18,
		resourceUsedInOtherCall = 19,
		cellReSelection = 20,
		callSetupRepetition = 21,
		icLeavingCallNoCallEnd = 22,
		unknownTetraIdentity = 23,
		ssSpecificDisconnection = 24,
		unknownExternalSubscriberIdentity = 25,
		callRestorationOfOtherUserFailed = 26,
		wrongCommunicationType = 27,
		callTransferSubscriberError = 28,
		unknownVirtualDest = 29,
		routingFailureToVirtualDest = 30,
		offlineCircuitModeMonitoringGateway = 31,
		unknownCallIdentifier = 32,
		monToSameVirtualDestAlreadyActive = 33,
		unknownMonitoringHandle = 34,
		callInWrongState = 35
	};
};


/* BIT STRING { registration (0), sdsInitiator (1), sdsDestination (2), circuitModeInitiator (3), circuitModeDestination (4), supplService (5), automaticVoiceIntercept (6) }  */
class  MonitoringService: public AsnBits
{
public:
	MonitoringService() : AsnBits()			{ nblFlag = true; }
	MonitoringService(size_t bits) : AsnBits(bits)	{ nblFlag = true; }
	MonitoringService(const unsigned char* str, const size_t bitLen) :
		AsnBits(str, bitLen)				{ nblFlag = true; }

	enum
	{
		registration = 0,
		sdsInitiator = 1,
		sdsDestination = 2,
		circuitModeInitiator = 3,
		circuitModeDestination = 4,
		supplService = 5,
		automaticVoiceIntercept = 6
	};
};


/* INTEGER { callSetup (0), callSetupReject (1), alertFromCalledParty (2), acceptFromCalledParty (3), callConnect (4), includeCallSetup (5), includeCallSetupReject (6), includeAlertFromCalledParty (7), includeAcceptFromCalledParty (8), includeCallConnect (9), groupCallWithActionFromMember (10) }  */
class  MonCallStateType: public AsnInt
{
public:
			MonCallStateType(): AsnInt() {}
			MonCallStateType (int i): AsnInt (i) {}

	enum
	{
		callSetup = 0,
		callSetupReject = 1,
		alertFromCalledParty = 2,
		acceptFromCalledParty = 3,
		callConnect = 4,
		includeCallSetup = 5,
		includeCallSetupReject = 6,
		includeAlertFromCalledParty = 7,
		includeAcceptFromCalledParty = 8,
		includeCallConnect = 9,
		groupCallWithActionFromMember = 10
	};
};


/* INTEGER { roamingLocationUpdate (0), migratingLocationUpdate (1), periodicLocationUpdate (2), iTSIAttach (3), callRestorationRoamingUpdate (4), callRestorationMigratingUpdate (5), demandLocationUpdate (6), disabledMSUpdate (7), implicitLocationUpdate (8) }  */
class  LocUpdateType: public AsnInt
{
public:
			LocUpdateType(): AsnInt() {}
			LocUpdateType (int i): AsnInt (i) {}

	enum
	{
		roamingLocationUpdate = 0,
		migratingLocationUpdate = 1,
		periodicLocationUpdate = 2,
		iTSIAttach = 3,
		callRestorationRoamingUpdate = 4,
		callRestorationMigratingUpdate = 5,
		demandLocationUpdate = 6,
		disabledMSUpdate = 7,
		implicitLocationUpdate = 8
	};
};


/* INTEGER { plain (0), secureHashAlgorithm (1), tetra (2) }  */
class  AuthorizationMethodType: public AsnInt
{
public:
			AuthorizationMethodType(): AsnInt() {}
			AuthorizationMethodType (int i): AsnInt (i) {}

	enum
	{
		plain = 0,
		secureHashAlgorithm = 1,
		tetra = 2
	};
};


/* INTEGER { infiniteTime (0), seconds30 (1), seconds45 (2), seconds60 (3), minutes2 (4), minutes3 (5), minutes4 (6), minutes5 (7), minutes6 (8), minutes8 (9), minutes10 (10), minutes12 (11), minutes15 (12), minutes20 (13), minutes30 (14), reserved (15) }  */
class  TetraCallTime: public AsnInt
{
public:
			TetraCallTime(): AsnInt() {}
			TetraCallTime (int i): AsnInt (i) {}

	enum
	{
		infiniteTime = 0,
		seconds30 = 1,
		seconds45 = 2,
		seconds60 = 3,
		minutes2 = 4,
		minutes3 = 5,
		minutes4 = 6,
		minutes5 = 7,
		minutes6 = 8,
		minutes8 = 9,
		minutes10 = 10,
		minutes12 = 11,
		minutes15 = 12,
		minutes20 = 13,
		minutes30 = 14,
		reserved = 15
	};
};


/* INTEGER { usePredefinedValue (0), second1 (1), seconds2 (2), seconds5 (3), seconds10 (4), seconds20 (5), seconds30 (6), seconds60 (7) }  */
class  CallSetupTime: public AsnInt
{
public:
			CallSetupTime(): AsnInt() {}
			CallSetupTime (int i): AsnInt (i) {}

	enum
	{
		usePredefinedValue = 0,
		second1 = 1,
		seconds2 = 2,
		seconds5 = 3,
		seconds10 = 4,
		seconds20 = 5,
		seconds30 = 6,
		seconds60 = 7
	};
};


/* BIT STRING { unconditional (0), onBusy (1), onNoReply (2), onNotReachable (3) }  */
class  CallForwardingType: public AsnBits
{
public:
	CallForwardingType() : AsnBits()			{ nblFlag = true; }
	CallForwardingType(size_t bits) : AsnBits(bits)	{ nblFlag = true; }
	CallForwardingType(const unsigned char* str, const size_t bitLen) :
		AsnBits(str, bitLen)				{ nblFlag = true; }

	enum
	{
		unconditional = 0,
		onBusy = 1,
		onNoReply = 2,
		onNotReachable = 3
	};
};


/* INTEGER { callControl (0), shortData (1), callControlAndSds (2) }  */
class  ForwardingServiceType: public AsnInt
{
public:
			ForwardingServiceType(): AsnInt() {}
			ForwardingServiceType (int i): AsnInt (i) {}

	enum
	{
		callControl = 0,
		shortData = 1,
		callControlAndSds = 2
	};
};


/* INTEGER { generalAccept (0), generalReject (1), callForwardingNotAvailable (2), unknownForwardedParty (3), unknownForwardToParty (4), staticCallForwardingIsActive (5), dynamicCallForwardingIsActive (6), permissionDenied (7), invalidElementInPdu (8) }  */
class  CallForwardingResultType: public AsnInt
{
public:
			CallForwardingResultType(): AsnInt() {}
			CallForwardingResultType (int i): AsnInt (i) {}

	enum
	{
		generalAccept = 0,
		generalReject = 1,
		callForwardingNotAvailable = 2,
		unknownForwardedParty = 3,
		unknownForwardToParty = 4,
		staticCallForwardingIsActive = 5,
		dynamicCallForwardingIsActive = 6,
		permissionDenied = 7,
		invalidElementInPdu = 8
	};
};


/* BIT STRING { callControlToOOCI (0), callControlToSSI (1), sdsToOOCI (2), sdsToSSI (3) }  */
class  UseOociAsCliType: public AsnBits
{
public:
	UseOociAsCliType() : AsnBits()			{ nblFlag = true; }
	UseOociAsCliType(size_t bits) : AsnBits(bits)	{ nblFlag = true; }
	UseOociAsCliType(const unsigned char* str, const size_t bitLen) :
		AsnBits(str, bitLen)				{ nblFlag = true; }

	enum
	{
		callControlToOOCI = 0,
		callControlToSSI = 1,
		sdsToOOCI = 2,
		sdsToSSI = 3
	};
};


/* INTEGER { generalAccept (0), generalReject (1), serviceNotAvailable (2), unknownAffectedPartySSI (4), invalidGatewayId (7), objectIdentityOutOfRange (8), noFreeMemoryForOOCI (9), affectedPartyIsNoIndividual (10), permissionDenied (11) }  */
class  OociResultType: public AsnInt
{
public:
			OociResultType(): AsnInt() {}
			OociResultType (int i): AsnInt (i) {}

	enum
	{
		generalAccept = 0,
		generalReject = 1,
		serviceNotAvailable = 2,
		unknownAffectedPartySSI = 4,
		invalidGatewayId = 7,
		objectIdentityOutOfRange = 8,
		noFreeMemoryForOOCI = 9,
		affectedPartyIsNoIndividual = 10,
		permissionDenied = 11
	};
};


/* INTEGER { unconditional (0), onBusy (1), onNoReply (2), onNotReachable (3), specialIdentityConversion (4), generalAuthorisationRequest (5) }  */
class  CallForwardingReasonType: public AsnInt
{
public:
			CallForwardingReasonType(): AsnInt() {}
			CallForwardingReasonType (int i): AsnInt (i) {}

	enum
	{
		unconditional = 0,
		onBusy = 1,
		onNoReply = 2,
		onNotReachable = 3,
		specialIdentityConversion = 4,
		generalAuthorisationRequest = 5
	};
};


class  SDSDataTypeSeq: public AsnType
{
public:
  class  SdsData: public AsnOcts  {
		public:
			SdsData ():AsnOcts() { }
			SdsData (const char *str):AsnOcts(str) { }
			SdsData (const char *str, const size_t len):AsnOcts(str, len) { }
			SdsData (const SdsData &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			SdsData		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			SdsData		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  SdsData		sdsData;



  class  BitLength: public AsnInt  {
    public:
        BitLength(AsnIntType val=0):AsnInt(val){ }
        BitLength(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        BitLength(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        BitLength(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        BitLength(const BitLength &that):AsnInt(that){ }

		BitLength & operator =(const BitLength &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
  BitLength		*bitLength;



   SDSDataTypeSeq() {Init();}
   void Init(void);
   virtual ~SDSDataTypeSeq() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SDSDataTypeSeq(const SDSDataTypeSeq& that);
public:
	 virtual const char* typeName() const	{ return "SDSDataTypeSeq"; }
  AsnType		*Clone() const;

  SDSDataTypeSeq		&operator = (const SDSDataTypeSeq &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_Transport_Ack: public AsnType
{
public:
  GeneralizedTime       timeStamp;


   ACAPI_Transport_Ack() {Init();}
   void Init(void);
   virtual ~ACAPI_Transport_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_Transport_Ack(const ACAPI_Transport_Ack& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_Transport_Ack"; }
  AsnType		*Clone() const;

  ACAPI_Transport_Ack		&operator = (const ACAPI_Transport_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_Message_Ack: public AsnType
{
public:
  GeneralizedTime       timeStamp;


   ACAPI_Message_Ack() {Init();}
   void Init(void);
   virtual ~ACAPI_Message_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_Message_Ack(const ACAPI_Message_Ack& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_Message_Ack"; }
  AsnType		*Clone() const;

  ACAPI_Message_Ack		&operator = (const ACAPI_Message_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_CallForwardCancelAll: public AsnType
{
public:
   SS_CallForwardCancelAll() {Init();}
   void Init(void);
   virtual ~SS_CallForwardCancelAll() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_CallForwardCancelAll(const SS_CallForwardCancelAll& that);
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardCancelAll"; }
  AsnType		*Clone() const;

  SS_CallForwardCancelAll		&operator = (const SS_CallForwardCancelAll &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_CallForwardInterrogate: public AsnType
{
public:
  AsnInt       *startSSI;


  AsnInt       *endSSI;


  AsnInt       *maxTransferredEntries;


   SS_CallForwardInterrogate() {Init();}
   void Init(void);
   virtual ~SS_CallForwardInterrogate() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_CallForwardInterrogate(const SS_CallForwardInterrogate& that);
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardInterrogate"; }
  AsnType		*Clone() const;

  SS_CallForwardInterrogate		&operator = (const SS_CallForwardInterrogate &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Data_Ack: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageAck;


   MON_Data_Ack() {Init();}
   void Init(void);
   virtual ~MON_Data_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Data_Ack(const MON_Data_Ack& that);
public:
	 virtual const char* typeName() const	{ return "MON_Data_Ack"; }
  AsnType		*Clone() const;

  MON_Data_Ack		&operator = (const MON_Data_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  LeasedLineType: public AsnType
{
public:
  AsnInt       trunkID;


  class  ChannelID: public AsnInt  {
    public:
        ChannelID(AsnIntType val=0):AsnInt(val){ }
        ChannelID(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        ChannelID(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        ChannelID(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        ChannelID(const ChannelID &that):AsnInt(that){ }

		ChannelID & operator =(const ChannelID &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
  ChannelID		channelID;



  class  SubChannelID: public AsnInt  {
    public:
        SubChannelID(AsnIntType val=0):AsnInt(val){ }
        SubChannelID(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        SubChannelID(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        SubChannelID(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        SubChannelID(const SubChannelID &that):AsnInt(that){ }

		SubChannelID & operator =(const SubChannelID &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
  SubChannelID		*subChannelID;



   LeasedLineType() {Init();}
   void Init(void);
   virtual ~LeasedLineType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   LeasedLineType(const LeasedLineType& that);
public:
	 virtual const char* typeName() const	{ return "LeasedLineType"; }
  AsnType		*Clone() const;

  LeasedLineType		&operator = (const LeasedLineType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ChannelMask_64k: public AsnType
{
public:
  AsnInt       trunkID;


  class  ChannelMask64k: public AsnBits  {
     public:
		ChannelMask64k (const char *stringForm=NULL):AsnBits(stringForm){ }
		ChannelMask64k (size_t numBits):AsnBits(numBits) { }
		ChannelMask64k (const unsigned char *bitOcts, size_t numBits):AsnBits(bitOcts, numBits){ }
		ChannelMask64k (const ChannelMask64k &_b):AsnBits(_b){ }
		const SizeConstraint* SizeConstraints(int &sizeList)const;

		ChannelMask64k & operator=(const char *stringForm){ SetEqual(stringForm); return *this; }
  };

  ChannelMask64k		channelMask64k;



   ChannelMask_64k() {Init();}
   void Init(void);
   virtual ~ChannelMask_64k() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ChannelMask_64k(const ChannelMask_64k& that);
public:
	 virtual const char* typeName() const	{ return "ChannelMask_64k"; }
  AsnType		*Clone() const;

  ChannelMask_64k		&operator = (const ChannelMask_64k &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ChannelMask_8k: public AsnType
{
public:
  AsnInt       trunkID;


  class  ChannelMask8k: public AsnBits  {
     public:
		ChannelMask8k (const char *stringForm=NULL):AsnBits(stringForm){ }
		ChannelMask8k (size_t numBits):AsnBits(numBits) { }
		ChannelMask8k (const unsigned char *bitOcts, size_t numBits):AsnBits(bitOcts, numBits){ }
		ChannelMask8k (const ChannelMask8k &_b):AsnBits(_b){ }
		const SizeConstraint* SizeConstraints(int &sizeList)const;

		ChannelMask8k & operator=(const char *stringForm){ SetEqual(stringForm); return *this; }
  };

  ChannelMask8k		channelMask8k;



   ChannelMask_8k() {Init();}
   void Init(void);
   virtual ~ChannelMask_8k() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ChannelMask_8k(const ChannelMask_8k& that);
public:
	 virtual const char* typeName() const	{ return "ChannelMask_8k"; }
  AsnType		*Clone() const;

  ChannelMask_8k		&operator = (const ChannelMask_8k &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  FragmentationInfoType: public AsnType
{
public:
  AsnInt       packetNumber;


  AsnInt       totalNumber;


   FragmentationInfoType() {Init();}
   void Init(void);
   virtual ~FragmentationInfoType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   FragmentationInfoType(const FragmentationInfoType& that);
public:
	 virtual const char* typeName() const	{ return "FragmentationInfoType"; }
  AsnType		*Clone() const;

  FragmentationInfoType		&operator = (const FragmentationInfoType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_CloseService_Ack: public AsnType
{
public:
  ACAPI_CloseService_AckInt       result;


   ACAPI_CloseService_Ack() {Init();}
   void Init(void);
   virtual ~ACAPI_CloseService_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_CloseService_Ack(const ACAPI_CloseService_Ack& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_CloseService_Ack"; }
  AsnType		*Clone() const;

  ACAPI_CloseService_Ack		&operator = (const ACAPI_CloseService_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_ForcedCallEnd: public AsnType
{
public:
  AsnInt       callID;


  DisconnectType       disconnectCause;


   CC_ForcedCallEnd() {Init();}
   void Init(void);
   virtual ~CC_ForcedCallEnd() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_ForcedCallEnd(const CC_ForcedCallEnd& that);
public:
	 virtual const char* typeName() const	{ return "CC_ForcedCallEnd"; }
  AsnType		*Clone() const;

  CC_ForcedCallEnd		&operator = (const CC_ForcedCallEnd &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_ForcedCallEnd_Ack: public AsnType
{
public:
  AsnInt       callID;


  CC_ForcedCallEnd_AckInt       result;


   CC_ForcedCallEnd_Ack() {Init();}
   void Init(void);
   virtual ~CC_ForcedCallEnd_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_ForcedCallEnd_Ack(const CC_ForcedCallEnd_Ack& that);
public:
	 virtual const char* typeName() const	{ return "CC_ForcedCallEnd_Ack"; }
  AsnType		*Clone() const;

  CC_ForcedCallEnd_Ack		&operator = (const CC_ForcedCallEnd_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_CallForwardCancel_Ack: public AsnType
{
public:
  CallForwardingResultType       cancelResult;


   SS_CallForwardCancel_Ack() {Init();}
   void Init(void);
   virtual ~SS_CallForwardCancel_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_CallForwardCancel_Ack(const SS_CallForwardCancel_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardCancel_Ack"; }
  AsnType		*Clone() const;

  SS_CallForwardCancel_Ack		&operator = (const SS_CallForwardCancel_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_ObjectIdentityCancelGateway: public AsnType
{
public:
  SSIType       gatewayID;


   SS_ObjectIdentityCancelGateway() {Init();}
   void Init(void);
   virtual ~SS_ObjectIdentityCancelGateway() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_ObjectIdentityCancelGateway(const SS_ObjectIdentityCancelGateway& that);
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityCancelGateway"; }
  AsnType		*Clone() const;

  SS_ObjectIdentityCancelGateway		&operator = (const SS_ObjectIdentityCancelGateway &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_ObjectIdentityCancelGateway_Ack: public AsnType
{
public:
  SSIType       gatewayID;


  OociResultType       cancelGatewayResult;


   SS_ObjectIdentityCancelGateway_Ack() {Init();}
   void Init(void);
   virtual ~SS_ObjectIdentityCancelGateway_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_ObjectIdentityCancelGateway_Ack(const SS_ObjectIdentityCancelGateway_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityCancelGateway_Ack"; }
  AsnType		*Clone() const;

  SS_ObjectIdentityCancelGateway_Ack		&operator = (const SS_ObjectIdentityCancelGateway_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_ObjectIdentityInterrogate: public AsnType
{
public:
  SSIType       gatewaySSI;


  AsnInt       *startSSI;


  AsnInt       *endSSI;


  AsnInt       *maxTransferredEntries;


   SS_ObjectIdentityInterrogate() {Init();}
   void Init(void);
   virtual ~SS_ObjectIdentityInterrogate() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_ObjectIdentityInterrogate(const SS_ObjectIdentityInterrogate& that);
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityInterrogate"; }
  AsnType		*Clone() const;

  SS_ObjectIdentityInterrogate		&operator = (const SS_ObjectIdentityInterrogate &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_FleetMonitoring_Req: public AsnType
{
public:
  MonitoringService       monServices;


  AsnInt       monFleet;


  AsnInt       *monHandle;


  GeneralizedTime       *monStartTime;


  GeneralizedTime       *monEndTime;


  AsnBool       *monPersistentData;


   MON_FleetMonitoring_Req() {Init();}
   void Init(void);
   virtual ~MON_FleetMonitoring_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_FleetMonitoring_Req(const MON_FleetMonitoring_Req& that);
public:
	 virtual const char* typeName() const	{ return "MON_FleetMonitoring_Req"; }
  AsnType		*Clone() const;

  MON_FleetMonitoring_Req		&operator = (const MON_FleetMonitoring_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_FleetMonitoring_Ack: public AsnType
{
public:
  AsnInt       monHandle;


  MonitoringService       monServices;


  AsnInt       monFleet;


  GeneralizedTime       *monStartTime;


  GeneralizedTime       *monEndTime;


  AsnBool       *persistentData;


   MON_FleetMonitoring_Ack() {Init();}
   void Init(void);
   virtual ~MON_FleetMonitoring_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_FleetMonitoring_Ack(const MON_FleetMonitoring_Ack& that);
public:
	 virtual const char* typeName() const	{ return "MON_FleetMonitoring_Ack"; }
  AsnType		*Clone() const;

  MON_FleetMonitoring_Ack		&operator = (const MON_FleetMonitoring_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Close_Ack: public AsnType
{
public:
  AsnInt       monHandle;


  MON_Close_AckInt       result;


   MON_Close_Ack() {Init();}
   void Init(void);
   virtual ~MON_Close_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Close_Ack(const MON_Close_Ack& that);
public:
	 virtual const char* typeName() const	{ return "MON_Close_Ack"; }
  AsnType		*Clone() const;

  MON_Close_Ack		&operator = (const MON_Close_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_ForcedCallEnd: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       callID;


  DisconnectType       disconnectCause;


   MON_ForcedCallEnd() {Init();}
   void Init(void);
   virtual ~MON_ForcedCallEnd() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_ForcedCallEnd(const MON_ForcedCallEnd& that);
public:
	 virtual const char* typeName() const	{ return "MON_ForcedCallEnd"; }
  AsnType		*Clone() const;

  MON_ForcedCallEnd		&operator = (const MON_ForcedCallEnd &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_ForcedCallEnd_Ack: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       callID;


  MON_ForcedCallEnd_AckInt       result;


   MON_ForcedCallEnd_Ack() {Init();}
   void Init(void);
   virtual ~MON_ForcedCallEnd_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_ForcedCallEnd_Ack(const MON_ForcedCallEnd_Ack& that);
public:
	 virtual const char* typeName() const	{ return "MON_ForcedCallEnd_Ack"; }
  AsnType		*Clone() const;

  MON_ForcedCallEnd_Ack		&operator = (const MON_ForcedCallEnd_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  RSM_ResourceMonitoring_Close: public AsnType
{
public:
  AsnInt       rsmHandle;


  RSM_ResourceMonitoring_CloseInt       result;


   RSM_ResourceMonitoring_Close() {Init();}
   void Init(void);
   virtual ~RSM_ResourceMonitoring_Close() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   RSM_ResourceMonitoring_Close(const RSM_ResourceMonitoring_Close& that);
public:
	 virtual const char* typeName() const	{ return "RSM_ResourceMonitoring_Close"; }
  AsnType		*Clone() const;

  RSM_ResourceMonitoring_Close		&operator = (const RSM_ResourceMonitoring_Close &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  TETRA_Address: public AsnType
{
public:
  SSIType       ssi;


  MCCType       *mcc;


  MNCType       *mnc;


   TETRA_Address() {Init();}
   void Init(void);
   virtual ~TETRA_Address() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   TETRA_Address(const TETRA_Address& that);
public:
	 virtual const char* typeName() const	{ return "TETRA_Address"; }
  AsnType		*Clone() const;

  TETRA_Address		&operator = (const TETRA_Address &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ISDN_Address: public AsnType
{
public:
  DialingString       externalSubscriber;


  SSIType       gateWaySSI;


   ISDN_Address() {Init();}
   void Init(void);
   virtual ~ISDN_Address() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ISDN_Address(const ISDN_Address& that);
public:
	 virtual const char* typeName() const	{ return "ISDN_Address"; }
  AsnType		*Clone() const;

  ISDN_Address		&operator = (const ISDN_Address &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  AddressType: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     tetraAddressCid = 0,
     iSDNAddressCid = 1
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
  TETRA_Address       *tetraAddress;

  ISDN_Address       *iSDNAddress;

  };


   AddressType() {Init();}
   AddressType(const AddressType& that);
public:
	 virtual const char* typeName() const	{ return "AddressType"; }
   void Init(void);

   virtual int checkConstraints(ConstraintFailList* pConstraintFails)const;

   virtual ~AddressType() {Clear();}

   void Clear();

  AsnType		*Clone() const;

  AddressType		&operator = (const AddressType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded /*, s env*/);
  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void			PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SDSDataType: public AsnType
{
public:
class  StatusType: public AsnInt  {
    public:
        StatusType(AsnIntType val=0):AsnInt(val){ }
        StatusType(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        StatusType(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        StatusType(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        StatusType(const StatusType &that):AsnInt(that){ }

		StatusType & operator =(const StatusType &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
class  SdsType1: public AsnOcts  {
		public:
			SdsType1 ():AsnOcts() { }
			SdsType1 (const char *str):AsnOcts(str) { }
			SdsType1 (const char *str, const size_t len):AsnOcts(str, len) { }
			SdsType1 (const SdsType1 &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			SdsType1		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			SdsType1		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

class  SdsType2: public AsnOcts  {
		public:
			SdsType2 ():AsnOcts() { }
			SdsType2 (const char *str):AsnOcts(str) { }
			SdsType2 (const char *str, const size_t len):AsnOcts(str, len) { }
			SdsType2 (const SdsType2 &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			SdsType2		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			SdsType2		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

class  SdsType3: public AsnOcts  {
		public:
			SdsType3 ():AsnOcts() { }
			SdsType3 (const char *str):AsnOcts(str) { }
			SdsType3 (const char *str, const size_t len):AsnOcts(str, len) { }
			SdsType3 (const SdsType3 &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			SdsType3		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			SdsType3		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  enum ChoiceIdEnum
  {
     statusTypeCid = 0,
     sdsType1Cid = 1,
     sdsType2Cid = 2,
     sdsType3Cid = 3,
     sdsType4Cid = 4
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
  StatusType       *statusType;

  SdsType1       *sdsType1;

  SdsType2       *sdsType2;

  SdsType3       *sdsType3;

  SDSDataTypeSeq       *sdsType4;

  };


   SDSDataType() {Init();}
   SDSDataType(const SDSDataType& that);
public:
	 virtual const char* typeName() const	{ return "SDSDataType"; }
   void Init(void);

   virtual int checkConstraints(ConstraintFailList* pConstraintFails)const;

   virtual ~SDSDataType() {Clear();}

   void Clear();

  AsnType		*Clone() const;

  SDSDataType		&operator = (const SDSDataType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded /*, s env*/);
  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void			PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  BasicServiceType: public AsnType
{
public:
  CommType       communicationType;


  AsnBool       *encryption;


  CircuitModeType       *circuitModeType;


   BasicServiceType() {Init();}
   void Init(void);
   virtual ~BasicServiceType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   BasicServiceType(const BasicServiceType& that);
public:
	 virtual const char* typeName() const	{ return "BasicServiceType"; }
  AsnType		*Clone() const;

  BasicServiceType		&operator = (const BasicServiceType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  LocationAreaType: public AsnType
{
public:
  Integer16       locationArea;


  class  LocationName: public AsnOcts  {
		public:
			LocationName ():AsnOcts() { }
			LocationName (const char *str):AsnOcts(str) { }
			LocationName (const char *str, const size_t len):AsnOcts(str, len) { }
			LocationName (const LocationName &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			LocationName		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			LocationName		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  LocationName		*locationName;



  class  Cell: public AsnInt  {
    public:
        Cell(AsnIntType val=0):AsnInt(val){ }
        Cell(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        Cell(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        Cell(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        Cell(const Cell &that):AsnInt(that){ }

		Cell & operator =(const Cell &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
  Cell		*cell;



  class  CellName: public AsnOcts  {
		public:
			CellName ():AsnOcts() { }
			CellName (const char *str):AsnOcts(str) { }
			CellName (const char *str, const size_t len):AsnOcts(str, len) { }
			CellName (const CellName &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			CellName		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			CellName		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  CellName		*cellName;



   LocationAreaType() {Init();}
   void Init(void);
   virtual ~LocationAreaType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   LocationAreaType(const LocationAreaType& that);
public:
	 virtual const char* typeName() const	{ return "LocationAreaType"; }
  AsnType		*Clone() const;

  LocationAreaType		&operator = (const LocationAreaType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  DialupLineType: public AsnType
{
public:
  DialingString       destinationID;


  DialingString       *sourceID;


  class  SubChannelID: public AsnInt  {
    public:
        SubChannelID(AsnIntType val=0):AsnInt(val){ }
        SubChannelID(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        SubChannelID(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        SubChannelID(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        SubChannelID(const SubChannelID &that):AsnInt(that){ }

		SubChannelID & operator =(const SubChannelID &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
  SubChannelID		*subChannelID;



   DialupLineType() {Init();}
   void Init(void);
   virtual ~DialupLineType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   DialupLineType(const DialupLineType& that);
public:
	 virtual const char* typeName() const	{ return "DialupLineType"; }
  AsnType		*Clone() const;

  DialupLineType		&operator = (const DialupLineType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  LineInformationType: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     leasedLineInfoCid = 0,
     dialupLineHandleCid = 1
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
  LeasedLineType       *leasedLineInfo;

  AsnInt       *dialupLineHandle;

  };


   LineInformationType() {Init();}
   LineInformationType(const LineInformationType& that);
public:
	 virtual const char* typeName() const	{ return "LineInformationType"; }
   void Init(void);

   virtual int checkConstraints(ConstraintFailList* pConstraintFails)const;

   virtual ~LineInformationType() {Clear();}

   void Clear();

  AsnType		*Clone() const;

  LineInformationType		&operator = (const LineInformationType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded /*, s env*/);
  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void			PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  LineResourceInfo: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     leasedLineIDCid = 0,
     dialupLineInfoCid = 1
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
  AsnInt       *leasedLineID;

  DialupLineType       *dialupLineInfo;

  };


   LineResourceInfo() {Init();}
   LineResourceInfo(const LineResourceInfo& that);
public:
	 virtual const char* typeName() const	{ return "LineResourceInfo"; }
   void Init(void);

   virtual int checkConstraints(ConstraintFailList* pConstraintFails)const;

   virtual ~LineResourceInfo() {Clear();}

   void Clear();

  AsnType		*Clone() const;

  LineResourceInfo		&operator = (const LineResourceInfo &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded /*, s env*/);
  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void			PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  LineInfoAckType: public AsnType
{
public:
  LineInformationType       lineInfo;


  LineInfoAckTypeInt       lineState;


   LineInfoAckType() {Init();}
   void Init(void);
   virtual ~LineInfoAckType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   LineInfoAckType(const LineInfoAckType& that);
public:
	 virtual const char* typeName() const	{ return "LineInfoAckType"; }
  AsnType		*Clone() const;

  LineInfoAckType		&operator = (const LineInfoAckType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  DialupLineMask: public AsnType
{
public:
  DialingString       destinationID;


  AsnInt       lineHandle;


  LineInfoAckType       lineState;


  DialingString       *sourceID;


  class  SubChannelID: public AsnInt  {
    public:
        SubChannelID(AsnIntType val=0):AsnInt(val){ }
        SubChannelID(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        SubChannelID(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        SubChannelID(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        SubChannelID(const SubChannelID &that):AsnInt(that){ }

		SubChannelID & operator =(const SubChannelID &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
  SubChannelID		*subChannelID;



   DialupLineMask() {Init();}
   void Init(void);
   virtual ~DialupLineMask() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   DialupLineMask(const DialupLineMask& that);
public:
	 virtual const char* typeName() const	{ return "DialupLineMask"; }
  AsnType		*Clone() const;

  DialupLineMask		&operator = (const DialupLineMask &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  LineInformationMask: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     channelMask64kCid = 0,
     channelMask8kCid = 1,
     dialupMaskCid = 2
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
  ChannelMask_64k       *channelMask64k;

  ChannelMask_8k       *channelMask8k;

  DialupLineMask       *dialupMask;

  };


   LineInformationMask() {Init();}
   LineInformationMask(const LineInformationMask& that);
public:
	 virtual const char* typeName() const	{ return "LineInformationMask"; }
   void Init(void);

   virtual int checkConstraints(ConstraintFailList* pConstraintFails)const;

   virtual ~LineInformationMask() {Clear();}

   void Clear();

  AsnType		*Clone() const;

  LineInformationMask		&operator = (const LineInformationMask &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded /*, s env*/);
  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void			PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SystemConnectionState: public AsnType
{
public:
  AsnInt       connectionID;


  class  ConnectionName: public IA5String  {
     public:
        ConnectionName():IA5String(){ }

		const SizeConstraint* SizeConstraints(int &sizeList)const;

		ConnectionName& operator=(const char* str)
			  { IA5String::operator=(str); return *this;}
		ConnectionName& operator=(const std::string& str)
			  { IA5String::operator=(str); return *this;}
  };

  ConnectionName		connectionName;



  SystemConnectionStateInt       connectionState;


   SystemConnectionState() {Init();}
   void Init(void);
   virtual ~SystemConnectionState() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SystemConnectionState(const SystemConnectionState& that);
public:
	 virtual const char* typeName() const	{ return "SystemConnectionState"; }
  AsnType		*Clone() const;

  SystemConnectionState		&operator = (const SystemConnectionState &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ResourceLoadInfo: public AsnType
{
public:
  AsnInt       resourceID;


  class  ResourceName: public IA5String  {
     public:
        ResourceName():IA5String(){ }

		const SizeConstraint* SizeConstraints(int &sizeList)const;

		ResourceName& operator=(const char* str)
			  { IA5String::operator=(str); return *this;}
		ResourceName& operator=(const std::string& str)
			  { IA5String::operator=(str); return *this;}
  };

  ResourceName		resourceName;



  ResourceLoadInfoInt       resourceLoad;


  AsnInt       actBufferLoad;


  AsnInt       maxBufferLoad;


   ResourceLoadInfo() {Init();}
   void Init(void);
   virtual ~ResourceLoadInfo() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ResourceLoadInfo(const ResourceLoadInfo& that);
public:
	 virtual const char* typeName() const	{ return "ResourceLoadInfo"; }
  AsnType		*Clone() const;

  ResourceLoadInfo		&operator = (const ResourceLoadInfo &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MacFacilityType: public AsnType
{
public:
  Integer16       uplinkRSSI;


  Integer16       pathDelay;


   MacFacilityType() {Init();}
   void Init(void);
   virtual ~MacFacilityType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MacFacilityType(const MacFacilityType& that);
public:
	 virtual const char* typeName() const	{ return "MacFacilityType"; }
  AsnType		*Clone() const;

  MacFacilityType		&operator = (const MacFacilityType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  DynGroupMemberState: public AsnType
{
public:
  TETRA_Address       affectedSsi;


  DynGroupMemberStateInt       attachmentState;


   DynGroupMemberState() {Init();}
   void Init(void);
   virtual ~DynGroupMemberState() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   DynGroupMemberState(const DynGroupMemberState& that);
public:
	 virtual const char* typeName() const	{ return "DynGroupMemberState"; }
  AsnType		*Clone() const;

  DynGroupMemberState		&operator = (const DynGroupMemberState &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CallTransferType: public AsnType
{
public:
  TETRA_Address       requestingSsi;


   CallTransferType() {Init();}
   void Init(void);
   virtual ~CallTransferType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CallTransferType(const CallTransferType& that);
public:
	 virtual const char* typeName() const	{ return "CallTransferType"; }
  AsnType		*Clone() const;

  CallTransferType		&operator = (const CallTransferType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CallForwardingEntryType: public AsnType
{
public:
  TETRA_Address       forwardedPartySSI;


  AddressType       forwardToParty;


  CallForwardingType       forwardingType;


  ForwardingServiceType       forwardingService;


   CallForwardingEntryType() {Init();}
   void Init(void);
   virtual ~CallForwardingEntryType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CallForwardingEntryType(const CallForwardingEntryType& that);
public:
	 virtual const char* typeName() const	{ return "CallForwardingEntryType"; }
  AsnType		*Clone() const;

  CallForwardingEntryType		&operator = (const CallForwardingEntryType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  OociEntryType: public AsnType
{
public:
  ISDN_Address       assignedOOCI;


  TETRA_Address       affectedPartySSI;


  UseOociAsCliType       *useOociAsCLI;


   OociEntryType() {Init();}
   void Init(void);
   virtual ~OociEntryType() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   OociEntryType(const OociEntryType& that);
public:
	 virtual const char* typeName() const	{ return "OociEntryType"; }
  AsnType		*Clone() const;

  OociEntryType		&operator = (const OociEntryType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_AbortCauseType: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     callIdentificationCid = 0,
     callReportCid = 1,
     talkingPartyIdentificationCid = 2,
     callForwardingCid = 3,
     listSearchCallCid = 4,
     callAuthorizedByDispatcherCid = 5,
     shortNumberAddressingCid = 6,
     areaSelectionCid = 7,
     accessPriorityCid = 8,
     priorityCallCid = 9,
     callWaitingCid = 10,
     callHoldCid = 11,
     callCompletionToBusySubscriberCid = 12,
     lateEntryCid = 13,
     preEmptivePriorityCallCid = 14,
     includeCallCid = 15,
     barringOfOutgoingCallsCid = 16,
     barringOfIncomingCallsCid = 17,
     discreetListeningCid = 18,
     ambienceListeningCid = 19,
     dynamicGroupNumberAssignmentCid = 20,
     callCompletionOnNoReplyCid = 21,
     callRetentionCid = 22
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
  AsnInt       *callIdentification;

  AsnInt       *callReport;

  AsnInt       *talkingPartyIdentification;

  AsnInt       *callForwarding;

  AsnInt       *listSearchCall;

  SS_AbortCauseTypeInt       *callAuthorizedByDispatcher;

  AsnInt       *shortNumberAddressing;

  AsnInt       *areaSelection;

  AsnInt       *accessPriority;

  AsnInt       *priorityCall;

  AsnInt       *callWaiting;

  AsnInt       *callHold;

  AsnInt       *callCompletionToBusySubscriber;

  AsnInt       *lateEntry;

  AsnInt       *preEmptivePriorityCall;

  AsnInt       *includeCall;

  AsnInt       *barringOfOutgoingCalls;

  AsnInt       *barringOfIncomingCalls;

  AsnInt       *discreetListening;

  SS_AbortCauseTypeInt1       *ambienceListening;

  AsnInt       *dynamicGroupNumberAssignment;

  AsnInt       *callCompletionOnNoReply;

  AsnInt       *callRetention;

  };


   SS_AbortCauseType() {Init();}
   SS_AbortCauseType(const SS_AbortCauseType& that);
public:
	 virtual const char* typeName() const	{ return "SS_AbortCauseType"; }
   void Init(void);

   virtual int checkConstraints(ConstraintFailList* pConstraintFails)const;

   virtual ~SS_AbortCauseType() {Clear();}

   void Clear();

  AsnType		*Clone() const;

  SS_AbortCauseType		&operator = (const SS_AbortCauseType &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded /*, s env*/);
  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void			PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class RSM_ResourceState_IndSeqOf2 : public AsnSeqOf<LineInformationMask>
{
public:
	 virtual const char* typeName() const	{ return "RSM_ResourceState_IndSeqOf2"; }
	 virtual AsnType* Clone() const			{ return new RSM_ResourceState_IndSeqOf2(*this); }
};

class RSM_ResourceState_IndSeqOf1 : public AsnSeqOf<ResourceLoadInfo>
{
public:
	 virtual const char* typeName() const	{ return "RSM_ResourceState_IndSeqOf1"; }
	 virtual AsnType* Clone() const			{ return new RSM_ResourceState_IndSeqOf1(*this); }
};

class RSM_ResourceState_IndSeqOf : public AsnSeqOf<SystemConnectionState>
{
public:
	 virtual const char* typeName() const	{ return "RSM_ResourceState_IndSeqOf"; }
	 virtual AsnType* Clone() const			{ return new RSM_ResourceState_IndSeqOf(*this); }
};

class RSM_ResourceMonitoring_ReqSeqOf : public AsnSeqOf<LineResourceInfo>
{
public:
	 virtual const char* typeName() const	{ return "RSM_ResourceMonitoring_ReqSeqOf"; }
	 virtual AsnType* Clone() const			{ return new RSM_ResourceMonitoring_ReqSeqOf(*this); }
};

class SS_ObjectIdentityInterrogate_AckSeqOf : public AsnSeqOf<OociEntryType>
{
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityInterrogate_AckSeqOf"; }
	 virtual AsnType* Clone() const			{ return new SS_ObjectIdentityInterrogate_AckSeqOf(*this); }
};

class SS_CallForwardInterrogate_AckSeqOf : public AsnSeqOf<CallForwardingEntryType>
{
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardInterrogate_AckSeqOf"; }
	 virtual AsnType* Clone() const			{ return new SS_CallForwardInterrogate_AckSeqOf(*this); }
};

class SS_DynGroupInterrogate_AckSeqOf : public AsnSeqOf<DynGroupMemberState>
{
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupInterrogate_AckSeqOf"; }
	 virtual AsnType* Clone() const			{ return new SS_DynGroupInterrogate_AckSeqOf(*this); }
};

class SS_DynGroupDelSeqOf : public AsnSeqOf<TETRA_Address>
{
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupDelSeqOf"; }
	 virtual AsnType* Clone() const			{ return new SS_DynGroupDelSeqOf(*this); }
};

class SS_DynGroupAddSeqOf : public AsnSeqOf<TETRA_Address>
{
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupAddSeqOf"; }
	 virtual AsnType* Clone() const			{ return new SS_DynGroupAddSeqOf(*this); }
};

class CC_InformationSeqOf : public AsnSeqOf<TETRA_Address>
{
public:
	 virtual const char* typeName() const	{ return "CC_InformationSeqOf"; }
	 virtual AsnType* Clone() const			{ return new CC_InformationSeqOf(*this); }
};

class ACAPI_OpenServiceSeqOf : public AsnSeqOf<LineResourceInfo>
{
public:
	 virtual const char* typeName() const	{ return "ACAPI_OpenServiceSeqOf"; }
	 virtual AsnType* Clone() const			{ return new ACAPI_OpenServiceSeqOf(*this); }
};

class  ACAPI_OpenService: public AsnType
{
public:
  class  LoginName: public AsnOcts  {
		public:
			LoginName ():AsnOcts() { }
			LoginName (const char *str):AsnOcts(str) { }
			LoginName (const char *str, const size_t len):AsnOcts(str, len) { }
			LoginName (const LoginName &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			LoginName		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			LoginName		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  LoginName		loginName;



  Integer16       version;


  ServiceIDType       serviceReq;


  TETRA_Address       ssiReq;


  ACAPI_OpenServiceSeqOf       *lineResourceInfo;


   ACAPI_OpenService() {Init();}
   void Init(void);
   virtual ~ACAPI_OpenService() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_OpenService(const ACAPI_OpenService& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_OpenService"; }
  AsnType		*Clone() const;

  ACAPI_OpenService		&operator = (const ACAPI_OpenService &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_OpenService_Ack: public AsnType
{
public:
  Integer16       version;


  ServiceIDType       serviceResp;


  TETRA_Address       ssiResp;


  AsnInt       serviceHandle;


  Integer16       applWindowSize;


  Integer16       serviceWindowSize;


   ACAPI_OpenService_Ack() {Init();}
   void Init(void);
   virtual ~ACAPI_OpenService_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_OpenService_Ack(const ACAPI_OpenService_Ack& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_OpenService_Ack"; }
  AsnType		*Clone() const;

  ACAPI_OpenService_Ack		&operator = (const ACAPI_OpenService_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_CloseService: public AsnType
{
public:
  ACAPI_CloseServiceInt       result;


  ServiceIDType       *serviceReq;


  TETRA_Address       *ssiReq;


   ACAPI_CloseService() {Init();}
   void Init(void);
   virtual ~ACAPI_CloseService() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_CloseService(const ACAPI_CloseService& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_CloseService"; }
  AsnType		*Clone() const;

  ACAPI_CloseService		&operator = (const ACAPI_CloseService &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_Authorization_Req: public AsnType
{
public:
  class  LoginName: public AsnOcts  {
		public:
			LoginName ():AsnOcts() { }
			LoginName (const char *str):AsnOcts(str) { }
			LoginName (const char *str, const size_t len):AsnOcts(str, len) { }
			LoginName (const LoginName &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			LoginName		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			LoginName		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  LoginName		loginName;



  ServiceIDType       serviceReq;


  TETRA_Address       ssiReq;


  AsnInt       serviceHandle;


  AuthorizationMethodType       authorizationMethod;


  class  RequestString: public AsnOcts  {
		public:
			RequestString ():AsnOcts() { }
			RequestString (const char *str):AsnOcts(str) { }
			RequestString (const char *str, const size_t len):AsnOcts(str, len) { }
			RequestString (const RequestString &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			RequestString		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			RequestString		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  RequestString		*requestString;



  class  RandomSeed: public AsnOcts  {
		public:
			RandomSeed ():AsnOcts() { }
			RandomSeed (const char *str):AsnOcts(str) { }
			RandomSeed (const char *str, const size_t len):AsnOcts(str, len) { }
			RandomSeed (const RandomSeed &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			RandomSeed		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			RandomSeed		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  RandomSeed		*randomSeed;



   ACAPI_Authorization_Req() {Init();}
   void Init(void);
   virtual ~ACAPI_Authorization_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_Authorization_Req(const ACAPI_Authorization_Req& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_Authorization_Req"; }
  AsnType		*Clone() const;

  ACAPI_Authorization_Req		&operator = (const ACAPI_Authorization_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_Authorization: public AsnType
{
public:
  class  LoginName: public AsnOcts  {
		public:
			LoginName ():AsnOcts() { }
			LoginName (const char *str):AsnOcts(str) { }
			LoginName (const char *str, const size_t len):AsnOcts(str, len) { }
			LoginName (const LoginName &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			LoginName		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			LoginName		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  LoginName		loginName;



  ServiceIDType       serviceReq;


  TETRA_Address       ssiReq;


  AuthorizationMethodType       authorizationMethod;


  class  AuthorizationString: public AsnOcts  {
		public:
			AuthorizationString ():AsnOcts() { }
			AuthorizationString (const char *str):AsnOcts(str) { }
			AuthorizationString (const char *str, const size_t len):AsnOcts(str, len) { }
			AuthorizationString (const AuthorizationString &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			AuthorizationString		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			AuthorizationString		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  AuthorizationString		authorizationString;



  class  RandomSeed: public AsnOcts  {
		public:
			RandomSeed ():AsnOcts() { }
			RandomSeed (const char *str):AsnOcts(str) { }
			RandomSeed (const char *str, const size_t len):AsnOcts(str, len) { }
			RandomSeed (const RandomSeed &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			RandomSeed		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			RandomSeed		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  RandomSeed		*randomSeed;



   ACAPI_Authorization() {Init();}
   void Init(void);
   virtual ~ACAPI_Authorization() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_Authorization(const ACAPI_Authorization& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_Authorization"; }
  AsnType		*Clone() const;

  ACAPI_Authorization		&operator = (const ACAPI_Authorization &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_Error_Info: public AsnType
{
public:
  class  ErrorText: public AsnOcts  {
		public:
			ErrorText ():AsnOcts() { }
			ErrorText (const char *str):AsnOcts(str) { }
			ErrorText (const char *str, const size_t len):AsnOcts(str, len) { }
			ErrorText (const ErrorText &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			ErrorText		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			ErrorText		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  ErrorText		errorText;



  GeneralizedTime       timeStamp;


  TETRA_Address       *affectedSSI;


  AsnInt       *callID;


   ACAPI_Error_Info() {Init();}
   void Init(void);
   virtual ~ACAPI_Error_Info() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_Error_Info(const ACAPI_Error_Info& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_Error_Info"; }
  AsnType		*Clone() const;

  ACAPI_Error_Info		&operator = (const ACAPI_Error_Info &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SDS_Data: public AsnType
{
public:
  AddressType       calledParty;


  AddressType       callingParty;


  Integer16       sdsHandle;


  SDSDataType       sdsData;


  AreaType       *areaSelection;


  PriorityType       *priorityClass;


  AsnBool       *acknowlegeExpected;


  LocationAreaType       *sourceLocation;


  MacFacilityType       *macFacility;


   SDS_Data() {Init();}
   void Init(void);
   virtual ~SDS_Data() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SDS_Data(const SDS_Data& that);
public:
	 virtual const char* typeName() const	{ return "SDS_Data"; }
  AsnType		*Clone() const;

  SDS_Data		&operator = (const SDS_Data &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SDS_Data_Ack: public AsnType
{
public:
  AddressType       calledParty;


  AddressType       callingParty;


  Integer16       sdsHandle;


  SDS_Data_AckInt       result;


  AsnBool       *isStatus;


   SDS_Data_Ack() {Init();}
   void Init(void);
   virtual ~SDS_Data_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SDS_Data_Ack(const SDS_Data_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SDS_Data_Ack"; }
  AsnType		*Clone() const;

  SDS_Data_Ack		&operator = (const SDS_Data_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Setup_Req: public AsnType
{
public:
  AddressType       calledParty;


  TETRA_Address       callingParty;


  AsnBool       hookSignalling;


  AsnBool       duplexRequest;


  LineInformationType       lineInformation;


  AsnBool       *requestToTransmit;


  CliType       *cliControl;


  AreaType       *areaSelection;


  PriorityType       *priorityClass;


  CallPriorityType       *callPriority;


  BasicServiceType       *basicService;


  CallTransferType       *callTransfer;


  AsnBool       *ambienceListening;


   CC_Setup_Req() {Init();}
   void Init(void);
   virtual ~CC_Setup_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Setup_Req(const CC_Setup_Req& that);
public:
	 virtual const char* typeName() const	{ return "CC_Setup_Req"; }
  AsnType		*Clone() const;

  CC_Setup_Req		&operator = (const CC_Setup_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_SetupInclude_Req: public AsnType
{
public:
  AddressType       includeParty;


  TETRA_Address       callingParty;


  AsnBool       hookSignalling;


  AsnInt       include2CallID;


  CliType       *cliControl;


  AsnBool       *divertCall;


   CC_SetupInclude_Req() {Init();}
   void Init(void);
   virtual ~CC_SetupInclude_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_SetupInclude_Req(const CC_SetupInclude_Req& that);
public:
	 virtual const char* typeName() const	{ return "CC_SetupInclude_Req"; }
  AsnType		*Clone() const;

  CC_SetupInclude_Req		&operator = (const CC_SetupInclude_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Setup_Ind: public AsnType
{
public:
  TETRA_Address       calledParty;


  AddressType       callingParty;


  AsnInt       callID;


  AsnBool       hookSignalling;


  AsnBool       duplexRequest;


  TetraCallTime       callTimeOut;


  TxGrantType       *txGrant;


  AsnBool       *txReqPermission;


  CliType       *cliControl;


  CallPriorityType       *callPriority;


  BasicServiceType       *basicService;


  LocationAreaType       *sourceLocation;


  SS_NotificationType       *ssNotification;


  TETRA_Address       *temporarySSI;


  AirEncryptionType       *airEncryption;


  AddressType       *originalCalledParty;


  CallForwardingReasonType       *callForwardingReason;


  AsnBool       *authorizationReq;


   CC_Setup_Ind() {Init();}
   void Init(void);
   virtual ~CC_Setup_Ind() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Setup_Ind(const CC_Setup_Ind& that);
public:
	 virtual const char* typeName() const	{ return "CC_Setup_Ind"; }
  AsnType		*Clone() const;

  CC_Setup_Ind		&operator = (const CC_Setup_Ind &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Setup_Ack: public AsnType
{
public:
  AddressType       calledParty;


  AddressType       callingParty;


  AsnInt       callID;


  AsnBool       *hookSignalling;


  AsnBool       *duplexMode;


  BasicServiceType       *basicService;


  CallSetupTime       *callSetupTime;


  CallTransferType       *callTransfer;


  AsnBool       *authorizationReq;


   CC_Setup_Ack() {Init();}
   void Init(void);
   virtual ~CC_Setup_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Setup_Ack(const CC_Setup_Ack& that);
public:
	 virtual const char* typeName() const	{ return "CC_Setup_Ack"; }
  AsnType		*Clone() const;

  CC_Setup_Ack		&operator = (const CC_Setup_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Information: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AsnInt       callID;


  CallStateType       *callState;


  AsnBool       *duplexMode;


  BasicServiceType       *basicService;


  SS_NotificationType       *ssNotification;


  TETRA_Address       *temporarySSI;


  AsnBool       *pollRequest;


  class  PollRespNumber: public AsnInt  {
    public:
        PollRespNumber(AsnIntType val=0):AsnInt(val){ }
        PollRespNumber(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        PollRespNumber(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        PollRespNumber(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        PollRespNumber(const PollRespNumber &that):AsnInt(that){ }

		PollRespNumber & operator =(const PollRespNumber &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
  PollRespNumber		*pollRespNumber;



  class  PollRespPercent: public AsnInt  {
    public:
        PollRespPercent(AsnIntType val=0):AsnInt(val){ }
        PollRespPercent(const char *str, bool unsignedFlag = true):AsnInt(str, unsignedFlag){ }
        PollRespPercent(const AsnOcts &o, bool unsignedFlag = true):AsnInt(o, unsignedFlag){ }
        PollRespPercent(const char *str, const size_t len, bool unsignedFlag = true):AsnInt(str, len, unsignedFlag){ }
        PollRespPercent(const PollRespPercent &that):AsnInt(that){ }

		PollRespPercent & operator =(const PollRespPercent &o);
		const ValueRange* ValueRanges(int &sizeVRList) const;

  };
  PollRespPercent		*pollRespPercent;



  CC_InformationSeqOf       *pollRespAddresses;


  DTMFString       *dTMF;


  CallSetupTime       *callSetupTime;


  LineInfoAckType       *lineInformation;


  AddressType       *alertedParty;


  CC_InformationInt       *dtmfErrorCode;


   CC_Information() {Init();}
   void Init(void);
   virtual ~CC_Information() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Information(const CC_Information& that);
public:
	 virtual const char* typeName() const	{ return "CC_Information"; }
  AsnType		*Clone() const;

  CC_Information		&operator = (const CC_Information &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Connect_Req: public AsnType
{
public:
  AddressType       callParty;


  AsnInt       callID;


  LineInformationType       lineInformation;


  AsnBool       *duplexMode;


  BasicServiceType       *basicService;


  AsnBool       *ambienceListening;


   CC_Connect_Req() {Init();}
   void Init(void);
   virtual ~CC_Connect_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Connect_Req(const CC_Connect_Req& that);
public:
	 virtual const char* typeName() const	{ return "CC_Connect_Req"; }
  AsnType		*Clone() const;

  CC_Connect_Req		&operator = (const CC_Connect_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Connect_Ind: public AsnType
{
public:
  AddressType       callParty;


  AsnInt       callID;


  AsnBool       hookSignalling;


  AsnBool       duplexMode;


  TxGrantType       txGrant;


  LineInfoAckType       lineInfoAck;


  AsnBool       *txReqPermission;


  CallPriorityType       *callPriority;


  BasicServiceType       *basicService;


  SS_NotificationType       *ssNotification;


  AddressType       *connectedParty;


  AirEncryptionType       *airEncryption;


  TetraCallTime       *callTimeOut;


   CC_Connect_Ind() {Init();}
   void Init(void);
   virtual ~CC_Connect_Ind() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Connect_Ind(const CC_Connect_Ind& that);
public:
	 virtual const char* typeName() const	{ return "CC_Connect_Ind"; }
  AsnType		*Clone() const;

  CC_Connect_Ind		&operator = (const CC_Connect_Ind &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Connect_Ack: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AsnInt       callID;


  TxGrantType       txGrant;


  LineInfoAckType       lineInfoAck;


  AsnBool       *txReqPermission;


  CallPriorityType       *callPriority;


  SS_NotificationType       *ssNotification;


  TetraCallTime       *callTimeOut;


   CC_Connect_Ack() {Init();}
   void Init(void);
   virtual ~CC_Connect_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Connect_Ack(const CC_Connect_Ack& that);
public:
	 virtual const char* typeName() const	{ return "CC_Connect_Ack"; }
  AsnType		*Clone() const;

  CC_Connect_Ack		&operator = (const CC_Connect_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxDemand: public AsnType
{
public:
  TETRA_Address       demandPartySSI;


  AsnInt       callID;


  TxPriorityType       *txPriority;


  AsnBool       *encryption;


  LineInformationType       *lineInformation;


  AsnBool       *noNfLoopBack;


   CC_TxDemand() {Init();}
   void Init(void);
   virtual ~CC_TxDemand() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxDemand(const CC_TxDemand& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxDemand"; }
  AsnType		*Clone() const;

  CC_TxDemand		&operator = (const CC_TxDemand &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxGrant: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AddressType       transmittingParty;


  AsnInt       callID;


  TxGrantType       txGrant;


  AsnBool       *txReqPermission;


  AsnBool       *encryption;


  CliType       *tpiRestriction;


  SS_NotificationType       *ssNotification;


   CC_TxGrant() {Init();}
   void Init(void);
   virtual ~CC_TxGrant() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxGrant(const CC_TxGrant& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxGrant"; }
  AsnType		*Clone() const;

  CC_TxGrant		&operator = (const CC_TxGrant &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxCeased: public AsnType
{
public:
  AddressType       callParty;


  AsnInt       callID;


  AsnBool       *txReqPermission;


  SS_NotificationType       *ssNotification;


   CC_TxCeased() {Init();}
   void Init(void);
   virtual ~CC_TxCeased() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxCeased(const CC_TxCeased& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxCeased"; }
  AsnType		*Clone() const;

  CC_TxCeased		&operator = (const CC_TxCeased &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxInterrupt: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AddressType       transmittingParty;


  AsnInt       callID;


  TxGrantType       txGrant;


  AsnBool       *txReqPermission;


  AsnBool       *encryption;


  CliType       *tpiRestriction;


   CC_TxInterrupt() {Init();}
   void Init(void);
   virtual ~CC_TxInterrupt() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxInterrupt(const CC_TxInterrupt& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxInterrupt"; }
  AsnType		*Clone() const;

  CC_TxInterrupt		&operator = (const CC_TxInterrupt &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxWait_Ind: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AsnInt       callID;


  AsnBool       *txReqPermission;


  SS_NotificationType       *ssNotification;


   CC_TxWait_Ind() {Init();}
   void Init(void);
   virtual ~CC_TxWait_Ind() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxWait_Ind(const CC_TxWait_Ind& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxWait_Ind"; }
  AsnType		*Clone() const;

  CC_TxWait_Ind		&operator = (const CC_TxWait_Ind &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxWait_Req: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AddressType       otherParty;


  AsnInt       callID;


   CC_TxWait_Req() {Init();}
   void Init(void);
   virtual ~CC_TxWait_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxWait_Req(const CC_TxWait_Req& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxWait_Req"; }
  AsnType		*Clone() const;

  CC_TxWait_Req		&operator = (const CC_TxWait_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxWait_Ack: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AddressType       otherParty;


  AsnInt       callID;


  CC_TxWait_AckInt       result;


   CC_TxWait_Ack() {Init();}
   void Init(void);
   virtual ~CC_TxWait_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxWait_Ack(const CC_TxWait_Ack& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxWait_Ack"; }
  AsnType		*Clone() const;

  CC_TxWait_Ack		&operator = (const CC_TxWait_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxContinue_Ind: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AsnInt       callID;


  AsnBool       *txReqPermission;


  SS_NotificationType       *ssNotification;


   CC_TxContinue_Ind() {Init();}
   void Init(void);
   virtual ~CC_TxContinue_Ind() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxContinue_Ind(const CC_TxContinue_Ind& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxContinue_Ind"; }
  AsnType		*Clone() const;

  CC_TxContinue_Ind		&operator = (const CC_TxContinue_Ind &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxContinue_Req: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AddressType       otherParty;


  AsnInt       callID;


   CC_TxContinue_Req() {Init();}
   void Init(void);
   virtual ~CC_TxContinue_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxContinue_Req(const CC_TxContinue_Req& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxContinue_Req"; }
  AsnType		*Clone() const;

  CC_TxContinue_Req		&operator = (const CC_TxContinue_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_TxContinue_Ack: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  AddressType       otherParty;


  AsnInt       callID;


  CC_TxContinue_AckInt       result;


   CC_TxContinue_Ack() {Init();}
   void Init(void);
   virtual ~CC_TxContinue_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_TxContinue_Ack(const CC_TxContinue_Ack& that);
public:
	 virtual const char* typeName() const	{ return "CC_TxContinue_Ack"; }
  AsnType		*Clone() const;

  CC_TxContinue_Ack		&operator = (const CC_TxContinue_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_CancelInclude: public AsnType
{
public:
  AddressType       includeParty;


  TETRA_Address       callingParty;


  AsnInt       include2CallID;


   CC_CancelInclude() {Init();}
   void Init(void);
   virtual ~CC_CancelInclude() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_CancelInclude(const CC_CancelInclude& that);
public:
	 virtual const char* typeName() const	{ return "CC_CancelInclude"; }
  AsnType		*Clone() const;

  CC_CancelInclude		&operator = (const CC_CancelInclude &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Disconnect: public AsnType
{
public:
  AddressType       callParty;


  AsnInt       callID;


  DisconnectType       disconnectCause;


  SS_NotificationType       *ssNotification;


  CallTransferType       *callTransfer;


  SS_AbortCauseType       *ssAbortCause;


  AddressType       *affectedParty;


  AsnBool       *authorizationGranted;


   CC_Disconnect() {Init();}
   void Init(void);
   virtual ~CC_Disconnect() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Disconnect(const CC_Disconnect& that);
public:
	 virtual const char* typeName() const	{ return "CC_Disconnect"; }
  AsnType		*Clone() const;

  CC_Disconnect		&operator = (const CC_Disconnect &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_Disconnect_Ack: public AsnType
{
public:
  AddressType       callParty;


  AsnInt       callID;


  DisconnectType       disconnectCause;


  CallTransferType       *callTransfer;


   CC_Disconnect_Ack() {Init();}
   void Init(void);
   virtual ~CC_Disconnect_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_Disconnect_Ack(const CC_Disconnect_Ack& that);
public:
	 virtual const char* typeName() const	{ return "CC_Disconnect_Ack"; }
  AsnType		*Clone() const;

  CC_Disconnect_Ack		&operator = (const CC_Disconnect_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  CC_DialupLine_Info: public AsnType
{
public:
  DialupLineType       dialupLineInfo;


  AsnInt       dialupLineHandle;


  CC_DialupLine_InfoInt       dialupLineState;


   CC_DialupLine_Info() {Init();}
   void Init(void);
   virtual ~CC_DialupLine_Info() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   CC_DialupLine_Info(const CC_DialupLine_Info& that);
public:
	 virtual const char* typeName() const	{ return "CC_DialupLine_Info"; }
  AsnType		*Clone() const;

  CC_DialupLine_Info		&operator = (const CC_DialupLine_Info &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_GroupAttach: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  TETRA_Address       groupSSI;


   SS_GroupAttach() {Init();}
   void Init(void);
   virtual ~SS_GroupAttach() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_GroupAttach(const SS_GroupAttach& that);
public:
	 virtual const char* typeName() const	{ return "SS_GroupAttach"; }
  AsnType		*Clone() const;

  SS_GroupAttach		&operator = (const SS_GroupAttach &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_GroupAttach_Ack: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  TETRA_Address       groupSSI;


  SS_GroupAttach_AckInt       result;


   SS_GroupAttach_Ack() {Init();}
   void Init(void);
   virtual ~SS_GroupAttach_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_GroupAttach_Ack(const SS_GroupAttach_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_GroupAttach_Ack"; }
  AsnType		*Clone() const;

  SS_GroupAttach_Ack		&operator = (const SS_GroupAttach_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_GroupDetach: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  TETRA_Address       groupSSI;


   SS_GroupDetach() {Init();}
   void Init(void);
   virtual ~SS_GroupDetach() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_GroupDetach(const SS_GroupDetach& that);
public:
	 virtual const char* typeName() const	{ return "SS_GroupDetach"; }
  AsnType		*Clone() const;

  SS_GroupDetach		&operator = (const SS_GroupDetach &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_GroupDetach_Ack: public AsnType
{
public:
  TETRA_Address       callPartySSI;


  TETRA_Address       groupSSI;


  SS_GroupDetach_AckInt       result;


   SS_GroupDetach_Ack() {Init();}
   void Init(void);
   virtual ~SS_GroupDetach_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_GroupDetach_Ack(const SS_GroupDetach_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_GroupDetach_Ack"; }
  AsnType		*Clone() const;

  SS_GroupDetach_Ack		&operator = (const SS_GroupDetach_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupAdd: public AsnType
{
public:
  TETRA_Address       dynGroupSSI;


  SS_DynGroupAddSeqOf       affectedSSI;


  SS_DynGroupAddInt       *groupAttachmentMode;


  class  MnemonicGroupName: public AsnOcts  {
		public:
			MnemonicGroupName ():AsnOcts() { }
			MnemonicGroupName (const char *str):AsnOcts(str) { }
			MnemonicGroupName (const char *str, const size_t len):AsnOcts(str, len) { }
			MnemonicGroupName (const MnemonicGroupName &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			MnemonicGroupName		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			MnemonicGroupName		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  MnemonicGroupName		*mnemonicGroupName;



  SS_DynGroupAddInt1       *classOfUsage;


   SS_DynGroupAdd() {Init();}
   void Init(void);
   virtual ~SS_DynGroupAdd() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupAdd(const SS_DynGroupAdd& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupAdd"; }
  AsnType		*Clone() const;

  SS_DynGroupAdd		&operator = (const SS_DynGroupAdd &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupDel: public AsnType
{
public:
  TETRA_Address       dynGroupSSI;


  SS_DynGroupDelSeqOf       affectedSSI;


   SS_DynGroupDel() {Init();}
   void Init(void);
   virtual ~SS_DynGroupDel() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupDel(const SS_DynGroupDel& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupDel"; }
  AsnType		*Clone() const;

  SS_DynGroupDel		&operator = (const SS_DynGroupDel &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupAdd_Ack: public AsnType
{
public:
  TETRA_Address       dynGroupSSI;


  SS_DynGroupAdd_AckInt       resultOfAssignment;


  TETRA_Address       *affectedSSI;


  SS_DynGroupAdd_AckInt1       *resultOfAttachment;


   SS_DynGroupAdd_Ack() {Init();}
   void Init(void);
   virtual ~SS_DynGroupAdd_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupAdd_Ack(const SS_DynGroupAdd_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupAdd_Ack"; }
  AsnType		*Clone() const;

  SS_DynGroupAdd_Ack		&operator = (const SS_DynGroupAdd_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupDel_Ack: public AsnType
{
public:
  TETRA_Address       dynGroupSSI;


  SS_DynGroupDel_AckInt       resultOfDeassignment;


  TETRA_Address       *affectedSSI;


   SS_DynGroupDel_Ack() {Init();}
   void Init(void);
   virtual ~SS_DynGroupDel_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupDel_Ack(const SS_DynGroupDel_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupDel_Ack"; }
  AsnType		*Clone() const;

  SS_DynGroupDel_Ack		&operator = (const SS_DynGroupDel_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupInterrogate: public AsnType
{
public:
  TETRA_Address       dynGroupSSI;


   SS_DynGroupInterrogate() {Init();}
   void Init(void);
   virtual ~SS_DynGroupInterrogate() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupInterrogate(const SS_DynGroupInterrogate& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupInterrogate"; }
  AsnType		*Clone() const;

  SS_DynGroupInterrogate		&operator = (const SS_DynGroupInterrogate &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupInterrogate_Ack: public AsnType
{
public:
  TETRA_Address       dynGroupSSI;


  AsnInt       numberOfMembers;


  SS_DynGroupInterrogate_AckSeqOf       memberState;


   SS_DynGroupInterrogate_Ack() {Init();}
   void Init(void);
   virtual ~SS_DynGroupInterrogate_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupInterrogate_Ack(const SS_DynGroupInterrogate_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupInterrogate_Ack"; }
  AsnType		*Clone() const;

  SS_DynGroupInterrogate_Ack		&operator = (const SS_DynGroupInterrogate_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupAssign: public AsnType
{
public:
  TETRA_Address       applicationSSI;


  TETRA_Address       dynGroupSSI;


  SS_DynGroupAssignInt       groupAttachmentMode;


  class  MnemonicGroupName: public AsnOcts  {
		public:
			MnemonicGroupName ():AsnOcts() { }
			MnemonicGroupName (const char *str):AsnOcts(str) { }
			MnemonicGroupName (const char *str, const size_t len):AsnOcts(str, len) { }
			MnemonicGroupName (const MnemonicGroupName &o):AsnOcts(o){ }
			const SizeConstraint* SizeConstraints(int &sizeList)const;

			MnemonicGroupName		&operator = (const AsnOcts &o)
			    { SetEqual(o);  return *this;}
			MnemonicGroupName		&operator = (const char *str)
				{ SetEqual(str); return *this; }
  };

  MnemonicGroupName		*mnemonicGroupName;



  SS_DynGroupAssignInt1       *classOfUsage;


   SS_DynGroupAssign() {Init();}
   void Init(void);
   virtual ~SS_DynGroupAssign() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupAssign(const SS_DynGroupAssign& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupAssign"; }
  AsnType		*Clone() const;

  SS_DynGroupAssign		&operator = (const SS_DynGroupAssign &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupAssign_Ack: public AsnType
{
public:
  TETRA_Address       applicationSSI;


  TETRA_Address       dynGroupSSI;


  SS_DynGroupAssign_AckInt       resultOfAssignment;


  SS_DynGroupAssign_AckInt1       resultOfAttachment;


   SS_DynGroupAssign_Ack() {Init();}
   void Init(void);
   virtual ~SS_DynGroupAssign_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupAssign_Ack(const SS_DynGroupAssign_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupAssign_Ack"; }
  AsnType		*Clone() const;

  SS_DynGroupAssign_Ack		&operator = (const SS_DynGroupAssign_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupDeassign: public AsnType
{
public:
  TETRA_Address       applicationSSI;


  TETRA_Address       dynGroupSSI;


   SS_DynGroupDeassign() {Init();}
   void Init(void);
   virtual ~SS_DynGroupDeassign() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupDeassign(const SS_DynGroupDeassign& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupDeassign"; }
  AsnType		*Clone() const;

  SS_DynGroupDeassign		&operator = (const SS_DynGroupDeassign &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_DynGroupDeassign_Ack: public AsnType
{
public:
  TETRA_Address       applicationSSI;


  TETRA_Address       dynGroupSSI;


  SS_DynGroupDeassign_AckInt       resultOfDeassignment;


   SS_DynGroupDeassign_Ack() {Init();}
   void Init(void);
   virtual ~SS_DynGroupDeassign_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_DynGroupDeassign_Ack(const SS_DynGroupDeassign_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_DynGroupDeassign_Ack"; }
  AsnType		*Clone() const;

  SS_DynGroupDeassign_Ack		&operator = (const SS_DynGroupDeassign_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_CallForwardActivate: public AsnType
{
public:
  TETRA_Address       forwardedPartySSI;


  AddressType       forwardToParty;


  CallForwardingType       forwardingType;


  ForwardingServiceType       forwardingService;


   SS_CallForwardActivate() {Init();}
   void Init(void);
   virtual ~SS_CallForwardActivate() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_CallForwardActivate(const SS_CallForwardActivate& that);
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardActivate"; }
  AsnType		*Clone() const;

  SS_CallForwardActivate		&operator = (const SS_CallForwardActivate &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_CallForwardActivate_Ack: public AsnType
{
public:
  TETRA_Address       forwardedPartySSI;


  AddressType       forwardToParty;


  CallForwardingType       forwardingType;


  ForwardingServiceType       forwardingService;


  CallForwardingResultType       forwardingResult;


   SS_CallForwardActivate_Ack() {Init();}
   void Init(void);
   virtual ~SS_CallForwardActivate_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_CallForwardActivate_Ack(const SS_CallForwardActivate_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardActivate_Ack"; }
  AsnType		*Clone() const;

  SS_CallForwardActivate_Ack		&operator = (const SS_CallForwardActivate_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_CallForwardDeactivate: public AsnType
{
public:
  TETRA_Address       forwardedPartySSI;


  CallForwardingType       forwardingType;


   SS_CallForwardDeactivate() {Init();}
   void Init(void);
   virtual ~SS_CallForwardDeactivate() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_CallForwardDeactivate(const SS_CallForwardDeactivate& that);
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardDeactivate"; }
  AsnType		*Clone() const;

  SS_CallForwardDeactivate		&operator = (const SS_CallForwardDeactivate &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_CallForwardDeactivate_Ack: public AsnType
{
public:
  TETRA_Address       forwardedPartySSI;


  CallForwardingType       forwardingType;


  CallForwardingResultType       forwardingResult;


   SS_CallForwardDeactivate_Ack() {Init();}
   void Init(void);
   virtual ~SS_CallForwardDeactivate_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_CallForwardDeactivate_Ack(const SS_CallForwardDeactivate_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardDeactivate_Ack"; }
  AsnType		*Clone() const;

  SS_CallForwardDeactivate_Ack		&operator = (const SS_CallForwardDeactivate_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_CallForwardInterrogate_Ack: public AsnType
{
public:
  FragmentationInfoType       fragmentationInfo;


  SS_CallForwardInterrogate_AckSeqOf       callForwardingEntries;


  AsnInt       *numberOfEntries;


   SS_CallForwardInterrogate_Ack() {Init();}
   void Init(void);
   virtual ~SS_CallForwardInterrogate_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_CallForwardInterrogate_Ack(const SS_CallForwardInterrogate_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_CallForwardInterrogate_Ack"; }
  AsnType		*Clone() const;

  SS_CallForwardInterrogate_Ack		&operator = (const SS_CallForwardInterrogate_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_ObjectIdentityAssign: public AsnType
{
public:
  ISDN_Address       assignedOOCI;


  TETRA_Address       affectedPartySSI;


  UseOociAsCliType       *useOociAsCLI;


   SS_ObjectIdentityAssign() {Init();}
   void Init(void);
   virtual ~SS_ObjectIdentityAssign() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_ObjectIdentityAssign(const SS_ObjectIdentityAssign& that);
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityAssign"; }
  AsnType		*Clone() const;

  SS_ObjectIdentityAssign		&operator = (const SS_ObjectIdentityAssign &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_ObjectIdentityAssign_Ack: public AsnType
{
public:
  ISDN_Address       assignedOOCI;


  TETRA_Address       affectedPartySSI;


  UseOociAsCliType       useOociAsCLI;


  OociResultType       assingmentResult;


   SS_ObjectIdentityAssign_Ack() {Init();}
   void Init(void);
   virtual ~SS_ObjectIdentityAssign_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_ObjectIdentityAssign_Ack(const SS_ObjectIdentityAssign_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityAssign_Ack"; }
  AsnType		*Clone() const;

  SS_ObjectIdentityAssign_Ack		&operator = (const SS_ObjectIdentityAssign_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_ObjectIdentityDeassign: public AsnType
{
public:
  ISDN_Address       assignedOOCI;


  SS_ObjectIdentityDeassignInt       *typeOfDeassignment;


   SS_ObjectIdentityDeassign() {Init();}
   void Init(void);
   virtual ~SS_ObjectIdentityDeassign() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_ObjectIdentityDeassign(const SS_ObjectIdentityDeassign& that);
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityDeassign"; }
  AsnType		*Clone() const;

  SS_ObjectIdentityDeassign		&operator = (const SS_ObjectIdentityDeassign &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_ObjectIdentityDeassign_Ack: public AsnType
{
public:
  ISDN_Address       assignedOOCI;


  OociResultType       deassingmentResult;


   SS_ObjectIdentityDeassign_Ack() {Init();}
   void Init(void);
   virtual ~SS_ObjectIdentityDeassign_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_ObjectIdentityDeassign_Ack(const SS_ObjectIdentityDeassign_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityDeassign_Ack"; }
  AsnType		*Clone() const;

  SS_ObjectIdentityDeassign_Ack		&operator = (const SS_ObjectIdentityDeassign_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  SS_ObjectIdentityInterrogate_Ack: public AsnType
{
public:
  SSIType       gatewaySSI;


  FragmentationInfoType       fragmentationInfo;


  SS_ObjectIdentityInterrogate_AckSeqOf       oociEntries;


  AsnInt       *numberOfEntries;


   SS_ObjectIdentityInterrogate_Ack() {Init();}
   void Init(void);
   virtual ~SS_ObjectIdentityInterrogate_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   SS_ObjectIdentityInterrogate_Ack(const SS_ObjectIdentityInterrogate_Ack& that);
public:
	 virtual const char* typeName() const	{ return "SS_ObjectIdentityInterrogate_Ack"; }
  AsnType		*Clone() const;

  SS_ObjectIdentityInterrogate_Ack		&operator = (const SS_ObjectIdentityInterrogate_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Monitoring_Req: public AsnType
{
public:
  MonitoringService       monServices;


  TETRA_Address       monBeginSSI;


  TETRA_Address       *monEndSSI;


  AsnInt       *monHandle;


  GeneralizedTime       *monStartTime;


  GeneralizedTime       *monEndTime;


  AsnBool       *monPersistentData;


   MON_Monitoring_Req() {Init();}
   void Init(void);
   virtual ~MON_Monitoring_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Monitoring_Req(const MON_Monitoring_Req& that);
public:
	 virtual const char* typeName() const	{ return "MON_Monitoring_Req"; }
  AsnType		*Clone() const;

  MON_Monitoring_Req		&operator = (const MON_Monitoring_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Monitoring_Ack: public AsnType
{
public:
  AsnInt       monHandle;


  MonitoringService       monServices;


  TETRA_Address       monBeginSSI;


  TETRA_Address       *monEndSSI;


  AsnInt       *countMonParties;


  GeneralizedTime       *monStartTime;


  GeneralizedTime       *monEndTime;


  AsnBool       *persistentData;


   MON_Monitoring_Ack() {Init();}
   void Init(void);
   virtual ~MON_Monitoring_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Monitoring_Ack(const MON_Monitoring_Ack& that);
public:
	 virtual const char* typeName() const	{ return "MON_Monitoring_Ack"; }
  AsnType		*Clone() const;

  MON_Monitoring_Ack		&operator = (const MON_Monitoring_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Close: public AsnType
{
public:
  AsnInt       monHandle;


  MonitoringService       monServices;


  MON_CloseInt       result;


  TETRA_Address       monBeginSSI;


  TETRA_Address       *monEndSSI;


  AsnInt       *monFleet;


   MON_Close() {Init();}
   void Init(void);
   virtual ~MON_Close() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Close(const MON_Close& that);
public:
	 virtual const char* typeName() const	{ return "MON_Close"; }
  AsnType		*Clone() const;

  MON_Close		&operator = (const MON_Close &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_LocationUpdate: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  TETRA_Address       monSSI;


  LocUpdateType       locationUpdate;


  AsnBool       appendLocationArea;


  LocationAreaType       locationArea;


  GeneralizedTime       timeStamp;


   MON_LocationUpdate() {Init();}
   void Init(void);
   virtual ~MON_LocationUpdate() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_LocationUpdate(const MON_LocationUpdate& that);
public:
	 virtual const char* typeName() const	{ return "MON_LocationUpdate"; }
  AsnType		*Clone() const;

  MON_LocationUpdate		&operator = (const MON_LocationUpdate &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_LocationDetach: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  TETRA_Address       monSSI;


  LocationAreaType       locationArea;


  GeneralizedTime       timeStamp;


   MON_LocationDetach() {Init();}
   void Init(void);
   virtual ~MON_LocationDetach() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_LocationDetach(const MON_LocationDetach& that);
public:
	 virtual const char* typeName() const	{ return "MON_LocationDetach"; }
  AsnType		*Clone() const;

  MON_LocationDetach		&operator = (const MON_LocationDetach &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_SDS_Data: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  AddressType       calledParty;


  AddressType       callingParty;


  Integer16       sdsHandle;


  SDSDataType       sdsData;


  LocationAreaType       sourceLocation;


  GeneralizedTime       timeStamp;


  AsnBool       *acknowlegeExpected;


  MacFacilityType       *macFacility;


   MON_SDS_Data() {Init();}
   void Init(void);
   virtual ~MON_SDS_Data() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_SDS_Data(const MON_SDS_Data& that);
public:
	 virtual const char* typeName() const	{ return "MON_SDS_Data"; }
  AsnType		*Clone() const;

  MON_SDS_Data		&operator = (const MON_SDS_Data &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_SDS_Ack: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  AddressType       calledParty;


  AddressType       callingParty;


  Integer16       sdsHandle;


  MON_SDS_AckInt       result;


  GeneralizedTime       timeStamp;


   MON_SDS_Ack() {Init();}
   void Init(void);
   virtual ~MON_SDS_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_SDS_Ack(const MON_SDS_Ack& that);
public:
	 virtual const char* typeName() const	{ return "MON_SDS_Ack"; }
  AsnType		*Clone() const;

  MON_SDS_Ack		&operator = (const MON_SDS_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_CC_Information: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  AddressType       calledParty;


  AddressType       callingParty;


  AsnInt       callID;


  MonCallStateType       callState;


  AsnBool       hookSignalling;


  AsnBool       duplexMode;


  GeneralizedTime       timeStamp;


  AreaType       *areaSelection;


  TetraCallTime       *callTimeOut;


  CallPriorityType       *callPriority;


  AsnBool       *requestToTransmit;


  SS_NotificationType       *ssNotification;


  DisconnectType       *disconnectCause;


  LocationAreaType       *callingLocationArea;


  LocationAreaType       *calledLocationArea;


  BasicServiceType       *basicService;


  AddressType       *groupMemberParty;


  AsnInt       *elapsedTime;


  AsnInt       *remainingTime;


  CliType       *cliControl;


   MON_CC_Information() {Init();}
   void Init(void);
   virtual ~MON_CC_Information() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_CC_Information(const MON_CC_Information& that);
public:
	 virtual const char* typeName() const	{ return "MON_CC_Information"; }
  AsnType		*Clone() const;

  MON_CC_Information		&operator = (const MON_CC_Information &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_TxDemand: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  TETRA_Address       demandPartySSI;


  AsnInt       callID;


  GeneralizedTime       timeStamp;


  TxPriorityType       *txPriority;


  AsnBool       *encryption;


   MON_TxDemand() {Init();}
   void Init(void);
   virtual ~MON_TxDemand() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_TxDemand(const MON_TxDemand& that);
public:
	 virtual const char* typeName() const	{ return "MON_TxDemand"; }
  AsnType		*Clone() const;

  MON_TxDemand		&operator = (const MON_TxDemand &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Uplink_TxDemand: public AsnType
{
public:
  AsnInt       monHandle;


  TETRA_Address       demandPartySSI;


  AsnInt       callID;


  TxPriorityType       *txPriority;


  AsnBool       *encryption;


  LineInformationType       *lineInformation;


  AsnBool       *noNfLoopBack;


   MON_Uplink_TxDemand() {Init();}
   void Init(void);
   virtual ~MON_Uplink_TxDemand() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Uplink_TxDemand(const MON_Uplink_TxDemand& that);
public:
	 virtual const char* typeName() const	{ return "MON_Uplink_TxDemand"; }
  AsnType		*Clone() const;

  MON_Uplink_TxDemand		&operator = (const MON_Uplink_TxDemand &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_TxCeased: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  TETRA_Address       callPartySSI;


  AsnInt       callID;


  GeneralizedTime       timeStamp;


  AsnBool       *txReqPermission;


   MON_TxCeased() {Init();}
   void Init(void);
   virtual ~MON_TxCeased() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_TxCeased(const MON_TxCeased& that);
public:
	 virtual const char* typeName() const	{ return "MON_TxCeased"; }
  AsnType		*Clone() const;

  MON_TxCeased		&operator = (const MON_TxCeased &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Uplink_TxCeased: public AsnType
{
public:
  AsnInt       monHandle;


  AddressType       callParty;


  AsnInt       callID;


  AsnBool       *txReqPermission;


  SS_NotificationType       *ssNotification;


   MON_Uplink_TxCeased() {Init();}
   void Init(void);
   virtual ~MON_Uplink_TxCeased() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Uplink_TxCeased(const MON_Uplink_TxCeased& that);
public:
	 virtual const char* typeName() const	{ return "MON_Uplink_TxCeased"; }
  AsnType		*Clone() const;

  MON_Uplink_TxCeased		&operator = (const MON_Uplink_TxCeased &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_TxGrant: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  TETRA_Address       callPartySSI;


  AddressType       transmittingParty;


  AsnInt       callID;


  TxGrantType       txGrant;


  GeneralizedTime       timeStamp;


  AsnBool       *txReqPermission;


  AsnBool       *encryption;


  CliType       *tpiRestriction;


   MON_TxGrant() {Init();}
   void Init(void);
   virtual ~MON_TxGrant() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_TxGrant(const MON_TxGrant& that);
public:
	 virtual const char* typeName() const	{ return "MON_TxGrant"; }
  AsnType		*Clone() const;

  MON_TxGrant		&operator = (const MON_TxGrant &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Disconnect: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  AddressType       disconnectedPartySSI;


  AsnInt       callID;


  DisconnectType       disconnectCause;


  GeneralizedTime       timeStamp;


  AsnBool       *callEnd;


   MON_Disconnect() {Init();}
   void Init(void);
   virtual ~MON_Disconnect() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Disconnect(const MON_Disconnect& that);
public:
	 virtual const char* typeName() const	{ return "MON_Disconnect"; }
  AsnType		*Clone() const;

  MON_Disconnect		&operator = (const MON_Disconnect &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Intercept_Req: public AsnType
{
public:
  AsnInt       monHandle;


  TETRA_Address       callPartySSI;


  AsnInt       callID;


  LineInformationType       lineInformation1;


  BasicServiceType       *basicService;


  LineInformationType       *lineInformation2;


   MON_Intercept_Req() {Init();}
   void Init(void);
   virtual ~MON_Intercept_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Intercept_Req(const MON_Intercept_Req& that);
public:
	 virtual const char* typeName() const	{ return "MON_Intercept_Req"; }
  AsnType		*Clone() const;

  MON_Intercept_Req		&operator = (const MON_Intercept_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Intercept_Ack: public AsnType
{
public:
  AsnInt       monHandle;


  TETRA_Address       callPartySSI;


  AddressType       interceptSSI1;


  AddressType       interceptSSI2;


  AsnInt       callID;


  AsnBool       duplexMode;


  LineInfoAckType       lineInfoAck1;


  BasicServiceType       *basicService;


  LineInfoAckType       *lineInfoAck2;


   MON_Intercept_Ack() {Init();}
   void Init(void);
   virtual ~MON_Intercept_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Intercept_Ack(const MON_Intercept_Ack& that);
public:
	 virtual const char* typeName() const	{ return "MON_Intercept_Ack"; }
  AsnType		*Clone() const;

  MON_Intercept_Ack		&operator = (const MON_Intercept_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Intercept_Connect: public AsnType
{
public:
  AsnInt       monHandle;


  TETRA_Address       callPartySSI;


  AsnInt       callID;


  AsnBool       duplexMode;


  TxGrantType       *txGrant;


  CallPriorityType       *callPriority;


  BasicServiceType       *basicService;


  LineInfoAckType       *lineInfoAck1;


  LineInfoAckType       *lineInfoAck2;


   MON_Intercept_Connect() {Init();}
   void Init(void);
   virtual ~MON_Intercept_Connect() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Intercept_Connect(const MON_Intercept_Connect& that);
public:
	 virtual const char* typeName() const	{ return "MON_Intercept_Connect"; }
  AsnType		*Clone() const;

  MON_Intercept_Connect		&operator = (const MON_Intercept_Connect &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Intercept_Disconnect: public AsnType
{
public:
  AsnInt       monHandle;


  AddressType       disconnectedPartySSI;


  AsnInt       callID;


  DisconnectType       disconnectCause;


   MON_Intercept_Disconnect() {Init();}
   void Init(void);
   virtual ~MON_Intercept_Disconnect() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Intercept_Disconnect(const MON_Intercept_Disconnect& that);
public:
	 virtual const char* typeName() const	{ return "MON_Intercept_Disconnect"; }
  AsnType		*Clone() const;

  MON_Intercept_Disconnect		&operator = (const MON_Intercept_Disconnect &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_Intercept_Disconnect_Ack: public AsnType
{
public:
  AsnInt       monHandle;


  AddressType       disconnectedPartySSI;


  AsnInt       callID;


  DisconnectType       disconnectCause;


   MON_Intercept_Disconnect_Ack() {Init();}
   void Init(void);
   virtual ~MON_Intercept_Disconnect_Ack() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_Intercept_Disconnect_Ack(const MON_Intercept_Disconnect_Ack& that);
public:
	 virtual const char* typeName() const	{ return "MON_Intercept_Disconnect_Ack"; }
  AsnType		*Clone() const;

  MON_Intercept_Disconnect_Ack		&operator = (const MON_Intercept_Disconnect_Ack &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  MON_TxInterrupt: public AsnType
{
public:
  AsnInt       monHandle;


  AsnInt       monMessageID;


  TETRA_Address       callPartySSI;


  AddressType       transmittingParty;


  AsnInt       callID;


  TxGrantType       txGrant;


  AsnBool       *txReqPermission;


  AsnBool       *encryption;


  CliType       *tpiRestriction;


   MON_TxInterrupt() {Init();}
   void Init(void);
   virtual ~MON_TxInterrupt() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   MON_TxInterrupt(const MON_TxInterrupt& that);
public:
	 virtual const char* typeName() const	{ return "MON_TxInterrupt"; }
  AsnType		*Clone() const;

  MON_TxInterrupt		&operator = (const MON_TxInterrupt &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  RSM_ResourceMonitoring_Req: public AsnType
{
public:
  AsnBool       systemConnectionReq;


  AsnBool       resourceLoadReq;


  RSM_ResourceMonitoring_ReqSeqOf       lineResourceStateReq;


  AsnBool       stateChangeIndReq;


  AsnInt       *rsmHandle;


   RSM_ResourceMonitoring_Req() {Init();}
   void Init(void);
   virtual ~RSM_ResourceMonitoring_Req() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   RSM_ResourceMonitoring_Req(const RSM_ResourceMonitoring_Req& that);
public:
	 virtual const char* typeName() const	{ return "RSM_ResourceMonitoring_Req"; }
  AsnType		*Clone() const;

  RSM_ResourceMonitoring_Req		&operator = (const RSM_ResourceMonitoring_Req &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  RSM_ResourceState_Ind: public AsnType
{
public:
  AsnInt       rsmHandle;


  RSM_ResourceState_IndSeqOf       *connectionState;


  RSM_ResourceState_IndSeqOf1       *resourceLoad;


  RSM_ResourceState_IndSeqOf2       *lineResourceState;


   RSM_ResourceState_Ind() {Init();}
   void Init(void);
   virtual ~RSM_ResourceState_Ind() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   RSM_ResourceState_Ind(const RSM_ResourceState_Ind& that);
public:
	 virtual const char* typeName() const	{ return "RSM_ResourceState_Ind"; }
  AsnType		*Clone() const;

  RSM_ResourceState_Ind		&operator = (const RSM_ResourceState_Ind &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_PDUChoice: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     name_ACAPI_OpenServiceCid = 0,
     name_ACAPI_OpenService_AckCid = 1,
     name_ACAPI_CloseServiceCid = 2,
     name_ACAPI_CloseService_AckCid = 3,
     name_ACAPI_Authorization_ReqCid = 4,
     name_ACAPI_AuthorizationCid = 5,
     name_ACAPI_Message_AckCid = 6,
     name_ACAPI_Error_InfoCid = 7,
     name_SDS_DataCid = 8,
     name_SDS_Data_AckCid = 9,
     name_CC_Setup_ReqCid = 10,
     name_CC_SetupInclude_ReqCid = 11,
     name_CC_Setup_IndCid = 12,
     name_CC_Setup_AckCid = 13,
     name_CC_InformationCid = 14,
     name_CC_Connect_ReqCid = 15,
     name_CC_Connect_IndCid = 16,
     name_CC_Connect_AckCid = 17,
     name_CC_TxDemandCid = 18,
     name_CC_TxGrantCid = 19,
     name_CC_TxCeasedCid = 20,
     name_CC_TxInterruptCid = 21,
     name_CC_TxWait_IndCid = 22,
     name_CC_TxWait_ReqCid = 23,
     name_CC_TxWait_AckCid = 24,
     name_CC_TxContinue_IndCid = 25,
     name_CC_TxContinue_ReqCid = 26,
     name_CC_TxContinue_AckCid = 27,
     name_CC_DisconnectCid = 28,
     name_CC_Disconnect_AckCid = 29,
     name_CC_DialupLine_InfoCid = 30,
     name_CC_ForcedCallEndCid = 31,
     name_CC_ForcedCallEnd_AckCid = 32,
     name_CC_CancelIncludeCid = 33,
     name_SS_GroupAttachCid = 34,
     name_SS_GroupAttach_AckCid = 35,
     name_SS_GroupDetachCid = 36,
     name_SS_GroupDetach_AckCid = 37,
     name_SS_DynGroupAddCid = 38,
     name_SS_DynGroupDelCid = 39,
     name_SS_DynGroupAdd_AckCid = 40,
     name_SS_DynGroupDel_AckCid = 41,
     name_SS_DynGroupInterrogateCid = 42,
     name_SS_DynGroupInterrogate_AckCid = 43,
     name_SS_DynGroupAssignCid = 44,
     name_SS_DynGroupAssign_AckCid = 45,
     name_SS_DynGroupDeassignCid = 46,
     name_SS_DynGroupDeassign_AckCid = 47,
     name_SS_CallForwardActivateCid = 48,
     name_SS_CallForwardActivate_AckCid = 49,
     name_SS_CallForwardDeactivateCid = 50,
     name_SS_CallForwardDeactivate_AckCid = 51,
     name_SS_CallForwardCancelAllCid = 52,
     name_SS_CallForwardCancel_AckCid = 53,
     name_SS_CallForwardInterrogateCid = 54,
     name_SS_CallForwardInterrogate_AckCid = 55,
     name_SS_ObjectIdentityAssignCid = 56,
     name_SS_ObjectIdentityAssign_AckCid = 57,
     name_SS_ObjectIdentityDeassignCid = 58,
     name_SS_ObjectIdentityDeassign_AckCid = 59,
     name_SS_ObjectIdentityCancelGatewayCid = 60,
     name_SS_ObjectIdentityCancelGateway_AckCid = 61,
     name_SS_ObjectIdentityInterrogateCid = 62,
     name_SS_ObjectIdentityInterrogate_AckCid = 63,
     name_MON_Monitoring_ReqCid = 64,
     name_MON_Monitoring_AckCid = 65,
     name_MON_FleetMonitoring_ReqCid = 66,
     name_MON_FleetMonitoring_AckCid = 67,
     name_MON_Data_AckCid = 68,
     name_MON_CloseCid = 69,
     name_MON_Close_AckCid = 70,
     name_MON_LocationUpdateCid = 71,
     name_MON_LocationDetachCid = 72,
     name_MON_SDS_DataCid = 73,
     name_MON_SDS_AckCid = 74,
     name_MON_CC_InformationCid = 75,
     name_MON_TxDemandCid = 76,
     name_MON_TxCeasedCid = 77,
     name_MON_TxGrantCid = 78,
     name_MON_DisconnectCid = 79,
     name_MON_Intercept_ReqCid = 80,
     name_MON_Intercept_AckCid = 81,
     name_MON_Intercept_ConnectCid = 82,
     name_MON_Intercept_DisconnectCid = 83,
     name_MON_Intercept_Disconnect_AckCid = 84,
     name_MON_ForcedCallEndCid = 85,
     name_MON_ForcedCallEnd_AckCid = 86,
     name_MON_Uplink_TxDemandCid = 87,
     name_MON_Uplink_TxCeasedCid = 88,
     name_MON_TxInterruptCid = 89,
     name_RSM_ResourceMonitoring_ReqCid = 90,
     name_RSM_ResourceState_IndCid = 91,
     name_RSM_ResourceMonitoring_CloseCid = 92
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
  ACAPI_OpenService       *name_ACAPI_OpenService;

  ACAPI_OpenService_Ack       *name_ACAPI_OpenService_Ack;

  ACAPI_CloseService       *name_ACAPI_CloseService;

  ACAPI_CloseService_Ack       *name_ACAPI_CloseService_Ack;

  ACAPI_Authorization_Req       *name_ACAPI_Authorization_Req;

  ACAPI_Authorization       *name_ACAPI_Authorization;

  ACAPI_Message_Ack       *name_ACAPI_Message_Ack;

  ACAPI_Error_Info       *name_ACAPI_Error_Info;

  SDS_Data       *name_SDS_Data;

  SDS_Data_Ack       *name_SDS_Data_Ack;

  CC_Setup_Req       *name_CC_Setup_Req;

  CC_SetupInclude_Req       *name_CC_SetupInclude_Req;

  CC_Setup_Ind       *name_CC_Setup_Ind;

  CC_Setup_Ack       *name_CC_Setup_Ack;

  CC_Information       *name_CC_Information;

  CC_Connect_Req       *name_CC_Connect_Req;

  CC_Connect_Ind       *name_CC_Connect_Ind;

  CC_Connect_Ack       *name_CC_Connect_Ack;

  CC_TxDemand       *name_CC_TxDemand;

  CC_TxGrant       *name_CC_TxGrant;

  CC_TxCeased       *name_CC_TxCeased;

  CC_TxInterrupt       *name_CC_TxInterrupt;

  CC_TxWait_Ind       *name_CC_TxWait_Ind;

  CC_TxWait_Req       *name_CC_TxWait_Req;

  CC_TxWait_Ack       *name_CC_TxWait_Ack;

  CC_TxContinue_Ind       *name_CC_TxContinue_Ind;

  CC_TxContinue_Req       *name_CC_TxContinue_Req;

  CC_TxContinue_Ack       *name_CC_TxContinue_Ack;

  CC_Disconnect       *name_CC_Disconnect;

  CC_Disconnect_Ack       *name_CC_Disconnect_Ack;

  CC_DialupLine_Info       *name_CC_DialupLine_Info;

  CC_ForcedCallEnd       *name_CC_ForcedCallEnd;

  CC_ForcedCallEnd_Ack       *name_CC_ForcedCallEnd_Ack;

  CC_CancelInclude       *name_CC_CancelInclude;

  SS_GroupAttach       *name_SS_GroupAttach;

  SS_GroupAttach_Ack       *name_SS_GroupAttach_Ack;

  SS_GroupDetach       *name_SS_GroupDetach;

  SS_GroupDetach_Ack       *name_SS_GroupDetach_Ack;

  SS_DynGroupAdd       *name_SS_DynGroupAdd;

  SS_DynGroupDel       *name_SS_DynGroupDel;

  SS_DynGroupAdd_Ack       *name_SS_DynGroupAdd_Ack;

  SS_DynGroupDel_Ack       *name_SS_DynGroupDel_Ack;

  SS_DynGroupInterrogate       *name_SS_DynGroupInterrogate;

  SS_DynGroupInterrogate_Ack       *name_SS_DynGroupInterrogate_Ack;

  SS_DynGroupAssign       *name_SS_DynGroupAssign;

  SS_DynGroupAssign_Ack       *name_SS_DynGroupAssign_Ack;

  SS_DynGroupDeassign       *name_SS_DynGroupDeassign;

  SS_DynGroupDeassign_Ack       *name_SS_DynGroupDeassign_Ack;

  SS_CallForwardActivate       *name_SS_CallForwardActivate;

  SS_CallForwardActivate_Ack       *name_SS_CallForwardActivate_Ack;

  SS_CallForwardDeactivate       *name_SS_CallForwardDeactivate;

  SS_CallForwardDeactivate_Ack       *name_SS_CallForwardDeactivate_Ack;

  SS_CallForwardCancelAll       *name_SS_CallForwardCancelAll;

  SS_CallForwardCancel_Ack       *name_SS_CallForwardCancel_Ack;

  SS_CallForwardInterrogate       *name_SS_CallForwardInterrogate;

  SS_CallForwardInterrogate_Ack       *name_SS_CallForwardInterrogate_Ack;

  SS_ObjectIdentityAssign       *name_SS_ObjectIdentityAssign;

  SS_ObjectIdentityAssign_Ack       *name_SS_ObjectIdentityAssign_Ack;

  SS_ObjectIdentityDeassign       *name_SS_ObjectIdentityDeassign;

  SS_ObjectIdentityDeassign_Ack       *name_SS_ObjectIdentityDeassign_Ack;

  SS_ObjectIdentityCancelGateway       *name_SS_ObjectIdentityCancelGateway;

  SS_ObjectIdentityCancelGateway_Ack       *name_SS_ObjectIdentityCancelGateway_Ack;

  SS_ObjectIdentityInterrogate       *name_SS_ObjectIdentityInterrogate;

  SS_ObjectIdentityInterrogate_Ack       *name_SS_ObjectIdentityInterrogate_Ack;

  MON_Monitoring_Req       *name_MON_Monitoring_Req;

  MON_Monitoring_Ack       *name_MON_Monitoring_Ack;

  MON_FleetMonitoring_Req       *name_MON_FleetMonitoring_Req;

  MON_FleetMonitoring_Ack       *name_MON_FleetMonitoring_Ack;

  MON_Data_Ack       *name_MON_Data_Ack;

  MON_Close       *name_MON_Close;

  MON_Close_Ack       *name_MON_Close_Ack;

  MON_LocationUpdate       *name_MON_LocationUpdate;

  MON_LocationDetach       *name_MON_LocationDetach;

  MON_SDS_Data       *name_MON_SDS_Data;

  MON_SDS_Ack       *name_MON_SDS_Ack;

  MON_CC_Information       *name_MON_CC_Information;

  MON_TxDemand       *name_MON_TxDemand;

  MON_TxCeased       *name_MON_TxCeased;

  MON_TxGrant       *name_MON_TxGrant;

  MON_Disconnect       *name_MON_Disconnect;

  MON_Intercept_Req       *name_MON_Intercept_Req;

  MON_Intercept_Ack       *name_MON_Intercept_Ack;

  MON_Intercept_Connect       *name_MON_Intercept_Connect;

  MON_Intercept_Disconnect       *name_MON_Intercept_Disconnect;

  MON_Intercept_Disconnect_Ack       *name_MON_Intercept_Disconnect_Ack;

  MON_ForcedCallEnd       *name_MON_ForcedCallEnd;

  MON_ForcedCallEnd_Ack       *name_MON_ForcedCallEnd_Ack;

  MON_Uplink_TxDemand       *name_MON_Uplink_TxDemand;

  MON_Uplink_TxCeased       *name_MON_Uplink_TxCeased;

  MON_TxInterrupt       *name_MON_TxInterrupt;

  RSM_ResourceMonitoring_Req       *name_RSM_ResourceMonitoring_Req;

  RSM_ResourceState_Ind       *name_RSM_ResourceState_Ind;

  RSM_ResourceMonitoring_Close       *name_RSM_ResourceMonitoring_Close;

  };


   ACAPI_PDUChoice() {Init();}
   ACAPI_PDUChoice(const ACAPI_PDUChoice& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_PDUChoice"; }
   void Init(void);

   virtual int checkConstraints(ConstraintFailList* pConstraintFails)const;

   virtual ~ACAPI_PDUChoice() {Clear();}

   void Clear();

  AsnType		*Clone() const;

  ACAPI_PDUChoice		&operator = (const ACAPI_PDUChoice &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded /*, s env*/);
  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void			PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_PDU: public AsnType
{
public:
  AsnInt       serviceHandle;


  AsnInt       serviceTxMessageID;


  AsnInt       serviceRxMessageID;


  AsnBool       *priorityFlag;


  ACAPI_PDUChoice       choice;


   ACAPI_PDU() {Init();}
   void Init(void);
   virtual ~ACAPI_PDU() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_PDU(const ACAPI_PDU& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_PDU"; }
  AsnType		*Clone() const;

  ACAPI_PDU		&operator = (const ACAPI_PDU &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_TransportChoice: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     name_ACAPI_PDUCid = 0,
     name_ACAPI_Transport_AckCid = 1
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
  ACAPI_PDU       *name_ACAPI_PDU;

  ACAPI_Transport_Ack       *name_ACAPI_Transport_Ack;

  };


   ACAPI_TransportChoice() {Init();}
   ACAPI_TransportChoice(const ACAPI_TransportChoice& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_TransportChoice"; }
   void Init(void);

   virtual int checkConstraints(ConstraintFailList* pConstraintFails)const;

   virtual ~ACAPI_TransportChoice() {Clear();}

   void Clear();

  AsnType		*Clone() const;

  ACAPI_TransportChoice		&operator = (const ACAPI_TransportChoice &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded /*, s env*/);
  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void			PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


class  ACAPI_Transport: public AsnType
{
public:
  AsnInt       applTxMessageID;


  AsnInt       applRxMessageID;


  AsnBool       *priorityFlag;


  ACAPI_TransportChoice       choice;


   ACAPI_Transport() {Init();}
   void Init(void);
   virtual ~ACAPI_Transport() {Clear();}
   void Clear();

	int checkConstraints(ConstraintFailList* pConstraintFails) const;

   ACAPI_Transport(const ACAPI_Transport& that);
public:
	 virtual const char* typeName() const	{ return "ACAPI_Transport"; }
  AsnType		*Clone() const;

  ACAPI_Transport		&operator = (const ACAPI_Transport &that);
  AsnLen		BEncContent (AsnBuf &_b) const;
  void			BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded);

  AsnLen		BEnc (AsnBuf &_b) const;
  void			BDec (const AsnBuf &_b, AsnLen &bytesDecoded);
	void Print(std::ostream& os, unsigned short indent = 0) const;
  void		PrintXML (std::ostream &os, const char *lpszTitle=NULL) const;
};


#ifndef NO_NAMESPACE
} // namespace close
#endif

#endif /* conditional include of acapi.h */
